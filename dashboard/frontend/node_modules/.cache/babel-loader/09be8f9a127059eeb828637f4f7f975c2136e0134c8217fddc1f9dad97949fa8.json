{"ast":null,"code":"import { getEmojiSequenceFromString, getUnqualifiedEmojiSequence } from \"../cleanup.js\";\nimport { getEmojiSequenceKeyword } from \"../format.js\";\nconst componentStatus = \"component\";\nconst allowedStatus = new Set([componentStatus, \"fully-qualified\", \"minimally-qualified\", \"unqualified\"]);\n/**\n* Get qualified variations from parsed test file\n*\n* Key is unqualified emoji, value is longest fully qualified emoji\n*/\nfunction getQualifiedTestData(data) {\n  const results = Object.create(null);\n  for (const key in data) {\n    const item = data[key];\n    const sequence = getUnqualifiedEmojiSequence(item.sequence);\n    const shortKey = getEmojiSequenceKeyword(sequence);\n    if (!results[shortKey] || results[shortKey].sequence.length < sequence.length) results[shortKey] = item;\n  }\n  return results;\n}\n/**\n* Get all emoji sequences from test file\n*\n* Returns all emojis as UTF-32 sequences, where:\n* \tkey = unqualified sequence (without \\uFE0F)\n* \tvalue = qualified sequence (with \\uFE0F)\n*\n* Duplicate items that have different versions with and without \\uFE0F are\n* listed only once, with unqualified sequence as key and longest possible\n* qualified sequence as value\n*\n* Example of 3 identical entries:\n*  '1F441 FE0F 200D 1F5E8 FE0F'\n*  '1F441 200D 1F5E8 FE0F'\n*  '1F441 FE0F 200D 1F5E8'\n* \t'1F441 200D 1F5E8'\n*\n* Out of these entries, only one item will be returned with:\n* \tkey = '1f441-200d-1f5e8' (converted to lower case, separated with dash)\n* \tvalue.sequence = [0x1F441, 0xFE0F, 0x200D, 0x1F5E8, 0xFE0F]\n* \tvalue.status = 'fully-qualified'\n* \tother properties in value are identical for all versions\n*/\nfunction parseEmojiTestFile(data) {\n  const results = Object.create(null);\n  let group;\n  let subgroup;\n  data.split(\"\\n\").forEach(line => {\n    line = line.trim();\n    const parts = line.split(\"#\");\n    if (parts.length < 2) return;\n    const firstChunk = parts.shift().trim();\n    const secondChunk = parts.join(\"#\").trim();\n    if (!firstChunk) {\n      const commentParts = secondChunk.split(\":\");\n      if (commentParts.length === 2) {\n        const key$1 = commentParts[0].trim();\n        const value = commentParts[1].trim();\n        switch (key$1) {\n          case \"group\":\n            group = value;\n            subgroup = void 0;\n            break;\n          case \"subgroup\":\n            subgroup = value;\n            break;\n        }\n      }\n      return;\n    }\n    if (!group || !subgroup) return;\n    const firstChunkParts = firstChunk.split(\";\");\n    if (firstChunkParts.length !== 2) return;\n    const code = firstChunkParts[0].trim();\n    if (!code || !code.match(/^[A-F0-9]+[A-F0-9\\s]*[A-F0-9]+$/)) return;\n    const status = firstChunkParts[1].trim();\n    if (!allowedStatus.has(status)) throw new Error(\"Bad emoji type: \".concat(status));\n    const secondChunkParts = secondChunk.split(/\\s+/);\n    if (secondChunkParts.length < 3) throw new Error(\"Bad emoji comment for: \".concat(code));\n    const emoji = secondChunkParts.shift();\n    const version = secondChunkParts.shift();\n    if (version.slice(0, 1) !== \"E\") throw new Error(\"Bad unicode version \\\"\".concat(version, \"\\\" for: \").concat(code));\n    const name = secondChunkParts.join(\" \");\n    const sequence = getEmojiSequenceFromString(code);\n    const key = getEmojiSequenceKeyword(sequence);\n    if (results[key]) throw new Error(\"Duplicate entry for \\\"\".concat(code, \"\\\"\"));\n    results[key] = {\n      group,\n      subgroup,\n      sequence,\n      emoji,\n      status,\n      version,\n      name\n    };\n  });\n  return getQualifiedTestData(results);\n}\nexport { componentStatus, parseEmojiTestFile };","map":{"version":3,"names":["getEmojiSequenceFromString","getUnqualifiedEmojiSequence","getEmojiSequenceKeyword","componentStatus","allowedStatus","Set","getQualifiedTestData","data","results","Object","create","key","item","sequence","shortKey","length","parseEmojiTestFile","group","subgroup","split","forEach","line","trim","parts","firstChunk","shift","secondChunk","join","commentParts","key$1","value","firstChunkParts","code","match","status","has","Error","concat","secondChunkParts","emoji","version","slice","name"],"sources":["/home/saiadmin/k3s-cluster/dashboard/frontend/node_modules/@iconify/utils/lib/emoji/test/parse.js"],"sourcesContent":["import { getEmojiSequenceFromString, getUnqualifiedEmojiSequence } from \"../cleanup.js\";\nimport { getEmojiSequenceKeyword } from \"../format.js\";\n\nconst componentStatus = \"component\";\nconst allowedStatus = new Set([\n\tcomponentStatus,\n\t\"fully-qualified\",\n\t\"minimally-qualified\",\n\t\"unqualified\"\n]);\n/**\n* Get qualified variations from parsed test file\n*\n* Key is unqualified emoji, value is longest fully qualified emoji\n*/\nfunction getQualifiedTestData(data) {\n\tconst results = Object.create(null);\n\tfor (const key in data) {\n\t\tconst item = data[key];\n\t\tconst sequence = getUnqualifiedEmojiSequence(item.sequence);\n\t\tconst shortKey = getEmojiSequenceKeyword(sequence);\n\t\tif (!results[shortKey] || results[shortKey].sequence.length < sequence.length) results[shortKey] = item;\n\t}\n\treturn results;\n}\n/**\n* Get all emoji sequences from test file\n*\n* Returns all emojis as UTF-32 sequences, where:\n* \tkey = unqualified sequence (without \\uFE0F)\n* \tvalue = qualified sequence (with \\uFE0F)\n*\n* Duplicate items that have different versions with and without \\uFE0F are\n* listed only once, with unqualified sequence as key and longest possible\n* qualified sequence as value\n*\n* Example of 3 identical entries:\n*  '1F441 FE0F 200D 1F5E8 FE0F'\n*  '1F441 200D 1F5E8 FE0F'\n*  '1F441 FE0F 200D 1F5E8'\n* \t'1F441 200D 1F5E8'\n*\n* Out of these entries, only one item will be returned with:\n* \tkey = '1f441-200d-1f5e8' (converted to lower case, separated with dash)\n* \tvalue.sequence = [0x1F441, 0xFE0F, 0x200D, 0x1F5E8, 0xFE0F]\n* \tvalue.status = 'fully-qualified'\n* \tother properties in value are identical for all versions\n*/\nfunction parseEmojiTestFile(data) {\n\tconst results = Object.create(null);\n\tlet group;\n\tlet subgroup;\n\tdata.split(\"\\n\").forEach((line) => {\n\t\tline = line.trim();\n\t\tconst parts = line.split(\"#\");\n\t\tif (parts.length < 2) return;\n\t\tconst firstChunk = parts.shift().trim();\n\t\tconst secondChunk = parts.join(\"#\").trim();\n\t\tif (!firstChunk) {\n\t\t\tconst commentParts = secondChunk.split(\":\");\n\t\t\tif (commentParts.length === 2) {\n\t\t\t\tconst key$1 = commentParts[0].trim();\n\t\t\t\tconst value = commentParts[1].trim();\n\t\t\t\tswitch (key$1) {\n\t\t\t\t\tcase \"group\":\n\t\t\t\t\t\tgroup = value;\n\t\t\t\t\t\tsubgroup = void 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"subgroup\":\n\t\t\t\t\t\tsubgroup = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (!group || !subgroup) return;\n\t\tconst firstChunkParts = firstChunk.split(\";\");\n\t\tif (firstChunkParts.length !== 2) return;\n\t\tconst code = firstChunkParts[0].trim();\n\t\tif (!code || !code.match(/^[A-F0-9]+[A-F0-9\\s]*[A-F0-9]+$/)) return;\n\t\tconst status = firstChunkParts[1].trim();\n\t\tif (!allowedStatus.has(status)) throw new Error(`Bad emoji type: ${status}`);\n\t\tconst secondChunkParts = secondChunk.split(/\\s+/);\n\t\tif (secondChunkParts.length < 3) throw new Error(`Bad emoji comment for: ${code}`);\n\t\tconst emoji = secondChunkParts.shift();\n\t\tconst version = secondChunkParts.shift();\n\t\tif (version.slice(0, 1) !== \"E\") throw new Error(`Bad unicode version \"${version}\" for: ${code}`);\n\t\tconst name = secondChunkParts.join(\" \");\n\t\tconst sequence = getEmojiSequenceFromString(code);\n\t\tconst key = getEmojiSequenceKeyword(sequence);\n\t\tif (results[key]) throw new Error(`Duplicate entry for \"${code}\"`);\n\t\tresults[key] = {\n\t\t\tgroup,\n\t\t\tsubgroup,\n\t\t\tsequence,\n\t\t\temoji,\n\t\t\tstatus,\n\t\t\tversion,\n\t\t\tname\n\t\t};\n\t});\n\treturn getQualifiedTestData(results);\n}\n\nexport { componentStatus, parseEmojiTestFile };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}