{"ast":null,"code":"import { hasTokenLabel, tokenLabel } from \"../scan/tokens_public.js\";\nimport { first, map, reduce } from \"lodash-es\";\nimport { getProductionDslName, NonTerminal, Rule, Terminal } from \"@chevrotain/gast\";\nexport const defaultParserErrorProvider = {\n  buildMismatchTokenMessage(_ref) {\n    let {\n      expected,\n      actual,\n      previous,\n      ruleName\n    } = _ref;\n    const hasLabel = hasTokenLabel(expected);\n    const expectedMsg = hasLabel ? \"--> \".concat(tokenLabel(expected), \" <--\") : \"token of type --> \".concat(expected.name, \" <--\");\n    const msg = \"Expecting \".concat(expectedMsg, \" but found --> '\").concat(actual.image, \"' <--\");\n    return msg;\n  },\n  buildNotAllInputParsedMessage(_ref2) {\n    let {\n      firstRedundant,\n      ruleName\n    } = _ref2;\n    return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\n  },\n  buildNoViableAltMessage(_ref3) {\n    let {\n      expectedPathsPerAlt,\n      actual,\n      previous,\n      customUserDescription,\n      ruleName\n    } = _ref3;\n    const errPrefix = \"Expecting: \";\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n    const actualText = first(actual).image;\n    const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      const allLookAheadPaths = reduce(expectedPathsPerAlt, (result, currAltPaths) => result.concat(currAltPaths), []);\n      const nextValidTokenSequences = map(allLookAheadPaths, currPath => \"[\".concat(map(currPath, currTokenType => tokenLabel(currTokenType)).join(\", \"), \"]\"));\n      const nextValidSequenceItems = map(nextValidTokenSequences, (itemMsg, idx) => \"  \".concat(idx + 1, \". \").concat(itemMsg));\n      const calculatedDescription = \"one of these possible Token sequences:\\n\".concat(nextValidSequenceItems.join(\"\\n\"));\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  },\n  buildEarlyExitMessage(_ref4) {\n    let {\n      expectedIterationPaths,\n      actual,\n      customUserDescription,\n      ruleName\n    } = _ref4;\n    const errPrefix = \"Expecting: \";\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n    const actualText = first(actual).image;\n    const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      const nextValidTokenSequences = map(expectedIterationPaths, currPath => \"[\".concat(map(currPath, currTokenType => tokenLabel(currTokenType)).join(\",\"), \"]\"));\n      const calculatedDescription = \"expecting at least one iteration which starts with one of these possible Token sequences::\\n  \" + \"<\".concat(nextValidTokenSequences.join(\" ,\"), \">\");\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  }\n};\nObject.freeze(defaultParserErrorProvider);\nexport const defaultGrammarResolverErrorProvider = {\n  buildRuleNotFoundError(topLevelRule, undefinedRule) {\n    const msg = \"Invalid grammar, reference to a rule which is not defined: ->\" + undefinedRule.nonTerminalName + \"<-\\n\" + \"inside top level rule: ->\" + topLevelRule.name + \"<-\";\n    return msg;\n  }\n};\nexport const defaultGrammarValidatorErrorProvider = {\n  buildDuplicateFoundError(topLevelRule, duplicateProds) {\n    function getExtraProductionArgument(prod) {\n      if (prod instanceof Terminal) {\n        return prod.terminalType.name;\n      } else if (prod instanceof NonTerminal) {\n        return prod.nonTerminalName;\n      } else {\n        return \"\";\n      }\n    }\n    const topLevelName = topLevelRule.name;\n    const duplicateProd = first(duplicateProds);\n    const index = duplicateProd.idx;\n    const dslName = getProductionDslName(duplicateProd);\n    const extraArgument = getExtraProductionArgument(duplicateProd);\n    const hasExplicitIndex = index > 0;\n    let msg = \"->\".concat(dslName).concat(hasExplicitIndex ? index : \"\", \"<- \").concat(extraArgument ? \"with argument: ->\".concat(extraArgument, \"<-\") : \"\", \"\\n                  appears more than once (\").concat(duplicateProds.length, \" times) in the top level rule: ->\").concat(topLevelName, \"<-.                  \\n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \\n                  \");\n    // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n    msg = msg.replace(/[ \\t]+/g, \" \");\n    msg = msg.replace(/\\s\\s+/g, \"\\n\");\n    return msg;\n  },\n  buildNamespaceConflictError(rule) {\n    const errMsg = \"Namespace conflict found in grammar.\\n\" + \"The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <\".concat(rule.name, \">.\\n\") + \"To resolve this make sure each Terminal and Non-Terminal names are unique\\n\" + \"This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n\" + \"and Non-Terminal names start with a lower case letter.\";\n    return errMsg;\n  },\n  buildAlternationPrefixAmbiguityError(options) {\n    const pathMsg = map(options.prefixPath, currTok => tokenLabel(currTok)).join(\", \");\n    const occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n    const errMsg = \"Ambiguous alternatives: <\".concat(options.ambiguityIndices.join(\" ,\"), \"> due to common lookahead prefix\\n\") + \"in <OR\".concat(occurrence, \"> inside <\").concat(options.topLevelRule.name, \"> Rule,\\n\") + \"<\".concat(pathMsg, \"> may appears as a prefix path in all these alternatives.\\n\") + \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n\" + \"For Further details.\";\n    return errMsg;\n  },\n  buildAlternationAmbiguityError(options) {\n    const pathMsg = map(options.prefixPath, currtok => tokenLabel(currtok)).join(\", \");\n    const occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n    let currMessage = \"Ambiguous Alternatives Detected: <\".concat(options.ambiguityIndices.join(\" ,\"), \"> in <OR\").concat(occurrence, \">\") + \" inside <\".concat(options.topLevelRule.name, \"> Rule,\\n\") + \"<\".concat(pathMsg, \"> may appears as a prefix path in all these alternatives.\\n\");\n    currMessage = currMessage + \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n\" + \"For Further details.\";\n    return currMessage;\n  },\n  buildEmptyRepetitionError(options) {\n    let dslName = getProductionDslName(options.repetition);\n    if (options.repetition.idx !== 0) {\n      dslName += options.repetition.idx;\n    }\n    const errMsg = \"The repetition <\".concat(dslName, \"> within Rule <\").concat(options.topLevelRule.name, \"> can never consume any tokens.\\n\") + \"This could lead to an infinite loop.\";\n    return errMsg;\n  },\n  // TODO: remove - `errors_public` from nyc.config.js exclude\n  //       once this method is fully removed from this file\n  buildTokenNameError(options) {\n    /* istanbul ignore next */\n    return \"deprecated\";\n  },\n  buildEmptyAlternationError(options) {\n    const errMsg = \"Ambiguous empty alternative: <\".concat(options.emptyChoiceIdx + 1, \">\") + \" in <OR\".concat(options.alternation.idx, \"> inside <\").concat(options.topLevelRule.name, \"> Rule.\\n\") + \"Only the last alternative may be an empty alternative.\";\n    return errMsg;\n  },\n  buildTooManyAlternativesError(options) {\n    const errMsg = \"An Alternation cannot have more than 256 alternatives:\\n\" + \"<OR\".concat(options.alternation.idx, \"> inside <\").concat(options.topLevelRule.name, \"> Rule.\\n has \").concat(options.alternation.definition.length + 1, \" alternatives.\");\n    return errMsg;\n  },\n  buildLeftRecursionError(options) {\n    const ruleName = options.topLevelRule.name;\n    const pathNames = map(options.leftRecursionPath, currRule => currRule.name);\n    const leftRecursivePath = \"\".concat(ruleName, \" --> \").concat(pathNames.concat([ruleName]).join(\" --> \"));\n    const errMsg = \"Left Recursion found in grammar.\\n\" + \"rule: <\".concat(ruleName, \"> can be invoked from itself (directly or indirectly)\\n\") + \"without consuming any Tokens. The grammar path that causes this is: \\n \".concat(leftRecursivePath, \"\\n\") + \" To fix this refactor your grammar to remove the left recursion.\\n\" + \"see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.\";\n    return errMsg;\n  },\n  // TODO: remove - `errors_public` from nyc.config.js exclude\n  //       once this method is fully removed from this file\n  buildInvalidRuleNameError(options) {\n    /* istanbul ignore next */\n    return \"deprecated\";\n  },\n  buildDuplicateRuleNameError(options) {\n    let ruleName;\n    if (options.topLevelRule instanceof Rule) {\n      ruleName = options.topLevelRule.name;\n    } else {\n      ruleName = options.topLevelRule;\n    }\n    const errMsg = \"Duplicate definition, rule: ->\".concat(ruleName, \"<- is already defined in the grammar: ->\").concat(options.grammarName, \"<-\");\n    return errMsg;\n  }\n};","map":{"version":3,"names":["hasTokenLabel","tokenLabel","first","map","reduce","getProductionDslName","NonTerminal","Rule","Terminal","defaultParserErrorProvider","buildMismatchTokenMessage","_ref","expected","actual","previous","ruleName","hasLabel","expectedMsg","concat","name","msg","image","buildNotAllInputParsedMessage","_ref2","firstRedundant","buildNoViableAltMessage","_ref3","expectedPathsPerAlt","customUserDescription","errPrefix","actualText","errSuffix","allLookAheadPaths","result","currAltPaths","nextValidTokenSequences","currPath","currTokenType","join","nextValidSequenceItems","itemMsg","idx","calculatedDescription","buildEarlyExitMessage","_ref4","expectedIterationPaths","Object","freeze","defaultGrammarResolverErrorProvider","buildRuleNotFoundError","topLevelRule","undefinedRule","nonTerminalName","defaultGrammarValidatorErrorProvider","buildDuplicateFoundError","duplicateProds","getExtraProductionArgument","prod","terminalType","topLevelName","duplicateProd","index","dslName","extraArgument","hasExplicitIndex","length","replace","buildNamespaceConflictError","rule","errMsg","buildAlternationPrefixAmbiguityError","options","pathMsg","prefixPath","currTok","occurrence","alternation","ambiguityIndices","buildAlternationAmbiguityError","currtok","currMessage","buildEmptyRepetitionError","repetition","buildTokenNameError","buildEmptyAlternationError","emptyChoiceIdx","buildTooManyAlternativesError","definition","buildLeftRecursionError","pathNames","leftRecursionPath","currRule","leftRecursivePath","buildInvalidRuleNameError","buildDuplicateRuleNameError","grammarName"],"sources":["/home/saiadmin/k3s-cluster/dashboard/frontend/node_modules/chevrotain/src/parse/errors_public.ts"],"sourcesContent":["import { hasTokenLabel, tokenLabel } from \"../scan/tokens_public.js\";\nimport { first, map, reduce } from \"lodash-es\";\nimport {\n  Alternation,\n  getProductionDslName,\n  NonTerminal,\n  Rule,\n  Terminal,\n} from \"@chevrotain/gast\";\nimport {\n  IParserErrorMessageProvider,\n  IProductionWithOccurrence,\n  TokenType,\n} from \"@chevrotain/types\";\nimport {\n  IGrammarResolverErrorMessageProvider,\n  IGrammarValidatorErrorMessageProvider,\n} from \"./grammar/types.js\";\n\nexport const defaultParserErrorProvider: IParserErrorMessageProvider = {\n  buildMismatchTokenMessage({ expected, actual, previous, ruleName }): string {\n    const hasLabel = hasTokenLabel(expected);\n    const expectedMsg = hasLabel\n      ? `--> ${tokenLabel(expected)} <--`\n      : `token of type --> ${expected.name} <--`;\n\n    const msg = `Expecting ${expectedMsg} but found --> '${actual.image}' <--`;\n\n    return msg;\n  },\n\n  buildNotAllInputParsedMessage({ firstRedundant, ruleName }): string {\n    return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\n  },\n\n  buildNoViableAltMessage({\n    expectedPathsPerAlt,\n    actual,\n    previous,\n    customUserDescription,\n    ruleName,\n  }): string {\n    const errPrefix = \"Expecting: \";\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n    const actualText = first(actual)!.image;\n    const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      const allLookAheadPaths = reduce(\n        expectedPathsPerAlt,\n        (result, currAltPaths) => result.concat(currAltPaths),\n        [] as TokenType[][],\n      );\n      const nextValidTokenSequences = map(\n        allLookAheadPaths,\n        (currPath) =>\n          `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\n            \", \",\n          )}]`,\n      );\n      const nextValidSequenceItems = map(\n        nextValidTokenSequences,\n        (itemMsg, idx) => `  ${idx + 1}. ${itemMsg}`,\n      );\n      const calculatedDescription = `one of these possible Token sequences:\\n${nextValidSequenceItems.join(\n        \"\\n\",\n      )}`;\n\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  },\n\n  buildEarlyExitMessage({\n    expectedIterationPaths,\n    actual,\n    customUserDescription,\n    ruleName,\n  }): string {\n    const errPrefix = \"Expecting: \";\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n    const actualText = first(actual)!.image;\n    const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      const nextValidTokenSequences = map(\n        expectedIterationPaths,\n        (currPath) =>\n          `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\n            \",\",\n          )}]`,\n      );\n      const calculatedDescription =\n        `expecting at least one iteration which starts with one of these possible Token sequences::\\n  ` +\n        `<${nextValidTokenSequences.join(\" ,\")}>`;\n\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  },\n};\n\nObject.freeze(defaultParserErrorProvider);\n\nexport const defaultGrammarResolverErrorProvider: IGrammarResolverErrorMessageProvider =\n  {\n    buildRuleNotFoundError(\n      topLevelRule: Rule,\n      undefinedRule: NonTerminal,\n    ): string {\n      const msg =\n        \"Invalid grammar, reference to a rule which is not defined: ->\" +\n        undefinedRule.nonTerminalName +\n        \"<-\\n\" +\n        \"inside top level rule: ->\" +\n        topLevelRule.name +\n        \"<-\";\n      return msg;\n    },\n  };\n\nexport const defaultGrammarValidatorErrorProvider: IGrammarValidatorErrorMessageProvider =\n  {\n    buildDuplicateFoundError(\n      topLevelRule: Rule,\n      duplicateProds: IProductionWithOccurrence[],\n    ): string {\n      function getExtraProductionArgument(\n        prod: IProductionWithOccurrence,\n      ): string {\n        if (prod instanceof Terminal) {\n          return prod.terminalType.name;\n        } else if (prod instanceof NonTerminal) {\n          return prod.nonTerminalName;\n        } else {\n          return \"\";\n        }\n      }\n\n      const topLevelName = topLevelRule.name;\n      const duplicateProd = first(duplicateProds)!;\n      const index = duplicateProd.idx;\n      const dslName = getProductionDslName(duplicateProd);\n      const extraArgument = getExtraProductionArgument(duplicateProd);\n\n      const hasExplicitIndex = index > 0;\n      let msg = `->${dslName}${hasExplicitIndex ? index : \"\"}<- ${\n        extraArgument ? `with argument: ->${extraArgument}<-` : \"\"\n      }\n                  appears more than once (${\n                    duplicateProds.length\n                  } times) in the top level rule: ->${topLevelName}<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  `;\n\n      // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n      msg = msg.replace(/[ \\t]+/g, \" \");\n      msg = msg.replace(/\\s\\s+/g, \"\\n\");\n\n      return msg;\n    },\n\n    buildNamespaceConflictError(rule: Rule): string {\n      const errMsg =\n        `Namespace conflict found in grammar.\\n` +\n        `The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${rule.name}>.\\n` +\n        `To resolve this make sure each Terminal and Non-Terminal names are unique\\n` +\n        `This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n` +\n        `and Non-Terminal names start with a lower case letter.`;\n\n      return errMsg;\n    },\n\n    buildAlternationPrefixAmbiguityError(options: {\n      topLevelRule: Rule;\n      prefixPath: TokenType[];\n      ambiguityIndices: number[];\n      alternation: Alternation;\n    }): string {\n      const pathMsg = map(options.prefixPath, (currTok) =>\n        tokenLabel(currTok),\n      ).join(\", \");\n      const occurrence =\n        options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n      const errMsg =\n        `Ambiguous alternatives: <${options.ambiguityIndices.join(\n          \" ,\",\n        )}> due to common lookahead prefix\\n` +\n        `in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\\n` +\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n` +\n        `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n` +\n        `For Further details.`;\n\n      return errMsg;\n    },\n\n    buildAlternationAmbiguityError(options: {\n      topLevelRule: Rule;\n      prefixPath: TokenType[];\n      ambiguityIndices: number[];\n      alternation: Alternation;\n    }): string {\n      const pathMsg = map(options.prefixPath, (currtok) =>\n        tokenLabel(currtok),\n      ).join(\", \");\n      const occurrence =\n        options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n      let currMessage =\n        `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(\n          \" ,\",\n        )}> in <OR${occurrence}>` +\n        ` inside <${options.topLevelRule.name}> Rule,\\n` +\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n`;\n\n      currMessage =\n        currMessage +\n        `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n` +\n        `For Further details.`;\n      return currMessage;\n    },\n\n    buildEmptyRepetitionError(options: {\n      topLevelRule: Rule;\n      repetition: IProductionWithOccurrence;\n    }): string {\n      let dslName = getProductionDslName(options.repetition);\n      if (options.repetition.idx !== 0) {\n        dslName += options.repetition.idx;\n      }\n\n      const errMsg =\n        `The repetition <${dslName}> within Rule <${options.topLevelRule.name}> can never consume any tokens.\\n` +\n        `This could lead to an infinite loop.`;\n\n      return errMsg;\n    },\n\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildTokenNameError(options: {\n      tokenType: TokenType;\n      expectedPattern: RegExp;\n    }): string {\n      /* istanbul ignore next */\n      return \"deprecated\";\n    },\n\n    buildEmptyAlternationError(options: {\n      topLevelRule: Rule;\n      alternation: Alternation;\n      emptyChoiceIdx: number;\n    }): string {\n      const errMsg =\n        `Ambiguous empty alternative: <${options.emptyChoiceIdx + 1}>` +\n        ` in <OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n` +\n        `Only the last alternative may be an empty alternative.`;\n\n      return errMsg;\n    },\n\n    buildTooManyAlternativesError(options: {\n      topLevelRule: Rule;\n      alternation: Alternation;\n    }): string {\n      const errMsg =\n        `An Alternation cannot have more than 256 alternatives:\\n` +\n        `<OR${options.alternation.idx}> inside <${\n          options.topLevelRule.name\n        }> Rule.\\n has ${\n          options.alternation.definition.length + 1\n        } alternatives.`;\n\n      return errMsg;\n    },\n\n    buildLeftRecursionError(options: {\n      topLevelRule: Rule;\n      leftRecursionPath: Rule[];\n    }): string {\n      const ruleName = options.topLevelRule.name;\n      const pathNames = map(\n        options.leftRecursionPath,\n        (currRule) => currRule.name,\n      );\n      const leftRecursivePath = `${ruleName} --> ${pathNames\n        .concat([ruleName])\n        .join(\" --> \")}`;\n      const errMsg =\n        `Left Recursion found in grammar.\\n` +\n        `rule: <${ruleName}> can be invoked from itself (directly or indirectly)\\n` +\n        `without consuming any Tokens. The grammar path that causes this is: \\n ${leftRecursivePath}\\n` +\n        ` To fix this refactor your grammar to remove the left recursion.\\n` +\n        `see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`;\n\n      return errMsg;\n    },\n\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildInvalidRuleNameError(options: {\n      topLevelRule: Rule;\n      expectedPattern: RegExp;\n    }): string {\n      /* istanbul ignore next */\n      return \"deprecated\";\n    },\n\n    buildDuplicateRuleNameError(options: {\n      topLevelRule: Rule | string;\n      grammarName: string;\n    }): string {\n      let ruleName;\n      if (options.topLevelRule instanceof Rule) {\n        ruleName = options.topLevelRule.name;\n      } else {\n        ruleName = options.topLevelRule;\n      }\n\n      const errMsg = `Duplicate definition, rule: ->${ruleName}<- is already defined in the grammar: ->${options.grammarName}<-`;\n\n      return errMsg;\n    },\n  };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}