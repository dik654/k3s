{"ast":null,"code":"import _objectSpread from \"/home/saiadmin/k3s-cluster/dashboard/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { emojiComponents, keycapEmoji, vs16Emoji } from \"../data.js\";\nimport { convertEmojiSequenceToUTF32 } from \"../convert.js\";\nimport { getUnqualifiedEmojiSequence, joinEmojiSequences, splitEmojiSequences } from \"../cleanup.js\";\nimport { getEmojiSequenceKeyword } from \"../format.js\";\n\n/**\n* Get qualified sequence, adding optional `FE0F` wherever it might exist\n*\n* This might result in sequence that is not actually valid, but considering\n* that `FE0F` is always treated as optional, full sequence used in regex will\n* catch both qualified and unqualified emojis, so proper sequence will get\n* caught anyway. This function just makes sure that in case if sequence does\n* have `FE0F`, it will be caught by regex too.\n*/\nfunction guessQualifiedEmojiSequence(sequence) {\n  return joinEmojiSequences(splitEmojiSequences(sequence).map(part => {\n    if (part.indexOf(vs16Emoji) !== -1) return part;\n    if (part.length === 2) {\n      const lastNum = part[1];\n      if (lastNum === keycapEmoji) return [part[0], vs16Emoji, lastNum];\n      for (const key in emojiComponents) {\n        const range = emojiComponents[key];\n        if (lastNum >= range[0] && lastNum < range[1]) return [part[0], vs16Emoji, lastNum];\n      }\n    }\n    return part.length === 1 ? [part[0], vs16Emoji] : part;\n  }));\n}\n/**\n* Get qualified variations for emojis\n*\n* Also converts list to UTF-32 as needed and removes duplicate items\n*/\nfunction getQualifiedEmojiVariation(item) {\n  const unqualifiedSequence = getUnqualifiedEmojiSequence(convertEmojiSequenceToUTF32(item.sequence));\n  const result = _objectSpread(_objectSpread({}, item), {}, {\n    sequence: guessQualifiedEmojiSequence(unqualifiedSequence)\n  });\n  if (result.sequenceKey) result.sequenceKey = getEmojiSequenceKeyword(unqualifiedSequence);\n  return result;\n}\n/**\n* Get qualified emoji variations for set of emojis, ignoring duplicate entries\n*/\nfunction getQualifiedEmojiVariations(items) {\n  const results = Object.create(null);\n  for (let i = 0; i < items.length; i++) {\n    const result = getQualifiedEmojiVariation(items[i]);\n    const key = getEmojiSequenceKeyword(getUnqualifiedEmojiSequence(result.sequence));\n    if (!results[key] || results[key].sequence.length < result.sequence.length) results[key] = result;\n  }\n  return Object.values(results);\n}\nexport { getQualifiedEmojiVariation, getQualifiedEmojiVariations, guessQualifiedEmojiSequence };","map":{"version":3,"names":["emojiComponents","keycapEmoji","vs16Emoji","convertEmojiSequenceToUTF32","getUnqualifiedEmojiSequence","joinEmojiSequences","splitEmojiSequences","getEmojiSequenceKeyword","guessQualifiedEmojiSequence","sequence","map","part","indexOf","length","lastNum","key","range","getQualifiedEmojiVariation","item","unqualifiedSequence","result","_objectSpread","sequenceKey","getQualifiedEmojiVariations","items","results","Object","create","i","values"],"sources":["/home/saiadmin/k3s-cluster/dashboard/frontend/node_modules/@iconify/utils/lib/emoji/test/variations.js"],"sourcesContent":["import { emojiComponents, keycapEmoji, vs16Emoji } from \"../data.js\";\nimport { convertEmojiSequenceToUTF32 } from \"../convert.js\";\nimport { getUnqualifiedEmojiSequence, joinEmojiSequences, splitEmojiSequences } from \"../cleanup.js\";\nimport { getEmojiSequenceKeyword } from \"../format.js\";\n\n/**\n* Get qualified sequence, adding optional `FE0F` wherever it might exist\n*\n* This might result in sequence that is not actually valid, but considering\n* that `FE0F` is always treated as optional, full sequence used in regex will\n* catch both qualified and unqualified emojis, so proper sequence will get\n* caught anyway. This function just makes sure that in case if sequence does\n* have `FE0F`, it will be caught by regex too.\n*/\nfunction guessQualifiedEmojiSequence(sequence) {\n\treturn joinEmojiSequences(splitEmojiSequences(sequence).map((part) => {\n\t\tif (part.indexOf(vs16Emoji) !== -1) return part;\n\t\tif (part.length === 2) {\n\t\t\tconst lastNum = part[1];\n\t\t\tif (lastNum === keycapEmoji) return [\n\t\t\t\tpart[0],\n\t\t\t\tvs16Emoji,\n\t\t\t\tlastNum\n\t\t\t];\n\t\t\tfor (const key in emojiComponents) {\n\t\t\t\tconst range = emojiComponents[key];\n\t\t\t\tif (lastNum >= range[0] && lastNum < range[1]) return [\n\t\t\t\t\tpart[0],\n\t\t\t\t\tvs16Emoji,\n\t\t\t\t\tlastNum\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\t\treturn part.length === 1 ? [part[0], vs16Emoji] : part;\n\t}));\n}\n/**\n* Get qualified variations for emojis\n*\n* Also converts list to UTF-32 as needed and removes duplicate items\n*/\nfunction getQualifiedEmojiVariation(item) {\n\tconst unqualifiedSequence = getUnqualifiedEmojiSequence(convertEmojiSequenceToUTF32(item.sequence));\n\tconst result = {\n\t\t...item,\n\t\tsequence: guessQualifiedEmojiSequence(unqualifiedSequence)\n\t};\n\tif (result.sequenceKey) result.sequenceKey = getEmojiSequenceKeyword(unqualifiedSequence);\n\treturn result;\n}\n/**\n* Get qualified emoji variations for set of emojis, ignoring duplicate entries\n*/\nfunction getQualifiedEmojiVariations(items) {\n\tconst results = Object.create(null);\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst result = getQualifiedEmojiVariation(items[i]);\n\t\tconst key = getEmojiSequenceKeyword(getUnqualifiedEmojiSequence(result.sequence));\n\t\tif (!results[key] || results[key].sequence.length < result.sequence.length) results[key] = result;\n\t}\n\treturn Object.values(results);\n}\n\nexport { getQualifiedEmojiVariation, getQualifiedEmojiVariations, guessQualifiedEmojiSequence };"],"mappings":";AAAA,SAASA,eAAe,EAAEC,WAAW,EAAEC,SAAS,QAAQ,YAAY;AACpE,SAASC,2BAA2B,QAAQ,eAAe;AAC3D,SAASC,2BAA2B,EAAEC,kBAAkB,EAAEC,mBAAmB,QAAQ,eAAe;AACpG,SAASC,uBAAuB,QAAQ,cAAc;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,2BAA2BA,CAACC,QAAQ,EAAE;EAC9C,OAAOJ,kBAAkB,CAACC,mBAAmB,CAACG,QAAQ,CAAC,CAACC,GAAG,CAAEC,IAAI,IAAK;IACrE,IAAIA,IAAI,CAACC,OAAO,CAACV,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE,OAAOS,IAAI;IAC/C,IAAIA,IAAI,CAACE,MAAM,KAAK,CAAC,EAAE;MACtB,MAAMC,OAAO,GAAGH,IAAI,CAAC,CAAC,CAAC;MACvB,IAAIG,OAAO,KAAKb,WAAW,EAAE,OAAO,CACnCU,IAAI,CAAC,CAAC,CAAC,EACPT,SAAS,EACTY,OAAO,CACP;MACD,KAAK,MAAMC,GAAG,IAAIf,eAAe,EAAE;QAClC,MAAMgB,KAAK,GAAGhB,eAAe,CAACe,GAAG,CAAC;QAClC,IAAID,OAAO,IAAIE,KAAK,CAAC,CAAC,CAAC,IAAIF,OAAO,GAAGE,KAAK,CAAC,CAAC,CAAC,EAAE,OAAO,CACrDL,IAAI,CAAC,CAAC,CAAC,EACPT,SAAS,EACTY,OAAO,CACP;MACF;IACD;IACA,OAAOH,IAAI,CAACE,MAAM,KAAK,CAAC,GAAG,CAACF,IAAI,CAAC,CAAC,CAAC,EAAET,SAAS,CAAC,GAAGS,IAAI;EACvD,CAAC,CAAC,CAAC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,SAASM,0BAA0BA,CAACC,IAAI,EAAE;EACzC,MAAMC,mBAAmB,GAAGf,2BAA2B,CAACD,2BAA2B,CAACe,IAAI,CAACT,QAAQ,CAAC,CAAC;EACnG,MAAMW,MAAM,GAAAC,aAAA,CAAAA,aAAA,KACRH,IAAI;IACPT,QAAQ,EAAED,2BAA2B,CAACW,mBAAmB;EAAC,EAC1D;EACD,IAAIC,MAAM,CAACE,WAAW,EAAEF,MAAM,CAACE,WAAW,GAAGf,uBAAuB,CAACY,mBAAmB,CAAC;EACzF,OAAOC,MAAM;AACd;AACA;AACA;AACA;AACA,SAASG,2BAA2BA,CAACC,KAAK,EAAE;EAC3C,MAAMC,OAAO,GAAGC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;EACnC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,KAAK,CAACX,MAAM,EAAEe,CAAC,EAAE,EAAE;IACtC,MAAMR,MAAM,GAAGH,0BAA0B,CAACO,KAAK,CAACI,CAAC,CAAC,CAAC;IACnD,MAAMb,GAAG,GAAGR,uBAAuB,CAACH,2BAA2B,CAACgB,MAAM,CAACX,QAAQ,CAAC,CAAC;IACjF,IAAI,CAACgB,OAAO,CAACV,GAAG,CAAC,IAAIU,OAAO,CAACV,GAAG,CAAC,CAACN,QAAQ,CAACI,MAAM,GAAGO,MAAM,CAACX,QAAQ,CAACI,MAAM,EAAEY,OAAO,CAACV,GAAG,CAAC,GAAGK,MAAM;EAClG;EACA,OAAOM,MAAM,CAACG,MAAM,CAACJ,OAAO,CAAC;AAC9B;AAEA,SAASR,0BAA0B,EAAEM,2BAA2B,EAAEf,2BAA2B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}