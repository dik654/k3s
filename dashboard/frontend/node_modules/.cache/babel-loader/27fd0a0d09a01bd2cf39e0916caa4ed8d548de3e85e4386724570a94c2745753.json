{"ast":null,"code":"import _objectSpread from \"/home/saiadmin/k3s-cluster/dashboard/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { vs16Emoji } from \"../data.js\";\nimport { convertEmojiSequenceToUTF32 } from \"../convert.js\";\nimport { getEmojiSequenceKeyword } from \"../format.js\";\n\n/**\n* Create regular expression instance\n*/\nfunction createEmojiRegExp(regexp) {\n  return new RegExp(regexp, \"g\");\n}\n/**\n* Find emojis in text\n*\n* Returns only one entry per match\n*/\nfunction getEmojiMatchesInText(regexp, content) {\n  const results = [];\n  const found = /* @__PURE__ */new Set();\n  (regexp instanceof Array ? regexp : [regexp]).forEach((regexp$1, index) => {\n    const matches = content.match(typeof regexp$1 === \"string\" ? createEmojiRegExp(regexp$1) : regexp$1);\n    if (matches) for (let i = 0; i < matches.length; i++) {\n      const match = matches[i];\n      if (found.has(match)) continue;\n      found.add(match);\n      const sequence = [];\n      for (const codePoint of match) {\n        const num = codePoint.codePointAt(0);\n        if (num !== vs16Emoji) sequence.push(num);\n      }\n      results.push({\n        match,\n        sequence,\n        keyword: getEmojiSequenceKeyword(convertEmojiSequenceToUTF32(sequence)),\n        regexp: index\n      });\n    }\n  });\n  results.sort((a, b) => {\n    const match1 = a.match;\n    const match2 = b.match;\n    if (match2.length === match1.length) return match1.localeCompare(match2);\n    return match2.length - match1.length;\n  });\n  return results;\n}\n/**\n* Sort emojis, get prev and next text\n*/\nfunction sortEmojiMatchesInText(content, matches) {\n  const ranges = [];\n  const check = (start, end) => {\n    for (let i = 0; i < ranges.length; i++) if (start < ranges[i].end && end > ranges[i].start) return false;\n    return true;\n  };\n  for (let i = 0; i < matches.length; i++) {\n    const match = matches[i];\n    const search = match.match;\n    let startFrom = 0;\n    let start;\n    while ((start = content.indexOf(search, startFrom)) !== -1) {\n      const end = start + search.length;\n      startFrom = end;\n      if (check(start, end)) ranges.push({\n        start,\n        end,\n        match\n      });\n    }\n  }\n  ranges.sort((a, b) => a.start - b.start);\n  const list = [];\n  let prevRange;\n  let lastEnd;\n  for (let i = 0; i < ranges.length; i++) {\n    const range = ranges[i];\n    const prev = content.slice(prevRange ? prevRange.end : 0, range.start);\n    list.push({\n      match: range.match,\n      prev\n    });\n    prevRange = range;\n    lastEnd = range.end;\n  }\n  if (!lastEnd) return [];\n  return list.map((item, index) => {\n    const nextItem = list[index + 1];\n    return _objectSpread(_objectSpread({}, item), {}, {\n      next: nextItem ? nextItem.prev : content.slice(lastEnd)\n    });\n  });\n}\nexport { createEmojiRegExp, getEmojiMatchesInText, sortEmojiMatchesInText };","map":{"version":3,"names":["vs16Emoji","convertEmojiSequenceToUTF32","getEmojiSequenceKeyword","createEmojiRegExp","regexp","RegExp","getEmojiMatchesInText","content","results","found","Set","Array","forEach","regexp$1","index","matches","match","i","length","has","add","sequence","codePoint","num","codePointAt","push","keyword","sort","a","b","match1","match2","localeCompare","sortEmojiMatchesInText","ranges","check","start","end","search","startFrom","indexOf","list","prevRange","lastEnd","range","prev","slice","map","item","nextItem","_objectSpread","next"],"sources":["/home/saiadmin/k3s-cluster/dashboard/frontend/node_modules/@iconify/utils/lib/emoji/replace/find.js"],"sourcesContent":["import { vs16Emoji } from \"../data.js\";\nimport { convertEmojiSequenceToUTF32 } from \"../convert.js\";\nimport { getEmojiSequenceKeyword } from \"../format.js\";\n\n/**\n* Create regular expression instance\n*/\nfunction createEmojiRegExp(regexp) {\n\treturn new RegExp(regexp, \"g\");\n}\n/**\n* Find emojis in text\n*\n* Returns only one entry per match\n*/\nfunction getEmojiMatchesInText(regexp, content) {\n\tconst results = [];\n\tconst found = /* @__PURE__ */ new Set();\n\t(regexp instanceof Array ? regexp : [regexp]).forEach((regexp$1, index) => {\n\t\tconst matches = content.match(typeof regexp$1 === \"string\" ? createEmojiRegExp(regexp$1) : regexp$1);\n\t\tif (matches) for (let i = 0; i < matches.length; i++) {\n\t\t\tconst match = matches[i];\n\t\t\tif (found.has(match)) continue;\n\t\t\tfound.add(match);\n\t\t\tconst sequence = [];\n\t\t\tfor (const codePoint of match) {\n\t\t\t\tconst num = codePoint.codePointAt(0);\n\t\t\t\tif (num !== vs16Emoji) sequence.push(num);\n\t\t\t}\n\t\t\tresults.push({\n\t\t\t\tmatch,\n\t\t\t\tsequence,\n\t\t\t\tkeyword: getEmojiSequenceKeyword(convertEmojiSequenceToUTF32(sequence)),\n\t\t\t\tregexp: index\n\t\t\t});\n\t\t}\n\t});\n\tresults.sort((a, b) => {\n\t\tconst match1 = a.match;\n\t\tconst match2 = b.match;\n\t\tif (match2.length === match1.length) return match1.localeCompare(match2);\n\t\treturn match2.length - match1.length;\n\t});\n\treturn results;\n}\n/**\n* Sort emojis, get prev and next text\n*/\nfunction sortEmojiMatchesInText(content, matches) {\n\tconst ranges = [];\n\tconst check = (start, end) => {\n\t\tfor (let i = 0; i < ranges.length; i++) if (start < ranges[i].end && end > ranges[i].start) return false;\n\t\treturn true;\n\t};\n\tfor (let i = 0; i < matches.length; i++) {\n\t\tconst match = matches[i];\n\t\tconst search = match.match;\n\t\tlet startFrom = 0;\n\t\tlet start;\n\t\twhile ((start = content.indexOf(search, startFrom)) !== -1) {\n\t\t\tconst end = start + search.length;\n\t\t\tstartFrom = end;\n\t\t\tif (check(start, end)) ranges.push({\n\t\t\t\tstart,\n\t\t\t\tend,\n\t\t\t\tmatch\n\t\t\t});\n\t\t}\n\t}\n\tranges.sort((a, b) => a.start - b.start);\n\tconst list = [];\n\tlet prevRange;\n\tlet lastEnd;\n\tfor (let i = 0; i < ranges.length; i++) {\n\t\tconst range = ranges[i];\n\t\tconst prev = content.slice(prevRange ? prevRange.end : 0, range.start);\n\t\tlist.push({\n\t\t\tmatch: range.match,\n\t\t\tprev\n\t\t});\n\t\tprevRange = range;\n\t\tlastEnd = range.end;\n\t}\n\tif (!lastEnd) return [];\n\treturn list.map((item, index) => {\n\t\tconst nextItem = list[index + 1];\n\t\treturn {\n\t\t\t...item,\n\t\t\tnext: nextItem ? nextItem.prev : content.slice(lastEnd)\n\t\t};\n\t});\n}\n\nexport { createEmojiRegExp, getEmojiMatchesInText, sortEmojiMatchesInText };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}