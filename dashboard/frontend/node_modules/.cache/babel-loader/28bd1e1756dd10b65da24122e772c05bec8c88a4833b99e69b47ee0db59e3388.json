{"ast":null,"code":"import { clone, drop, dropRight, first as _first, forEach, isEmpty, last } from \"lodash-es\";\nimport { first } from \"./first.js\";\nimport { RestWalker } from \"./rest.js\";\nimport { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal } from \"@chevrotain/gast\";\nexport class AbstractNextPossibleTokensWalker extends RestWalker {\n  constructor(topProd, path) {\n    super();\n    this.topProd = topProd;\n    this.path = path;\n    this.possibleTokTypes = [];\n    this.nextProductionName = \"\";\n    this.nextProductionOccurrence = 0;\n    this.found = false;\n    this.isAtEndOfPath = false;\n  }\n  startWalking() {\n    this.found = false;\n    if (this.path.ruleStack[0] !== this.topProd.name) {\n      throw Error(\"The path does not start with the walker's top Rule!\");\n    }\n    // immutable for the win\n    this.ruleStack = clone(this.path.ruleStack).reverse(); // intelij bug requires assertion\n    this.occurrenceStack = clone(this.path.occurrenceStack).reverse(); // intelij bug requires assertion\n    // already verified that the first production is valid, we now seek the 2nd production\n    this.ruleStack.pop();\n    this.occurrenceStack.pop();\n    this.updateExpectedNext();\n    this.walk(this.topProd);\n    return this.possibleTokTypes;\n  }\n  walk(prod) {\n    let prevRest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    // stop scanning once we found the path\n    if (!this.found) {\n      super.walk(prod, prevRest);\n    }\n  }\n  walkProdRef(refProd, currRest, prevRest) {\n    // found the next production, need to keep walking in it\n    if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {\n      const fullRest = currRest.concat(prevRest);\n      this.updateExpectedNext();\n      this.walk(refProd.referencedRule, fullRest);\n    }\n  }\n  updateExpectedNext() {\n    // need to consume the Terminal\n    if (isEmpty(this.ruleStack)) {\n      // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n      // really seeking is the last Terminal...\n      this.nextProductionName = \"\";\n      this.nextProductionOccurrence = 0;\n      this.isAtEndOfPath = true;\n    } else {\n      this.nextProductionName = this.ruleStack.pop();\n      this.nextProductionOccurrence = this.occurrenceStack.pop();\n    }\n  }\n}\nexport class NextAfterTokenWalker extends AbstractNextPossibleTokensWalker {\n  constructor(topProd, path) {\n    super(topProd, path);\n    this.path = path;\n    this.nextTerminalName = \"\";\n    this.nextTerminalOccurrence = 0;\n    this.nextTerminalName = this.path.lastTok.name;\n    this.nextTerminalOccurrence = this.path.lastTokOccurrence;\n  }\n  walkTerminal(terminal, currRest, prevRest) {\n    if (this.isAtEndOfPath && terminal.terminalType.name === this.nextTerminalName && terminal.idx === this.nextTerminalOccurrence && !this.found) {\n      const fullRest = currRest.concat(prevRest);\n      const restProd = new Alternative({\n        definition: fullRest\n      });\n      this.possibleTokTypes = first(restProd);\n      this.found = true;\n    }\n  }\n}\n/**\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\n * it never \"follows\" production refs\n */\nexport class AbstractNextTerminalAfterProductionWalker extends RestWalker {\n  constructor(topRule, occurrence) {\n    super();\n    this.topRule = topRule;\n    this.occurrence = occurrence;\n    this.result = {\n      token: undefined,\n      occurrence: undefined,\n      isEndOfRule: undefined\n    };\n  }\n  startWalking() {\n    this.walk(this.topRule);\n    return this.result;\n  }\n}\nexport class NextTerminalAfterManyWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkMany(manyProd, currRest, prevRest) {\n    if (manyProd.idx === this.occurrence) {\n      const firstAfterMany = _first(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterMany === undefined;\n      if (firstAfterMany instanceof Terminal) {\n        this.result.token = firstAfterMany.terminalType;\n        this.result.occurrence = firstAfterMany.idx;\n      }\n    } else {\n      super.walkMany(manyProd, currRest, prevRest);\n    }\n  }\n}\nexport class NextTerminalAfterManySepWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkManySep(manySepProd, currRest, prevRest) {\n    if (manySepProd.idx === this.occurrence) {\n      const firstAfterManySep = _first(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterManySep === undefined;\n      if (firstAfterManySep instanceof Terminal) {\n        this.result.token = firstAfterManySep.terminalType;\n        this.result.occurrence = firstAfterManySep.idx;\n      }\n    } else {\n      super.walkManySep(manySepProd, currRest, prevRest);\n    }\n  }\n}\nexport class NextTerminalAfterAtLeastOneWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n    if (atLeastOneProd.idx === this.occurrence) {\n      const firstAfterAtLeastOne = _first(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterAtLeastOne === undefined;\n      if (firstAfterAtLeastOne instanceof Terminal) {\n        this.result.token = firstAfterAtLeastOne.terminalType;\n        this.result.occurrence = firstAfterAtLeastOne.idx;\n      }\n    } else {\n      super.walkAtLeastOne(atLeastOneProd, currRest, prevRest);\n    }\n  }\n}\n// TODO: reduce code duplication in the AfterWalkers\nexport class NextTerminalAfterAtLeastOneSepWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest) {\n    if (atleastOneSepProd.idx === this.occurrence) {\n      const firstAfterfirstAfterAtLeastOneSep = _first(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined;\n      if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\n        this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\n        this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n      }\n    } else {\n      super.walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest);\n    }\n  }\n}\nexport function possiblePathsFrom(targetDef, maxLength) {\n  let currPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  // avoid side effects\n  currPath = clone(currPath);\n  let result = [];\n  let i = 0;\n  // TODO: avoid inner funcs\n  function remainingPathWith(nextDef) {\n    return nextDef.concat(drop(targetDef, i + 1));\n  }\n  // TODO: avoid inner funcs\n  function getAlternativesForProd(definition) {\n    const alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);\n    return result.concat(alternatives);\n  }\n  /**\n   * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\n   * following (rest) of the targetDef.\n   *\n   * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\n   * the optional production.\n   */\n  while (currPath.length < maxLength && i < targetDef.length) {\n    const prod = targetDef[i];\n    /* istanbul ignore else */\n    if (prod instanceof Alternative) {\n      return getAlternativesForProd(prod.definition);\n    } else if (prod instanceof NonTerminal) {\n      return getAlternativesForProd(prod.definition);\n    } else if (prod instanceof Option) {\n      result = getAlternativesForProd(prod.definition);\n    } else if (prod instanceof RepetitionMandatory) {\n      const newDef = prod.definition.concat([new Repetition({\n        definition: prod.definition\n      })]);\n      return getAlternativesForProd(newDef);\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      const newDef = [new Alternative({\n        definition: prod.definition\n      }), new Repetition({\n        definition: [new Terminal({\n          terminalType: prod.separator\n        })].concat(prod.definition)\n      })];\n      return getAlternativesForProd(newDef);\n    } else if (prod instanceof RepetitionWithSeparator) {\n      const newDef = prod.definition.concat([new Repetition({\n        definition: [new Terminal({\n          terminalType: prod.separator\n        })].concat(prod.definition)\n      })]);\n      result = getAlternativesForProd(newDef);\n    } else if (prod instanceof Repetition) {\n      const newDef = prod.definition.concat([new Repetition({\n        definition: prod.definition\n      })]);\n      result = getAlternativesForProd(newDef);\n    } else if (prod instanceof Alternation) {\n      forEach(prod.definition, currAlt => {\n        // TODO: this is a limited check for empty alternatives\n        //   It would prevent a common case of infinite loops during parser initialization.\n        //   However **in-directly** empty alternatives may still cause issues.\n        if (isEmpty(currAlt.definition) === false) {\n          result = getAlternativesForProd(currAlt.definition);\n        }\n      });\n      return result;\n    } else if (prod instanceof Terminal) {\n      currPath.push(prod.terminalType);\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n    i++;\n  }\n  result.push({\n    partialPath: currPath,\n    suffixDef: drop(targetDef, i)\n  });\n  return result;\n}\nexport function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n  const EXIT_NON_TERMINAL = \"EXIT_NONE_TERMINAL\";\n  // to avoid creating a new Array each time.\n  const EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\n  const EXIT_ALTERNATIVE = \"EXIT_ALTERNATIVE\";\n  let foundCompletePath = false;\n  const tokenVectorLength = tokenVector.length;\n  const minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n  const result = [];\n  const possiblePaths = [];\n  possiblePaths.push({\n    idx: -1,\n    def: initialDef,\n    ruleStack: [],\n    occurrenceStack: []\n  });\n  while (!isEmpty(possiblePaths)) {\n    const currPath = possiblePaths.pop();\n    // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n    if (currPath === EXIT_ALTERNATIVE) {\n      if (foundCompletePath && last(possiblePaths).idx <= minimalAlternativesIndex) {\n        // remove irrelevant alternative\n        possiblePaths.pop();\n      }\n      continue;\n    }\n    const currDef = currPath.def;\n    const currIdx = currPath.idx;\n    const currRuleStack = currPath.ruleStack;\n    const currOccurrenceStack = currPath.occurrenceStack;\n    // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n    if (isEmpty(currDef)) {\n      continue;\n    }\n    const prod = currDef[0];\n    /* istanbul ignore else */\n    if (prod === EXIT_NON_TERMINAL) {\n      const nextPath = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: dropRight(currRuleStack),\n        occurrenceStack: dropRight(currOccurrenceStack)\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof Terminal) {\n      /* istanbul ignore else */\n      if (currIdx < tokenVectorLength - 1) {\n        const nextIdx = currIdx + 1;\n        const actualToken = tokenVector[nextIdx];\n        if (tokMatcher(actualToken, prod.terminalType)) {\n          const nextPath = {\n            idx: nextIdx,\n            def: drop(currDef),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          };\n          possiblePaths.push(nextPath);\n        }\n        // end of the line\n      } else if (currIdx === tokenVectorLength - 1) {\n        // IGNORE ABOVE ELSE\n        result.push({\n          nextTokenType: prod.terminalType,\n          nextTokenOccurrence: prod.idx,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        });\n        foundCompletePath = true;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    } else if (prod instanceof NonTerminal) {\n      const newRuleStack = clone(currRuleStack);\n      newRuleStack.push(prod.nonTerminalName);\n      const newOccurrenceStack = clone(currOccurrenceStack);\n      newOccurrenceStack.push(prod.idx);\n      const nextPath = {\n        idx: currIdx,\n        def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop(currDef)),\n        ruleStack: newRuleStack,\n        occurrenceStack: newOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof Option) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout);\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      const nextPathWith = {\n        idx: currIdx,\n        def: prod.definition.concat(drop(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof RepetitionMandatory) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      const secondIteration = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      });\n      const nextDef = prod.definition.concat([secondIteration], drop(currDef));\n      const nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      const separatorGast = new Terminal({\n        terminalType: prod.separator\n      });\n      const secondIteration = new Repetition({\n        definition: [separatorGast].concat(prod.definition),\n        idx: prod.idx\n      });\n      const nextDef = prod.definition.concat([secondIteration], drop(currDef));\n      const nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof RepetitionWithSeparator) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout);\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      const separatorGast = new Terminal({\n        terminalType: prod.separator\n      });\n      const nthRepetition = new Repetition({\n        definition: [separatorGast].concat(prod.definition),\n        idx: prod.idx\n      });\n      const nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n      const nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof Repetition) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout);\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n      const nthRepetition = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      });\n      const nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n      const nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof Alternation) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      for (let i = prod.definition.length - 1; i >= 0; i--) {\n        const currAlt = prod.definition[i];\n        const currAltPath = {\n          idx: currIdx,\n          def: currAlt.definition.concat(drop(currDef)),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        };\n        possiblePaths.push(currAltPath);\n        possiblePaths.push(EXIT_ALTERNATIVE);\n      }\n    } else if (prod instanceof Alternative) {\n      possiblePaths.push({\n        idx: currIdx,\n        def: prod.definition.concat(drop(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      });\n    } else if (prod instanceof Rule) {\n      // last because we should only encounter at most a single one of these per invocation.\n      possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  }\n  return result;\n}\nfunction expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n  const newRuleStack = clone(currRuleStack);\n  newRuleStack.push(topRule.name);\n  const newCurrOccurrenceStack = clone(currOccurrenceStack);\n  // top rule is always assumed to have been called with occurrence index 1\n  newCurrOccurrenceStack.push(1);\n  return {\n    idx: currIdx,\n    def: topRule.definition,\n    ruleStack: newRuleStack,\n    occurrenceStack: newCurrOccurrenceStack\n  };\n}","map":{"version":3,"names":["clone","drop","dropRight","first","_first","forEach","isEmpty","last","RestWalker","Alternation","Alternative","NonTerminal","Option","Repetition","RepetitionMandatory","RepetitionMandatoryWithSeparator","RepetitionWithSeparator","Rule","Terminal","AbstractNextPossibleTokensWalker","constructor","topProd","path","possibleTokTypes","nextProductionName","nextProductionOccurrence","found","isAtEndOfPath","startWalking","ruleStack","name","Error","reverse","occurrenceStack","pop","updateExpectedNext","walk","prod","prevRest","arguments","length","undefined","walkProdRef","refProd","currRest","referencedRule","idx","fullRest","concat","NextAfterTokenWalker","nextTerminalName","nextTerminalOccurrence","lastTok","lastTokOccurrence","walkTerminal","terminal","terminalType","restProd","definition","AbstractNextTerminalAfterProductionWalker","topRule","occurrence","result","token","isEndOfRule","NextTerminalAfterManyWalker","walkMany","manyProd","firstAfterMany","NextTerminalAfterManySepWalker","walkManySep","manySepProd","firstAfterManySep","NextTerminalAfterAtLeastOneWalker","walkAtLeastOne","atLeastOneProd","firstAfterAtLeastOne","NextTerminalAfterAtLeastOneSepWalker","walkAtLeastOneSep","atleastOneSepProd","firstAfterfirstAfterAtLeastOneSep","possiblePathsFrom","targetDef","maxLength","currPath","i","remainingPathWith","nextDef","getAlternativesForProd","alternatives","newDef","separator","currAlt","push","partialPath","suffixDef","nextPossibleTokensAfter","initialDef","tokenVector","tokMatcher","maxLookAhead","EXIT_NON_TERMINAL","EXIT_NON_TERMINAL_ARR","EXIT_ALTERNATIVE","foundCompletePath","tokenVectorLength","minimalAlternativesIndex","possiblePaths","def","currDef","currIdx","currRuleStack","currOccurrenceStack","nextPath","nextIdx","actualToken","nextTokenType","nextTokenOccurrence","newRuleStack","nonTerminalName","newOccurrenceStack","nextPathWithout","nextPathWith","secondIteration","separatorGast","nthRepetition","currAltPath","expandTopLevelRule","newCurrOccurrenceStack"],"sources":["/home/saiadmin/k3s-cluster/dashboard/frontend/node_modules/chevrotain/src/parse/grammar/interpreter.ts"],"sourcesContent":["import {\n  clone,\n  drop,\n  dropRight,\n  first as _first,\n  forEach,\n  isEmpty,\n  last,\n} from \"lodash-es\";\nimport { first } from \"./first.js\";\nimport { RestWalker } from \"./rest.js\";\nimport { TokenMatcher } from \"../parser/parser.js\";\nimport {\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal,\n} from \"@chevrotain/gast\";\nimport {\n  IGrammarPath,\n  IProduction,\n  ISyntacticContentAssistPath,\n  IToken,\n  ITokenGrammarPath,\n  TokenType,\n} from \"@chevrotain/types\";\n\nexport abstract class AbstractNextPossibleTokensWalker extends RestWalker {\n  protected possibleTokTypes: TokenType[] = [];\n  protected ruleStack: string[];\n  protected occurrenceStack: number[];\n\n  protected nextProductionName = \"\";\n  protected nextProductionOccurrence = 0;\n  protected found = false;\n  protected isAtEndOfPath = false;\n\n  constructor(\n    protected topProd: Rule,\n    protected path: IGrammarPath,\n  ) {\n    super();\n  }\n\n  startWalking(): TokenType[] {\n    this.found = false;\n\n    if (this.path.ruleStack[0] !== this.topProd.name) {\n      throw Error(\"The path does not start with the walker's top Rule!\");\n    }\n\n    // immutable for the win\n    this.ruleStack = clone(this.path.ruleStack).reverse(); // intelij bug requires assertion\n    this.occurrenceStack = clone(this.path.occurrenceStack).reverse(); // intelij bug requires assertion\n\n    // already verified that the first production is valid, we now seek the 2nd production\n    this.ruleStack.pop();\n    this.occurrenceStack.pop();\n\n    this.updateExpectedNext();\n    this.walk(this.topProd);\n\n    return this.possibleTokTypes;\n  }\n\n  walk(\n    prod: { definition: IProduction[] },\n    prevRest: IProduction[] = [],\n  ): void {\n    // stop scanning once we found the path\n    if (!this.found) {\n      super.walk(prod, prevRest);\n    }\n  }\n\n  walkProdRef(\n    refProd: NonTerminal,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    // found the next production, need to keep walking in it\n    if (\n      refProd.referencedRule.name === this.nextProductionName &&\n      refProd.idx === this.nextProductionOccurrence\n    ) {\n      const fullRest = currRest.concat(prevRest);\n      this.updateExpectedNext();\n      this.walk(refProd.referencedRule, <any>fullRest);\n    }\n  }\n\n  updateExpectedNext(): void {\n    // need to consume the Terminal\n    if (isEmpty(this.ruleStack)) {\n      // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n      // really seeking is the last Terminal...\n      this.nextProductionName = \"\";\n      this.nextProductionOccurrence = 0;\n      this.isAtEndOfPath = true;\n    } else {\n      this.nextProductionName = this.ruleStack.pop()!;\n      this.nextProductionOccurrence = this.occurrenceStack.pop()!;\n    }\n  }\n}\n\nexport class NextAfterTokenWalker extends AbstractNextPossibleTokensWalker {\n  private nextTerminalName = \"\";\n  private nextTerminalOccurrence = 0;\n\n  constructor(\n    topProd: Rule,\n    protected path: ITokenGrammarPath,\n  ) {\n    super(topProd, path);\n    this.nextTerminalName = this.path.lastTok.name;\n    this.nextTerminalOccurrence = this.path.lastTokOccurrence;\n  }\n\n  walkTerminal(\n    terminal: Terminal,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    if (\n      this.isAtEndOfPath &&\n      terminal.terminalType.name === this.nextTerminalName &&\n      terminal.idx === this.nextTerminalOccurrence &&\n      !this.found\n    ) {\n      const fullRest = currRest.concat(prevRest);\n      const restProd = new Alternative({ definition: fullRest });\n      this.possibleTokTypes = first(restProd);\n      this.found = true;\n    }\n  }\n}\n\nexport type AlternativesFirstTokens = TokenType[][];\n\nexport interface IFirstAfterRepetition {\n  token: TokenType | undefined;\n  occurrence: number | undefined;\n  isEndOfRule: boolean | undefined;\n}\n\n/**\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\n * it never \"follows\" production refs\n */\nexport class AbstractNextTerminalAfterProductionWalker extends RestWalker {\n  protected result: IFirstAfterRepetition = {\n    token: undefined,\n    occurrence: undefined,\n    isEndOfRule: undefined,\n  };\n\n  constructor(\n    protected topRule: Rule,\n    protected occurrence: number,\n  ) {\n    super();\n  }\n\n  startWalking(): IFirstAfterRepetition {\n    this.walk(this.topRule);\n    return this.result;\n  }\n}\n\nexport class NextTerminalAfterManyWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkMany(\n    manyProd: Repetition,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    if (manyProd.idx === this.occurrence) {\n      const firstAfterMany = _first(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterMany === undefined;\n      if (firstAfterMany instanceof Terminal) {\n        this.result.token = firstAfterMany.terminalType;\n        this.result.occurrence = firstAfterMany.idx;\n      }\n    } else {\n      super.walkMany(manyProd, currRest, prevRest);\n    }\n  }\n}\n\nexport class NextTerminalAfterManySepWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkManySep(\n    manySepProd: RepetitionWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    if (manySepProd.idx === this.occurrence) {\n      const firstAfterManySep = _first(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterManySep === undefined;\n      if (firstAfterManySep instanceof Terminal) {\n        this.result.token = firstAfterManySep.terminalType;\n        this.result.occurrence = firstAfterManySep.idx;\n      }\n    } else {\n      super.walkManySep(manySepProd, currRest, prevRest);\n    }\n  }\n}\n\nexport class NextTerminalAfterAtLeastOneWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkAtLeastOne(\n    atLeastOneProd: RepetitionMandatory,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    if (atLeastOneProd.idx === this.occurrence) {\n      const firstAfterAtLeastOne = _first(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterAtLeastOne === undefined;\n      if (firstAfterAtLeastOne instanceof Terminal) {\n        this.result.token = firstAfterAtLeastOne.terminalType;\n        this.result.occurrence = firstAfterAtLeastOne.idx;\n      }\n    } else {\n      super.walkAtLeastOne(atLeastOneProd, currRest, prevRest);\n    }\n  }\n}\n\n// TODO: reduce code duplication in the AfterWalkers\nexport class NextTerminalAfterAtLeastOneSepWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkAtLeastOneSep(\n    atleastOneSepProd: RepetitionMandatoryWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    if (atleastOneSepProd.idx === this.occurrence) {\n      const firstAfterfirstAfterAtLeastOneSep = _first(\n        currRest.concat(prevRest),\n      );\n      this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined;\n      if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\n        this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\n        this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n      }\n    } else {\n      super.walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest);\n    }\n  }\n}\n\nexport interface PartialPathAndSuffixes {\n  partialPath: TokenType[];\n  suffixDef: IProduction[];\n}\n\nexport function possiblePathsFrom(\n  targetDef: IProduction[],\n  maxLength: number,\n  currPath: TokenType[] = [],\n): PartialPathAndSuffixes[] {\n  // avoid side effects\n  currPath = clone(currPath);\n  let result: PartialPathAndSuffixes[] = [];\n  let i = 0;\n\n  // TODO: avoid inner funcs\n  function remainingPathWith(nextDef: IProduction[]) {\n    return nextDef.concat(drop(targetDef, i + 1));\n  }\n\n  // TODO: avoid inner funcs\n  function getAlternativesForProd(definition: IProduction[]) {\n    const alternatives = possiblePathsFrom(\n      remainingPathWith(definition),\n      maxLength,\n      currPath,\n    );\n    return result.concat(alternatives);\n  }\n\n  /**\n   * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\n   * following (rest) of the targetDef.\n   *\n   * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\n   * the optional production.\n   */\n  while (currPath.length < maxLength && i < targetDef.length) {\n    const prod = targetDef[i];\n\n    /* istanbul ignore else */\n    if (prod instanceof Alternative) {\n      return getAlternativesForProd(prod.definition);\n    } else if (prod instanceof NonTerminal) {\n      return getAlternativesForProd(prod.definition);\n    } else if (prod instanceof Option) {\n      result = getAlternativesForProd(prod.definition);\n    } else if (prod instanceof RepetitionMandatory) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: prod.definition,\n        }),\n      ]);\n      return getAlternativesForProd(newDef);\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      const newDef = [\n        new Alternative({ definition: prod.definition }),\n        new Repetition({\n          definition: [new Terminal({ terminalType: prod.separator })].concat(\n            <any>prod.definition,\n          ),\n        }),\n      ];\n      return getAlternativesForProd(newDef);\n    } else if (prod instanceof RepetitionWithSeparator) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: [new Terminal({ terminalType: prod.separator })].concat(\n            <any>prod.definition,\n          ),\n        }),\n      ]);\n      result = getAlternativesForProd(newDef);\n    } else if (prod instanceof Repetition) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: prod.definition,\n        }),\n      ]);\n      result = getAlternativesForProd(newDef);\n    } else if (prod instanceof Alternation) {\n      forEach(prod.definition, (currAlt) => {\n        // TODO: this is a limited check for empty alternatives\n        //   It would prevent a common case of infinite loops during parser initialization.\n        //   However **in-directly** empty alternatives may still cause issues.\n        if (isEmpty(currAlt.definition) === false) {\n          result = getAlternativesForProd(currAlt.definition);\n        }\n      });\n      return result;\n    } else if (prod instanceof Terminal) {\n      currPath.push(prod.terminalType);\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n\n    i++;\n  }\n  result.push({\n    partialPath: currPath,\n    suffixDef: drop(targetDef, i),\n  });\n\n  return result;\n}\n\ninterface IPathToExamine {\n  idx: number;\n  def: IProduction[];\n  ruleStack: string[];\n  occurrenceStack: number[];\n}\n\nexport function nextPossibleTokensAfter(\n  initialDef: IProduction[],\n  tokenVector: IToken[],\n  tokMatcher: TokenMatcher,\n  maxLookAhead: number,\n): ISyntacticContentAssistPath[] {\n  const EXIT_NON_TERMINAL: any = \"EXIT_NONE_TERMINAL\";\n  // to avoid creating a new Array each time.\n  const EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\n  const EXIT_ALTERNATIVE: any = \"EXIT_ALTERNATIVE\";\n  let foundCompletePath = false;\n\n  const tokenVectorLength = tokenVector.length;\n  const minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n\n  const result: ISyntacticContentAssistPath[] = [];\n\n  const possiblePaths: IPathToExamine[] = [];\n  possiblePaths.push({\n    idx: -1,\n    def: initialDef,\n    ruleStack: [],\n    occurrenceStack: [],\n  });\n\n  while (!isEmpty(possiblePaths)) {\n    const currPath = possiblePaths.pop()!;\n\n    // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n    if (currPath === EXIT_ALTERNATIVE) {\n      if (\n        foundCompletePath &&\n        last(possiblePaths)!.idx <= minimalAlternativesIndex\n      ) {\n        // remove irrelevant alternative\n        possiblePaths.pop();\n      }\n      continue;\n    }\n\n    const currDef = currPath.def;\n    const currIdx = currPath.idx;\n    const currRuleStack = currPath.ruleStack;\n    const currOccurrenceStack = currPath.occurrenceStack;\n\n    // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n    if (isEmpty(currDef)) {\n      continue;\n    }\n\n    const prod = currDef[0];\n    /* istanbul ignore else */\n    if (prod === EXIT_NON_TERMINAL) {\n      const nextPath = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: dropRight(currRuleStack),\n        occurrenceStack: dropRight(currOccurrenceStack),\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof Terminal) {\n      /* istanbul ignore else */\n      if (currIdx < tokenVectorLength - 1) {\n        const nextIdx = currIdx + 1;\n        const actualToken = tokenVector[nextIdx];\n        if (tokMatcher!(actualToken, prod.terminalType)) {\n          const nextPath = {\n            idx: nextIdx,\n            def: drop(currDef),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack,\n          };\n          possiblePaths.push(nextPath);\n        }\n        // end of the line\n      } else if (currIdx === tokenVectorLength - 1) {\n        // IGNORE ABOVE ELSE\n        result.push({\n          nextTokenType: prod.terminalType,\n          nextTokenOccurrence: prod.idx,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        });\n        foundCompletePath = true;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    } else if (prod instanceof NonTerminal) {\n      const newRuleStack = clone(currRuleStack);\n      newRuleStack.push(prod.nonTerminalName);\n\n      const newOccurrenceStack = clone(currOccurrenceStack);\n      newOccurrenceStack.push(prod.idx);\n\n      const nextPath = {\n        idx: currIdx,\n        def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop(currDef)),\n        ruleStack: newRuleStack,\n        occurrenceStack: newOccurrenceStack,\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof Option) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack,\n      };\n      possiblePaths.push(nextPathWithout);\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE);\n\n      const nextPathWith = {\n        idx: currIdx,\n        def: prod.definition.concat(drop(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack,\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof RepetitionMandatory) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      const secondIteration = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx,\n      });\n      const nextDef = prod.definition.concat([secondIteration], drop(currDef));\n      const nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack,\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      const separatorGast = new Terminal({\n        terminalType: prod.separator,\n      });\n      const secondIteration = new Repetition({\n        definition: [<any>separatorGast].concat(prod.definition),\n        idx: prod.idx,\n      });\n      const nextDef = prod.definition.concat([secondIteration], drop(currDef));\n      const nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack,\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof RepetitionWithSeparator) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack,\n      };\n      possiblePaths.push(nextPathWithout);\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE);\n\n      const separatorGast = new Terminal({\n        terminalType: prod.separator,\n      });\n      const nthRepetition = new Repetition({\n        definition: [<any>separatorGast].concat(prod.definition),\n        idx: prod.idx,\n      });\n      const nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n      const nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack,\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof Repetition) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack,\n      };\n      possiblePaths.push(nextPathWithout);\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE);\n\n      // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n      const nthRepetition = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx,\n      });\n      const nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n      const nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack,\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof Alternation) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      for (let i = prod.definition.length - 1; i >= 0; i--) {\n        const currAlt: any = prod.definition[i];\n        const currAltPath = {\n          idx: currIdx,\n          def: currAlt.definition.concat(drop(currDef)),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        };\n        possiblePaths.push(currAltPath);\n        possiblePaths.push(EXIT_ALTERNATIVE);\n      }\n    } else if (prod instanceof Alternative) {\n      possiblePaths.push({\n        idx: currIdx,\n        def: prod.definition.concat(drop(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack,\n      });\n    } else if (prod instanceof Rule) {\n      // last because we should only encounter at most a single one of these per invocation.\n      possiblePaths.push(\n        expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack),\n      );\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  }\n  return result;\n}\n\nfunction expandTopLevelRule(\n  topRule: Rule,\n  currIdx: number,\n  currRuleStack: string[],\n  currOccurrenceStack: number[],\n): IPathToExamine {\n  const newRuleStack = clone(currRuleStack);\n  newRuleStack.push(topRule.name);\n\n  const newCurrOccurrenceStack = clone(currOccurrenceStack);\n  // top rule is always assumed to have been called with occurrence index 1\n  newCurrOccurrenceStack.push(1);\n\n  return {\n    idx: currIdx,\n    def: topRule.definition,\n    ruleStack: newRuleStack,\n    occurrenceStack: newCurrOccurrenceStack,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}