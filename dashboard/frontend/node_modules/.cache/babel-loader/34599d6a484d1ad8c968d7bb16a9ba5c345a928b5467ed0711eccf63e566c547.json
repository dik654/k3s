{"ast":null,"code":"import _objectSpread from \"/home/saiadmin/k3s-cluster/dashboard/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { emojiComponents } from \"../data.js\";\n\n/**\n* Merge types for unique key\n*/\nfunction mergeComponentTypes(value) {\n  return \"[\" + value.join(\",\") + \"]\";\n}\n/**\n* Merge count for unique key\n*/\nfunction mergeComponentsCount(value) {\n  const keys = [];\n  for (const key in emojiComponents) {\n    const type = key;\n    for (let i = 0; i < value[type]; i++) keys.push(type);\n  }\n  return keys.length ? mergeComponentTypes(keys) : \"\";\n}\n/**\n* Get item from group\n*/\nfunction getGroupItem(items, components) {\n  const item = items[mergeComponentsCount(components)];\n  if (item) {\n    item.parsed = true;\n    return item.item;\n  }\n}\n/**\n* Convert test data to dependencies tree, based on components\n*/\nfunction getEmojiTestDataTree(data) {\n  const groups = Object.create(null);\n  for (const key in data) {\n    const item = data[key];\n    const text = item.name.key;\n    const parent = groups[text] || (groups[text] = {});\n    const components = {\n      \"hair-style\": 0,\n      \"skin-tone\": 0\n    };\n    item.sequence.forEach(value => {\n      if (typeof value !== \"number\") components[value]++;\n    });\n    const componentsKey = mergeComponentsCount(components);\n    if (parent[componentsKey]) throw new Error(\"Duplicate components tree item for \\\"\".concat(text, \"\\\"\"));\n    parent[componentsKey] = {\n      item: _objectSpread(_objectSpread({}, item), {}, {\n        components,\n        componentsKey\n      })\n    };\n  }\n  const results = Object.create(null);\n  for (const key in groups) {\n    const items = groups[key];\n    const check = (parent, parentComponents, type) => {\n      const item = parse(parentComponents, [type]);\n      if (item) {\n        const children = parent.children || (parent.children = {});\n        children[type] = item;\n        return true;\n      }\n    };\n    const parse = (parentComponents, newComponents) => {\n      const components = {\n        \"hair-style\": 0,\n        \"skin-tone\": 0\n      };\n      const componentsList = parentComponents.concat(newComponents);\n      componentsList.forEach(type => {\n        components[type]++;\n      });\n      let item = getGroupItem(items, components);\n      if (!item && newComponents.length === 1 && newComponents[0] === \"skin-tone\") {\n        const doubleComponents = _objectSpread({}, components);\n        doubleComponents[\"skin-tone\"]++;\n        item = getGroupItem(items, doubleComponents);\n      }\n      if (item) {\n        const result = {\n          item\n        };\n        for (const key$1 in emojiComponents) check(result, componentsList, key$1);\n        return result;\n      }\n    };\n    const root = parse([], []);\n    if (!root) throw new Error(\"Cannot find parent item for \\\"\".concat(key, \"\\\"\"));\n    for (const itemsKey in items) if (!items[itemsKey].parsed) throw new Error(\"Error generating tree for \\\"\".concat(key, \"\\\"\"));\n    if (root.children) results[key] = root;\n  }\n  return results;\n}\nexport { getEmojiTestDataTree };","map":{"version":3,"names":["emojiComponents","mergeComponentTypes","value","join","mergeComponentsCount","keys","key","type","i","push","length","getGroupItem","items","components","item","parsed","getEmojiTestDataTree","data","groups","Object","create","text","name","parent","sequence","forEach","componentsKey","Error","concat","_objectSpread","results","check","parentComponents","parse","children","newComponents","componentsList","doubleComponents","result","key$1","root","itemsKey"],"sources":["/home/saiadmin/k3s-cluster/dashboard/frontend/node_modules/@iconify/utils/lib/emoji/test/tree.js"],"sourcesContent":["import { emojiComponents } from \"../data.js\";\n\n/**\n* Merge types for unique key\n*/\nfunction mergeComponentTypes(value) {\n\treturn \"[\" + value.join(\",\") + \"]\";\n}\n/**\n* Merge count for unique key\n*/\nfunction mergeComponentsCount(value) {\n\tconst keys = [];\n\tfor (const key in emojiComponents) {\n\t\tconst type = key;\n\t\tfor (let i = 0; i < value[type]; i++) keys.push(type);\n\t}\n\treturn keys.length ? mergeComponentTypes(keys) : \"\";\n}\n/**\n* Get item from group\n*/\nfunction getGroupItem(items, components) {\n\tconst item = items[mergeComponentsCount(components)];\n\tif (item) {\n\t\titem.parsed = true;\n\t\treturn item.item;\n\t}\n}\n/**\n* Convert test data to dependencies tree, based on components\n*/\nfunction getEmojiTestDataTree(data) {\n\tconst groups = Object.create(null);\n\tfor (const key in data) {\n\t\tconst item = data[key];\n\t\tconst text = item.name.key;\n\t\tconst parent = groups[text] || (groups[text] = {});\n\t\tconst components = {\n\t\t\t\"hair-style\": 0,\n\t\t\t\"skin-tone\": 0\n\t\t};\n\t\titem.sequence.forEach((value) => {\n\t\t\tif (typeof value !== \"number\") components[value]++;\n\t\t});\n\t\tconst componentsKey = mergeComponentsCount(components);\n\t\tif (parent[componentsKey]) throw new Error(`Duplicate components tree item for \"${text}\"`);\n\t\tparent[componentsKey] = { item: {\n\t\t\t...item,\n\t\t\tcomponents,\n\t\t\tcomponentsKey\n\t\t} };\n\t}\n\tconst results = Object.create(null);\n\tfor (const key in groups) {\n\t\tconst items = groups[key];\n\t\tconst check = (parent, parentComponents, type) => {\n\t\t\tconst item = parse(parentComponents, [type]);\n\t\t\tif (item) {\n\t\t\t\tconst children = parent.children || (parent.children = {});\n\t\t\t\tchildren[type] = item;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t\tconst parse = (parentComponents, newComponents) => {\n\t\t\tconst components = {\n\t\t\t\t\"hair-style\": 0,\n\t\t\t\t\"skin-tone\": 0\n\t\t\t};\n\t\t\tconst componentsList = parentComponents.concat(newComponents);\n\t\t\tcomponentsList.forEach((type) => {\n\t\t\t\tcomponents[type]++;\n\t\t\t});\n\t\t\tlet item = getGroupItem(items, components);\n\t\t\tif (!item && newComponents.length === 1 && newComponents[0] === \"skin-tone\") {\n\t\t\t\tconst doubleComponents = { ...components };\n\t\t\t\tdoubleComponents[\"skin-tone\"]++;\n\t\t\t\titem = getGroupItem(items, doubleComponents);\n\t\t\t}\n\t\t\tif (item) {\n\t\t\t\tconst result = { item };\n\t\t\t\tfor (const key$1 in emojiComponents) check(result, componentsList, key$1);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t};\n\t\tconst root = parse([], []);\n\t\tif (!root) throw new Error(`Cannot find parent item for \"${key}\"`);\n\t\tfor (const itemsKey in items) if (!items[itemsKey].parsed) throw new Error(`Error generating tree for \"${key}\"`);\n\t\tif (root.children) results[key] = root;\n\t}\n\treturn results;\n}\n\nexport { getEmojiTestDataTree };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}