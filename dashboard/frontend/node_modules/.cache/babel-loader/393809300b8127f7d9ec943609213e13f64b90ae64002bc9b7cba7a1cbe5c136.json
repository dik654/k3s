{"ast":null,"code":"import _objectSpread from \"/home/saiadmin/k3s-cluster/dashboard/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { decodeEntities } from \"./chunk-S3R3BYOJ.mjs\";\nimport { common_default, getConfig, hasKatex, renderKatexSanitized, sanitizeText } from \"./chunk-ABZYJK2D.mjs\";\nimport { __name, log } from \"./chunk-AGHRB4JF.mjs\";\n\n// src/rendering-util/icons.ts\nimport { getIconData, iconToHTML, iconToSVG, replaceIDs, stringToIcon } from \"@iconify/utils\";\nvar unknownIcon = {\n  body: '<g><rect width=\"80\" height=\"80\" style=\"fill: #087ebf; stroke-width: 0px;\"/><text transform=\"translate(21.16 64.67)\" style=\"fill: #fff; font-family: ArialMT, Arial; font-size: 67.75px;\"><tspan x=\"0\" y=\"0\">?</tspan></text></g>',\n  height: 80,\n  width: 80\n};\nvar iconsStore = /* @__PURE__ */new Map();\nvar loaderStore = /* @__PURE__ */new Map();\nvar registerIconPacks = /* @__PURE__ */__name(iconLoaders => {\n  for (const iconLoader of iconLoaders) {\n    if (!iconLoader.name) {\n      throw new Error('Invalid icon loader. Must have a \"name\" property with non-empty string value.');\n    }\n    log.debug(\"Registering icon pack:\", iconLoader.name);\n    if (\"loader\" in iconLoader) {\n      loaderStore.set(iconLoader.name, iconLoader.loader);\n    } else if (\"icons\" in iconLoader) {\n      iconsStore.set(iconLoader.name, iconLoader.icons);\n    } else {\n      log.error(\"Invalid icon loader:\", iconLoader);\n      throw new Error('Invalid icon loader. Must have either \"icons\" or \"loader\" property.');\n    }\n  }\n}, \"registerIconPacks\");\nvar getRegisteredIconData = /* @__PURE__ */__name(async (iconName, fallbackPrefix) => {\n  const data = stringToIcon(iconName, true, fallbackPrefix !== void 0);\n  if (!data) {\n    throw new Error(\"Invalid icon name: \".concat(iconName));\n  }\n  const prefix = data.prefix || fallbackPrefix;\n  if (!prefix) {\n    throw new Error(\"Icon name must contain a prefix: \".concat(iconName));\n  }\n  let icons = iconsStore.get(prefix);\n  if (!icons) {\n    const loader = loaderStore.get(prefix);\n    if (!loader) {\n      throw new Error(\"Icon set not found: \".concat(data.prefix));\n    }\n    try {\n      const loaded = await loader();\n      icons = _objectSpread(_objectSpread({}, loaded), {}, {\n        prefix\n      });\n      iconsStore.set(prefix, icons);\n    } catch (e) {\n      log.error(e);\n      throw new Error(\"Failed to load icon set: \".concat(data.prefix));\n    }\n  }\n  const iconData = getIconData(icons, data.name);\n  if (!iconData) {\n    throw new Error(\"Icon not found: \".concat(iconName));\n  }\n  return iconData;\n}, \"getRegisteredIconData\");\nvar isIconAvailable = /* @__PURE__ */__name(async iconName => {\n  try {\n    await getRegisteredIconData(iconName);\n    return true;\n  } catch (_unused) {\n    return false;\n  }\n}, \"isIconAvailable\");\nvar getIconSVG = /* @__PURE__ */__name(async (iconName, customisations, extraAttributes) => {\n  let iconData;\n  try {\n    iconData = await getRegisteredIconData(iconName, customisations === null || customisations === void 0 ? void 0 : customisations.fallbackPrefix);\n  } catch (e) {\n    log.error(e);\n    iconData = unknownIcon;\n  }\n  const renderData = iconToSVG(iconData, customisations);\n  const svg = iconToHTML(replaceIDs(renderData.body), _objectSpread(_objectSpread({}, renderData.attributes), extraAttributes));\n  return sanitizeText(svg, getConfig());\n}, \"getIconSVG\");\n\n// src/rendering-util/createText.ts\nimport { select } from \"d3\";\n\n// src/rendering-util/handle-markdown-text.ts\nimport { marked } from \"marked\";\nimport { dedent } from \"ts-dedent\";\nfunction preprocessMarkdown(markdown, _ref) {\n  let {\n    markdownAutoWrap\n  } = _ref;\n  const withoutBR = markdown.replace(/<br\\/>/g, \"\\n\");\n  const withoutMultipleNewlines = withoutBR.replace(/\\n{2,}/g, \"\\n\");\n  const withoutExtraSpaces = dedent(withoutMultipleNewlines);\n  if (markdownAutoWrap === false) {\n    return withoutExtraSpaces.replace(/ /g, \"&nbsp;\");\n  }\n  return withoutExtraSpaces;\n}\n__name(preprocessMarkdown, \"preprocessMarkdown\");\nfunction markdownToLines(markdown) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const preprocessedMarkdown = preprocessMarkdown(markdown, config);\n  const nodes = marked.lexer(preprocessedMarkdown);\n  const lines = [[]];\n  let currentLine = 0;\n  function processNode(node) {\n    let parentType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"normal\";\n    if (node.type === \"text\") {\n      const textLines = node.text.split(\"\\n\");\n      textLines.forEach((textLine, index) => {\n        if (index !== 0) {\n          currentLine++;\n          lines.push([]);\n        }\n        textLine.split(\" \").forEach(word => {\n          word = word.replace(/&#39;/g, \"'\");\n          if (word) {\n            lines[currentLine].push({\n              content: word,\n              type: parentType\n            });\n          }\n        });\n      });\n    } else if (node.type === \"strong\" || node.type === \"em\") {\n      node.tokens.forEach(contentNode => {\n        processNode(contentNode, node.type);\n      });\n    } else if (node.type === \"html\") {\n      lines[currentLine].push({\n        content: node.text,\n        type: \"normal\"\n      });\n    }\n  }\n  __name(processNode, \"processNode\");\n  nodes.forEach(treeNode => {\n    if (treeNode.type === \"paragraph\") {\n      var _treeNode$tokens;\n      (_treeNode$tokens = treeNode.tokens) === null || _treeNode$tokens === void 0 || _treeNode$tokens.forEach(contentNode => {\n        processNode(contentNode);\n      });\n    } else if (treeNode.type === \"html\") {\n      lines[currentLine].push({\n        content: treeNode.text,\n        type: \"normal\"\n      });\n    } else {\n      lines[currentLine].push({\n        content: treeNode.raw,\n        type: \"normal\"\n      });\n    }\n  });\n  return lines;\n}\n__name(markdownToLines, \"markdownToLines\");\nfunction markdownToHTML(markdown) {\n  let {\n    markdownAutoWrap\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const nodes = marked.lexer(markdown);\n  function output(node) {\n    if (node.type === \"text\") {\n      if (markdownAutoWrap === false) {\n        return node.text.replace(/\\n */g, \"<br/>\").replace(/ /g, \"&nbsp;\");\n      }\n      return node.text.replace(/\\n */g, \"<br/>\");\n    } else if (node.type === \"strong\") {\n      var _node$tokens;\n      return \"<strong>\".concat((_node$tokens = node.tokens) === null || _node$tokens === void 0 ? void 0 : _node$tokens.map(output).join(\"\"), \"</strong>\");\n    } else if (node.type === \"em\") {\n      var _node$tokens2;\n      return \"<em>\".concat((_node$tokens2 = node.tokens) === null || _node$tokens2 === void 0 ? void 0 : _node$tokens2.map(output).join(\"\"), \"</em>\");\n    } else if (node.type === \"paragraph\") {\n      var _node$tokens3;\n      return \"<p>\".concat((_node$tokens3 = node.tokens) === null || _node$tokens3 === void 0 ? void 0 : _node$tokens3.map(output).join(\"\"), \"</p>\");\n    } else if (node.type === \"space\") {\n      return \"\";\n    } else if (node.type === \"html\") {\n      return \"\".concat(node.text);\n    } else if (node.type === \"escape\") {\n      return node.text;\n    }\n    log.warn(\"Unsupported markdown: \".concat(node.type));\n    return node.raw;\n  }\n  __name(output, \"output\");\n  return nodes.map(output).join(\"\");\n}\n__name(markdownToHTML, \"markdownToHTML\");\n\n// src/rendering-util/splitText.ts\nfunction splitTextToChars(text) {\n  if (Intl.Segmenter) {\n    return [...new Intl.Segmenter().segment(text)].map(s => s.segment);\n  }\n  return [...text];\n}\n__name(splitTextToChars, \"splitTextToChars\");\nfunction splitWordToFitWidth(checkFit, word) {\n  const characters = splitTextToChars(word.content);\n  return splitWordToFitWidthRecursion(checkFit, [], characters, word.type);\n}\n__name(splitWordToFitWidth, \"splitWordToFitWidth\");\nfunction splitWordToFitWidthRecursion(checkFit, usedChars, remainingChars, type) {\n  if (remainingChars.length === 0) {\n    return [{\n      content: usedChars.join(\"\"),\n      type\n    }, {\n      content: \"\",\n      type\n    }];\n  }\n  const [nextChar, ...rest] = remainingChars;\n  const newWord = [...usedChars, nextChar];\n  if (checkFit([{\n    content: newWord.join(\"\"),\n    type\n  }])) {\n    return splitWordToFitWidthRecursion(checkFit, newWord, rest, type);\n  }\n  if (usedChars.length === 0 && nextChar) {\n    usedChars.push(nextChar);\n    remainingChars.shift();\n  }\n  return [{\n    content: usedChars.join(\"\"),\n    type\n  }, {\n    content: remainingChars.join(\"\"),\n    type\n  }];\n}\n__name(splitWordToFitWidthRecursion, \"splitWordToFitWidthRecursion\");\nfunction splitLineToFitWidth(line, checkFit) {\n  if (line.some(_ref2 => {\n    let {\n      content\n    } = _ref2;\n    return content.includes(\"\\n\");\n  })) {\n    throw new Error(\"splitLineToFitWidth does not support newlines in the line\");\n  }\n  return splitLineToFitWidthRecursion(line, checkFit);\n}\n__name(splitLineToFitWidth, \"splitLineToFitWidth\");\nfunction splitLineToFitWidthRecursion(words, checkFit) {\n  var _words$shift;\n  let lines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let newLine = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  if (words.length === 0) {\n    if (newLine.length > 0) {\n      lines.push(newLine);\n    }\n    return lines.length > 0 ? lines : [];\n  }\n  let joiner = \"\";\n  if (words[0].content === \" \") {\n    joiner = \" \";\n    words.shift();\n  }\n  const nextWord = (_words$shift = words.shift()) !== null && _words$shift !== void 0 ? _words$shift : {\n    content: \" \",\n    type: \"normal\"\n  };\n  const lineWithNextWord = [...newLine];\n  if (joiner !== \"\") {\n    lineWithNextWord.push({\n      content: joiner,\n      type: \"normal\"\n    });\n  }\n  lineWithNextWord.push(nextWord);\n  if (checkFit(lineWithNextWord)) {\n    return splitLineToFitWidthRecursion(words, checkFit, lines, lineWithNextWord);\n  }\n  if (newLine.length > 0) {\n    lines.push(newLine);\n    words.unshift(nextWord);\n  } else if (nextWord.content) {\n    const [line, rest] = splitWordToFitWidth(checkFit, nextWord);\n    lines.push([line]);\n    if (rest.content) {\n      words.unshift(rest);\n    }\n  }\n  return splitLineToFitWidthRecursion(words, checkFit, lines);\n}\n__name(splitLineToFitWidthRecursion, \"splitLineToFitWidthRecursion\");\n\n// src/rendering-util/createText.ts\nfunction applyStyle(dom, styleFn) {\n  if (styleFn) {\n    dom.attr(\"style\", styleFn);\n  }\n}\n__name(applyStyle, \"applyStyle\");\nasync function addHtmlSpan(element, node, width, classes) {\n  let addBackground = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  let config = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : getConfig();\n  const fo = element.append(\"foreignObject\");\n  fo.attr(\"width\", \"\".concat(10 * width, \"px\"));\n  fo.attr(\"height\", \"\".concat(10 * width, \"px\"));\n  const div = fo.append(\"xhtml:div\");\n  const sanitizedLabel = hasKatex(node.label) ? await renderKatexSanitized(node.label.replace(common_default.lineBreakRegex, \"\\n\"), config) : sanitizeText(node.label, config);\n  const labelClass = node.isNode ? \"nodeLabel\" : \"edgeLabel\";\n  const span = div.append(\"span\");\n  span.html(sanitizedLabel);\n  applyStyle(span, node.labelStyle);\n  span.attr(\"class\", \"\".concat(labelClass, \" \").concat(classes));\n  applyStyle(div, node.labelStyle);\n  div.style(\"display\", \"table-cell\");\n  div.style(\"white-space\", \"nowrap\");\n  div.style(\"line-height\", \"1.5\");\n  div.style(\"max-width\", width + \"px\");\n  div.style(\"text-align\", \"center\");\n  div.attr(\"xmlns\", \"http://www.w3.org/1999/xhtml\");\n  if (addBackground) {\n    div.attr(\"class\", \"labelBkg\");\n  }\n  let bbox = div.node().getBoundingClientRect();\n  if (bbox.width === width) {\n    div.style(\"display\", \"table\");\n    div.style(\"white-space\", \"break-spaces\");\n    div.style(\"width\", width + \"px\");\n    bbox = div.node().getBoundingClientRect();\n  }\n  return fo.node();\n}\n__name(addHtmlSpan, \"addHtmlSpan\");\nfunction createTspan(textElement, lineIndex, lineHeight) {\n  return textElement.append(\"tspan\").attr(\"class\", \"text-outer-tspan\").attr(\"x\", 0).attr(\"y\", lineIndex * lineHeight - 0.1 + \"em\").attr(\"dy\", lineHeight + \"em\");\n}\n__name(createTspan, \"createTspan\");\nfunction computeWidthOfText(parentNode, lineHeight, line) {\n  const testElement = parentNode.append(\"text\");\n  const testSpan = createTspan(testElement, 1, lineHeight);\n  updateTextContentAndStyles(testSpan, line);\n  const textLength = testSpan.node().getComputedTextLength();\n  testElement.remove();\n  return textLength;\n}\n__name(computeWidthOfText, \"computeWidthOfText\");\nfunction computeDimensionOfText(parentNode, lineHeight, text) {\n  var _testSpan$node;\n  const testElement = parentNode.append(\"text\");\n  const testSpan = createTspan(testElement, 1, lineHeight);\n  updateTextContentAndStyles(testSpan, [{\n    content: text,\n    type: \"normal\"\n  }]);\n  const textDimension = (_testSpan$node = testSpan.node()) === null || _testSpan$node === void 0 ? void 0 : _testSpan$node.getBoundingClientRect();\n  if (textDimension) {\n    testElement.remove();\n  }\n  return textDimension;\n}\n__name(computeDimensionOfText, \"computeDimensionOfText\");\nfunction createFormattedText(width, g, structuredText) {\n  let addBackground = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const lineHeight = 1.1;\n  const labelGroup = g.append(\"g\");\n  const bkg = labelGroup.insert(\"rect\").attr(\"class\", \"background\").attr(\"style\", \"stroke: none\");\n  const textElement = labelGroup.append(\"text\").attr(\"y\", \"-10.1\");\n  let lineIndex = 0;\n  for (const line of structuredText) {\n    const checkWidth = /* @__PURE__ */__name(line2 => computeWidthOfText(labelGroup, lineHeight, line2) <= width, \"checkWidth\");\n    const linesUnderWidth = checkWidth(line) ? [line] : splitLineToFitWidth(line, checkWidth);\n    for (const preparedLine of linesUnderWidth) {\n      const tspan = createTspan(textElement, lineIndex, lineHeight);\n      updateTextContentAndStyles(tspan, preparedLine);\n      lineIndex++;\n    }\n  }\n  if (addBackground) {\n    const bbox = textElement.node().getBBox();\n    const padding = 2;\n    bkg.attr(\"x\", bbox.x - padding).attr(\"y\", bbox.y - padding).attr(\"width\", bbox.width + 2 * padding).attr(\"height\", bbox.height + 2 * padding);\n    return labelGroup.node();\n  } else {\n    return textElement.node();\n  }\n}\n__name(createFormattedText, \"createFormattedText\");\nfunction updateTextContentAndStyles(tspan, wrappedLine) {\n  tspan.text(\"\");\n  wrappedLine.forEach((word, index) => {\n    const innerTspan = tspan.append(\"tspan\").attr(\"font-style\", word.type === \"em\" ? \"italic\" : \"normal\").attr(\"class\", \"text-inner-tspan\").attr(\"font-weight\", word.type === \"strong\" ? \"bold\" : \"normal\");\n    if (index === 0) {\n      innerTspan.text(word.content);\n    } else {\n      innerTspan.text(\" \" + word.content);\n    }\n  });\n}\n__name(updateTextContentAndStyles, \"updateTextContentAndStyles\");\nasync function replaceIconSubstring(text) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const pendingReplacements = [];\n  text.replace(/(fa[bklrs]?):fa-([\\w-]+)/g, (fullMatch, prefix, iconName) => {\n    pendingReplacements.push((async () => {\n      const registeredIconName = \"\".concat(prefix, \":\").concat(iconName);\n      if (await isIconAvailable(registeredIconName)) {\n        return await getIconSVG(registeredIconName, void 0, {\n          class: \"label-icon\"\n        });\n      } else {\n        return \"<i class='\".concat(sanitizeText(fullMatch, config).replace(\":\", \" \"), \"'></i>\");\n      }\n    })());\n    return fullMatch;\n  });\n  const replacements = await Promise.all(pendingReplacements);\n  return text.replace(/(fa[bklrs]?):fa-([\\w-]+)/g, () => {\n    var _replacements$shift;\n    return (_replacements$shift = replacements.shift()) !== null && _replacements$shift !== void 0 ? _replacements$shift : \"\";\n  });\n}\n__name(replaceIconSubstring, \"replaceIconSubstring\");\nvar createText = /* @__PURE__ */__name(async function (el) {\n  let text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  let {\n    style = \"\",\n    isTitle = false,\n    classes = \"\",\n    useHtmlLabels = true,\n    isNode = true,\n    width = 200,\n    addSvgBackground = false\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let config = arguments.length > 3 ? arguments[3] : undefined;\n  log.debug(\"XYZ createText\", text, style, isTitle, classes, useHtmlLabels, isNode, \"addSvgBackground: \", addSvgBackground);\n  if (useHtmlLabels) {\n    const htmlText = markdownToHTML(text, config);\n    const decodedReplacedText = await replaceIconSubstring(decodeEntities(htmlText), config);\n    const inputForKatex = text.replace(/\\\\\\\\/g, \"\\\\\");\n    const node = {\n      isNode,\n      label: hasKatex(text) ? inputForKatex : decodedReplacedText,\n      labelStyle: style.replace(\"fill:\", \"color:\")\n    };\n    const vertexNode = await addHtmlSpan(el, node, width, classes, addSvgBackground, config);\n    return vertexNode;\n  } else {\n    const sanitizeBR = text.replace(/<br\\s*\\/?>/g, \"<br/>\");\n    const structuredText = markdownToLines(sanitizeBR.replace(\"<br>\", \"<br/>\"), config);\n    const svgLabel = createFormattedText(width, el, structuredText, text ? addSvgBackground : false);\n    if (isNode) {\n      if (/stroke:/.exec(style)) {\n        style = style.replace(\"stroke:\", \"lineColor:\");\n      }\n      const nodeLabelTextStyle = style.replace(/stroke:[^;]+;?/g, \"\").replace(/stroke-width:[^;]+;?/g, \"\").replace(/fill:[^;]+;?/g, \"\").replace(/color:/g, \"fill:\");\n      select(svgLabel).attr(\"style\", nodeLabelTextStyle);\n    } else {\n      const edgeLabelRectStyle = style.replace(/stroke:[^;]+;?/g, \"\").replace(/stroke-width:[^;]+;?/g, \"\").replace(/fill:[^;]+;?/g, \"\").replace(/background:/g, \"fill:\");\n      select(svgLabel).select(\"rect\").attr(\"style\", edgeLabelRectStyle.replace(/background:/g, \"fill:\"));\n      const edgeLabelTextStyle = style.replace(/stroke:[^;]+;?/g, \"\").replace(/stroke-width:[^;]+;?/g, \"\").replace(/fill:[^;]+;?/g, \"\").replace(/color:/g, \"fill:\");\n      select(svgLabel).select(\"text\").attr(\"style\", edgeLabelTextStyle);\n    }\n    return svgLabel;\n  }\n}, \"createText\");\nexport { unknownIcon, registerIconPacks, getIconSVG, computeDimensionOfText, replaceIconSubstring, createText };","map":{"version":3,"names":["decodeEntities","common_default","getConfig","hasKatex","renderKatexSanitized","sanitizeText","__name","log","getIconData","iconToHTML","iconToSVG","replaceIDs","stringToIcon","unknownIcon","body","height","width","iconsStore","Map","loaderStore","registerIconPacks","iconLoaders","iconLoader","name","Error","debug","set","loader","icons","error","getRegisteredIconData","iconName","fallbackPrefix","data","concat","prefix","get","loaded","_objectSpread","e","iconData","isIconAvailable","_unused","getIconSVG","customisations","extraAttributes","renderData","svg","attributes","select","marked","dedent","preprocessMarkdown","markdown","_ref","markdownAutoWrap","withoutBR","replace","withoutMultipleNewlines","withoutExtraSpaces","markdownToLines","config","arguments","length","undefined","preprocessedMarkdown","nodes","lexer","lines","currentLine","processNode","node","parentType","type","textLines","text","split","forEach","textLine","index","push","word","content","tokens","contentNode","treeNode","_treeNode$tokens","raw","markdownToHTML","output","_node$tokens","map","join","_node$tokens2","_node$tokens3","warn","splitTextToChars","Intl","Segmenter","segment","s","splitWordToFitWidth","checkFit","characters","splitWordToFitWidthRecursion","usedChars","remainingChars","nextChar","rest","newWord","shift","splitLineToFitWidth","line","some","_ref2","includes","splitLineToFitWidthRecursion","words","_words$shift","newLine","joiner","nextWord","lineWithNextWord","unshift","applyStyle","dom","styleFn","attr","addHtmlSpan","element","classes","addBackground","fo","append","div","sanitizedLabel","label","lineBreakRegex","labelClass","isNode","span","html","labelStyle","style","bbox","getBoundingClientRect","createTspan","textElement","lineIndex","lineHeight","computeWidthOfText","parentNode","testElement","testSpan","updateTextContentAndStyles","textLength","getComputedTextLength","remove","computeDimensionOfText","_testSpan$node","textDimension","createFormattedText","g","structuredText","labelGroup","bkg","insert","checkWidth","line2","linesUnderWidth","preparedLine","tspan","getBBox","padding","x","y","wrappedLine","innerTspan","replaceIconSubstring","pendingReplacements","fullMatch","registeredIconName","class","replacements","Promise","all","_replacements$shift","createText","el","isTitle","useHtmlLabels","addSvgBackground","htmlText","decodedReplacedText","inputForKatex","vertexNode","sanitizeBR","svgLabel","exec","nodeLabelTextStyle","edgeLabelRectStyle","edgeLabelTextStyle"],"sources":["/home/saiadmin/k3s-cluster/dashboard/frontend/node_modules/mermaid/dist/chunks/mermaid.core/chunk-JA3XYJ7Z.mjs"],"sourcesContent":["import {\n  decodeEntities\n} from \"./chunk-S3R3BYOJ.mjs\";\nimport {\n  common_default,\n  getConfig,\n  hasKatex,\n  renderKatexSanitized,\n  sanitizeText\n} from \"./chunk-ABZYJK2D.mjs\";\nimport {\n  __name,\n  log\n} from \"./chunk-AGHRB4JF.mjs\";\n\n// src/rendering-util/icons.ts\nimport { getIconData, iconToHTML, iconToSVG, replaceIDs, stringToIcon } from \"@iconify/utils\";\nvar unknownIcon = {\n  body: '<g><rect width=\"80\" height=\"80\" style=\"fill: #087ebf; stroke-width: 0px;\"/><text transform=\"translate(21.16 64.67)\" style=\"fill: #fff; font-family: ArialMT, Arial; font-size: 67.75px;\"><tspan x=\"0\" y=\"0\">?</tspan></text></g>',\n  height: 80,\n  width: 80\n};\nvar iconsStore = /* @__PURE__ */ new Map();\nvar loaderStore = /* @__PURE__ */ new Map();\nvar registerIconPacks = /* @__PURE__ */ __name((iconLoaders) => {\n  for (const iconLoader of iconLoaders) {\n    if (!iconLoader.name) {\n      throw new Error(\n        'Invalid icon loader. Must have a \"name\" property with non-empty string value.'\n      );\n    }\n    log.debug(\"Registering icon pack:\", iconLoader.name);\n    if (\"loader\" in iconLoader) {\n      loaderStore.set(iconLoader.name, iconLoader.loader);\n    } else if (\"icons\" in iconLoader) {\n      iconsStore.set(iconLoader.name, iconLoader.icons);\n    } else {\n      log.error(\"Invalid icon loader:\", iconLoader);\n      throw new Error('Invalid icon loader. Must have either \"icons\" or \"loader\" property.');\n    }\n  }\n}, \"registerIconPacks\");\nvar getRegisteredIconData = /* @__PURE__ */ __name(async (iconName, fallbackPrefix) => {\n  const data = stringToIcon(iconName, true, fallbackPrefix !== void 0);\n  if (!data) {\n    throw new Error(`Invalid icon name: ${iconName}`);\n  }\n  const prefix = data.prefix || fallbackPrefix;\n  if (!prefix) {\n    throw new Error(`Icon name must contain a prefix: ${iconName}`);\n  }\n  let icons = iconsStore.get(prefix);\n  if (!icons) {\n    const loader = loaderStore.get(prefix);\n    if (!loader) {\n      throw new Error(`Icon set not found: ${data.prefix}`);\n    }\n    try {\n      const loaded = await loader();\n      icons = { ...loaded, prefix };\n      iconsStore.set(prefix, icons);\n    } catch (e) {\n      log.error(e);\n      throw new Error(`Failed to load icon set: ${data.prefix}`);\n    }\n  }\n  const iconData = getIconData(icons, data.name);\n  if (!iconData) {\n    throw new Error(`Icon not found: ${iconName}`);\n  }\n  return iconData;\n}, \"getRegisteredIconData\");\nvar isIconAvailable = /* @__PURE__ */ __name(async (iconName) => {\n  try {\n    await getRegisteredIconData(iconName);\n    return true;\n  } catch {\n    return false;\n  }\n}, \"isIconAvailable\");\nvar getIconSVG = /* @__PURE__ */ __name(async (iconName, customisations, extraAttributes) => {\n  let iconData;\n  try {\n    iconData = await getRegisteredIconData(iconName, customisations?.fallbackPrefix);\n  } catch (e) {\n    log.error(e);\n    iconData = unknownIcon;\n  }\n  const renderData = iconToSVG(iconData, customisations);\n  const svg = iconToHTML(replaceIDs(renderData.body), {\n    ...renderData.attributes,\n    ...extraAttributes\n  });\n  return sanitizeText(svg, getConfig());\n}, \"getIconSVG\");\n\n// src/rendering-util/createText.ts\nimport { select } from \"d3\";\n\n// src/rendering-util/handle-markdown-text.ts\nimport { marked } from \"marked\";\nimport { dedent } from \"ts-dedent\";\nfunction preprocessMarkdown(markdown, { markdownAutoWrap }) {\n  const withoutBR = markdown.replace(/<br\\/>/g, \"\\n\");\n  const withoutMultipleNewlines = withoutBR.replace(/\\n{2,}/g, \"\\n\");\n  const withoutExtraSpaces = dedent(withoutMultipleNewlines);\n  if (markdownAutoWrap === false) {\n    return withoutExtraSpaces.replace(/ /g, \"&nbsp;\");\n  }\n  return withoutExtraSpaces;\n}\n__name(preprocessMarkdown, \"preprocessMarkdown\");\nfunction markdownToLines(markdown, config = {}) {\n  const preprocessedMarkdown = preprocessMarkdown(markdown, config);\n  const nodes = marked.lexer(preprocessedMarkdown);\n  const lines = [[]];\n  let currentLine = 0;\n  function processNode(node, parentType = \"normal\") {\n    if (node.type === \"text\") {\n      const textLines = node.text.split(\"\\n\");\n      textLines.forEach((textLine, index) => {\n        if (index !== 0) {\n          currentLine++;\n          lines.push([]);\n        }\n        textLine.split(\" \").forEach((word) => {\n          word = word.replace(/&#39;/g, `'`);\n          if (word) {\n            lines[currentLine].push({ content: word, type: parentType });\n          }\n        });\n      });\n    } else if (node.type === \"strong\" || node.type === \"em\") {\n      node.tokens.forEach((contentNode) => {\n        processNode(contentNode, node.type);\n      });\n    } else if (node.type === \"html\") {\n      lines[currentLine].push({ content: node.text, type: \"normal\" });\n    }\n  }\n  __name(processNode, \"processNode\");\n  nodes.forEach((treeNode) => {\n    if (treeNode.type === \"paragraph\") {\n      treeNode.tokens?.forEach((contentNode) => {\n        processNode(contentNode);\n      });\n    } else if (treeNode.type === \"html\") {\n      lines[currentLine].push({ content: treeNode.text, type: \"normal\" });\n    } else {\n      lines[currentLine].push({ content: treeNode.raw, type: \"normal\" });\n    }\n  });\n  return lines;\n}\n__name(markdownToLines, \"markdownToLines\");\nfunction markdownToHTML(markdown, { markdownAutoWrap } = {}) {\n  const nodes = marked.lexer(markdown);\n  function output(node) {\n    if (node.type === \"text\") {\n      if (markdownAutoWrap === false) {\n        return node.text.replace(/\\n */g, \"<br/>\").replace(/ /g, \"&nbsp;\");\n      }\n      return node.text.replace(/\\n */g, \"<br/>\");\n    } else if (node.type === \"strong\") {\n      return `<strong>${node.tokens?.map(output).join(\"\")}</strong>`;\n    } else if (node.type === \"em\") {\n      return `<em>${node.tokens?.map(output).join(\"\")}</em>`;\n    } else if (node.type === \"paragraph\") {\n      return `<p>${node.tokens?.map(output).join(\"\")}</p>`;\n    } else if (node.type === \"space\") {\n      return \"\";\n    } else if (node.type === \"html\") {\n      return `${node.text}`;\n    } else if (node.type === \"escape\") {\n      return node.text;\n    }\n    log.warn(`Unsupported markdown: ${node.type}`);\n    return node.raw;\n  }\n  __name(output, \"output\");\n  return nodes.map(output).join(\"\");\n}\n__name(markdownToHTML, \"markdownToHTML\");\n\n// src/rendering-util/splitText.ts\nfunction splitTextToChars(text) {\n  if (Intl.Segmenter) {\n    return [...new Intl.Segmenter().segment(text)].map((s) => s.segment);\n  }\n  return [...text];\n}\n__name(splitTextToChars, \"splitTextToChars\");\nfunction splitWordToFitWidth(checkFit, word) {\n  const characters = splitTextToChars(word.content);\n  return splitWordToFitWidthRecursion(checkFit, [], characters, word.type);\n}\n__name(splitWordToFitWidth, \"splitWordToFitWidth\");\nfunction splitWordToFitWidthRecursion(checkFit, usedChars, remainingChars, type) {\n  if (remainingChars.length === 0) {\n    return [\n      { content: usedChars.join(\"\"), type },\n      { content: \"\", type }\n    ];\n  }\n  const [nextChar, ...rest] = remainingChars;\n  const newWord = [...usedChars, nextChar];\n  if (checkFit([{ content: newWord.join(\"\"), type }])) {\n    return splitWordToFitWidthRecursion(checkFit, newWord, rest, type);\n  }\n  if (usedChars.length === 0 && nextChar) {\n    usedChars.push(nextChar);\n    remainingChars.shift();\n  }\n  return [\n    { content: usedChars.join(\"\"), type },\n    { content: remainingChars.join(\"\"), type }\n  ];\n}\n__name(splitWordToFitWidthRecursion, \"splitWordToFitWidthRecursion\");\nfunction splitLineToFitWidth(line, checkFit) {\n  if (line.some(({ content }) => content.includes(\"\\n\"))) {\n    throw new Error(\"splitLineToFitWidth does not support newlines in the line\");\n  }\n  return splitLineToFitWidthRecursion(line, checkFit);\n}\n__name(splitLineToFitWidth, \"splitLineToFitWidth\");\nfunction splitLineToFitWidthRecursion(words, checkFit, lines = [], newLine = []) {\n  if (words.length === 0) {\n    if (newLine.length > 0) {\n      lines.push(newLine);\n    }\n    return lines.length > 0 ? lines : [];\n  }\n  let joiner = \"\";\n  if (words[0].content === \" \") {\n    joiner = \" \";\n    words.shift();\n  }\n  const nextWord = words.shift() ?? { content: \" \", type: \"normal\" };\n  const lineWithNextWord = [...newLine];\n  if (joiner !== \"\") {\n    lineWithNextWord.push({ content: joiner, type: \"normal\" });\n  }\n  lineWithNextWord.push(nextWord);\n  if (checkFit(lineWithNextWord)) {\n    return splitLineToFitWidthRecursion(words, checkFit, lines, lineWithNextWord);\n  }\n  if (newLine.length > 0) {\n    lines.push(newLine);\n    words.unshift(nextWord);\n  } else if (nextWord.content) {\n    const [line, rest] = splitWordToFitWidth(checkFit, nextWord);\n    lines.push([line]);\n    if (rest.content) {\n      words.unshift(rest);\n    }\n  }\n  return splitLineToFitWidthRecursion(words, checkFit, lines);\n}\n__name(splitLineToFitWidthRecursion, \"splitLineToFitWidthRecursion\");\n\n// src/rendering-util/createText.ts\nfunction applyStyle(dom, styleFn) {\n  if (styleFn) {\n    dom.attr(\"style\", styleFn);\n  }\n}\n__name(applyStyle, \"applyStyle\");\nasync function addHtmlSpan(element, node, width, classes, addBackground = false, config = getConfig()) {\n  const fo = element.append(\"foreignObject\");\n  fo.attr(\"width\", `${10 * width}px`);\n  fo.attr(\"height\", `${10 * width}px`);\n  const div = fo.append(\"xhtml:div\");\n  const sanitizedLabel = hasKatex(node.label) ? await renderKatexSanitized(node.label.replace(common_default.lineBreakRegex, \"\\n\"), config) : sanitizeText(node.label, config);\n  const labelClass = node.isNode ? \"nodeLabel\" : \"edgeLabel\";\n  const span = div.append(\"span\");\n  span.html(sanitizedLabel);\n  applyStyle(span, node.labelStyle);\n  span.attr(\"class\", `${labelClass} ${classes}`);\n  applyStyle(div, node.labelStyle);\n  div.style(\"display\", \"table-cell\");\n  div.style(\"white-space\", \"nowrap\");\n  div.style(\"line-height\", \"1.5\");\n  div.style(\"max-width\", width + \"px\");\n  div.style(\"text-align\", \"center\");\n  div.attr(\"xmlns\", \"http://www.w3.org/1999/xhtml\");\n  if (addBackground) {\n    div.attr(\"class\", \"labelBkg\");\n  }\n  let bbox = div.node().getBoundingClientRect();\n  if (bbox.width === width) {\n    div.style(\"display\", \"table\");\n    div.style(\"white-space\", \"break-spaces\");\n    div.style(\"width\", width + \"px\");\n    bbox = div.node().getBoundingClientRect();\n  }\n  return fo.node();\n}\n__name(addHtmlSpan, \"addHtmlSpan\");\nfunction createTspan(textElement, lineIndex, lineHeight) {\n  return textElement.append(\"tspan\").attr(\"class\", \"text-outer-tspan\").attr(\"x\", 0).attr(\"y\", lineIndex * lineHeight - 0.1 + \"em\").attr(\"dy\", lineHeight + \"em\");\n}\n__name(createTspan, \"createTspan\");\nfunction computeWidthOfText(parentNode, lineHeight, line) {\n  const testElement = parentNode.append(\"text\");\n  const testSpan = createTspan(testElement, 1, lineHeight);\n  updateTextContentAndStyles(testSpan, line);\n  const textLength = testSpan.node().getComputedTextLength();\n  testElement.remove();\n  return textLength;\n}\n__name(computeWidthOfText, \"computeWidthOfText\");\nfunction computeDimensionOfText(parentNode, lineHeight, text) {\n  const testElement = parentNode.append(\"text\");\n  const testSpan = createTspan(testElement, 1, lineHeight);\n  updateTextContentAndStyles(testSpan, [{ content: text, type: \"normal\" }]);\n  const textDimension = testSpan.node()?.getBoundingClientRect();\n  if (textDimension) {\n    testElement.remove();\n  }\n  return textDimension;\n}\n__name(computeDimensionOfText, \"computeDimensionOfText\");\nfunction createFormattedText(width, g, structuredText, addBackground = false) {\n  const lineHeight = 1.1;\n  const labelGroup = g.append(\"g\");\n  const bkg = labelGroup.insert(\"rect\").attr(\"class\", \"background\").attr(\"style\", \"stroke: none\");\n  const textElement = labelGroup.append(\"text\").attr(\"y\", \"-10.1\");\n  let lineIndex = 0;\n  for (const line of structuredText) {\n    const checkWidth = /* @__PURE__ */ __name((line2) => computeWidthOfText(labelGroup, lineHeight, line2) <= width, \"checkWidth\");\n    const linesUnderWidth = checkWidth(line) ? [line] : splitLineToFitWidth(line, checkWidth);\n    for (const preparedLine of linesUnderWidth) {\n      const tspan = createTspan(textElement, lineIndex, lineHeight);\n      updateTextContentAndStyles(tspan, preparedLine);\n      lineIndex++;\n    }\n  }\n  if (addBackground) {\n    const bbox = textElement.node().getBBox();\n    const padding = 2;\n    bkg.attr(\"x\", bbox.x - padding).attr(\"y\", bbox.y - padding).attr(\"width\", bbox.width + 2 * padding).attr(\"height\", bbox.height + 2 * padding);\n    return labelGroup.node();\n  } else {\n    return textElement.node();\n  }\n}\n__name(createFormattedText, \"createFormattedText\");\nfunction updateTextContentAndStyles(tspan, wrappedLine) {\n  tspan.text(\"\");\n  wrappedLine.forEach((word, index) => {\n    const innerTspan = tspan.append(\"tspan\").attr(\"font-style\", word.type === \"em\" ? \"italic\" : \"normal\").attr(\"class\", \"text-inner-tspan\").attr(\"font-weight\", word.type === \"strong\" ? \"bold\" : \"normal\");\n    if (index === 0) {\n      innerTspan.text(word.content);\n    } else {\n      innerTspan.text(\" \" + word.content);\n    }\n  });\n}\n__name(updateTextContentAndStyles, \"updateTextContentAndStyles\");\nasync function replaceIconSubstring(text, config = {}) {\n  const pendingReplacements = [];\n  text.replace(/(fa[bklrs]?):fa-([\\w-]+)/g, (fullMatch, prefix, iconName) => {\n    pendingReplacements.push(\n      (async () => {\n        const registeredIconName = `${prefix}:${iconName}`;\n        if (await isIconAvailable(registeredIconName)) {\n          return await getIconSVG(registeredIconName, void 0, { class: \"label-icon\" });\n        } else {\n          return `<i class='${sanitizeText(fullMatch, config).replace(\":\", \" \")}'></i>`;\n        }\n      })()\n    );\n    return fullMatch;\n  });\n  const replacements = await Promise.all(pendingReplacements);\n  return text.replace(/(fa[bklrs]?):fa-([\\w-]+)/g, () => replacements.shift() ?? \"\");\n}\n__name(replaceIconSubstring, \"replaceIconSubstring\");\nvar createText = /* @__PURE__ */ __name(async (el, text = \"\", {\n  style = \"\",\n  isTitle = false,\n  classes = \"\",\n  useHtmlLabels = true,\n  isNode = true,\n  width = 200,\n  addSvgBackground = false\n} = {}, config) => {\n  log.debug(\n    \"XYZ createText\",\n    text,\n    style,\n    isTitle,\n    classes,\n    useHtmlLabels,\n    isNode,\n    \"addSvgBackground: \",\n    addSvgBackground\n  );\n  if (useHtmlLabels) {\n    const htmlText = markdownToHTML(text, config);\n    const decodedReplacedText = await replaceIconSubstring(decodeEntities(htmlText), config);\n    const inputForKatex = text.replace(/\\\\\\\\/g, \"\\\\\");\n    const node = {\n      isNode,\n      label: hasKatex(text) ? inputForKatex : decodedReplacedText,\n      labelStyle: style.replace(\"fill:\", \"color:\")\n    };\n    const vertexNode = await addHtmlSpan(el, node, width, classes, addSvgBackground, config);\n    return vertexNode;\n  } else {\n    const sanitizeBR = text.replace(/<br\\s*\\/?>/g, \"<br/>\");\n    const structuredText = markdownToLines(sanitizeBR.replace(\"<br>\", \"<br/>\"), config);\n    const svgLabel = createFormattedText(\n      width,\n      el,\n      structuredText,\n      text ? addSvgBackground : false\n    );\n    if (isNode) {\n      if (/stroke:/.exec(style)) {\n        style = style.replace(\"stroke:\", \"lineColor:\");\n      }\n      const nodeLabelTextStyle = style.replace(/stroke:[^;]+;?/g, \"\").replace(/stroke-width:[^;]+;?/g, \"\").replace(/fill:[^;]+;?/g, \"\").replace(/color:/g, \"fill:\");\n      select(svgLabel).attr(\"style\", nodeLabelTextStyle);\n    } else {\n      const edgeLabelRectStyle = style.replace(/stroke:[^;]+;?/g, \"\").replace(/stroke-width:[^;]+;?/g, \"\").replace(/fill:[^;]+;?/g, \"\").replace(/background:/g, \"fill:\");\n      select(svgLabel).select(\"rect\").attr(\"style\", edgeLabelRectStyle.replace(/background:/g, \"fill:\"));\n      const edgeLabelTextStyle = style.replace(/stroke:[^;]+;?/g, \"\").replace(/stroke-width:[^;]+;?/g, \"\").replace(/fill:[^;]+;?/g, \"\").replace(/color:/g, \"fill:\");\n      select(svgLabel).select(\"text\").attr(\"style\", edgeLabelTextStyle);\n    }\n    return svgLabel;\n  }\n}, \"createText\");\n\nexport {\n  unknownIcon,\n  registerIconPacks,\n  getIconSVG,\n  computeDimensionOfText,\n  replaceIconSubstring,\n  createText\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}