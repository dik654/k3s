{"ast":null,"code":"import { joinerEmoji } from \"../data.js\";\nimport { convertEmojiSequenceToUTF32 } from \"../convert.js\";\nimport { splitEmojiSequences } from \"../cleanup.js\";\nimport { createOptionalEmojiRegexItem, createSequenceEmojiRegexItem, createSetEmojiRegexItem, createUTF16EmojiRegexItem } from \"./base.js\";\nimport { createRegexForNumbersSequence } from \"./numbers.js\";\nimport { mergeSimilarItemsInSet } from \"./similar.js\";\n\n/**\n* Create tree\n*/\nfunction createEmojisTree(sequences) {\n  const root = [];\n  for (let i = 0; i < sequences.length; i++) {\n    const split = splitEmojiSequences(convertEmojiSequenceToUTF32(sequences[i]));\n    let parent = root;\n    for (let j = 0; j < split.length; j++) {\n      const regex = createRegexForNumbersSequence(split[j]);\n      let item;\n      const match = parent.find(item$1 => item$1.regex.regex === regex.regex);\n      if (!match) {\n        item = {\n          regex\n        };\n        parent.push(item);\n      } else item = match;\n      if (j === split.length - 1) {\n        item.end = true;\n        break;\n      }\n      parent = item.children || (item.children = []);\n    }\n  }\n  return root;\n}\n/**\n* Parse tree\n*/\nfunction parseEmojiTree(items) {\n  function mergeParsedChildren(items$1) {\n    const parsedItems = [];\n    const mapWithoutEnd = Object.create(null);\n    const mapWithEnd = Object.create(null);\n    for (let i = 0; i < items$1.length; i++) {\n      const item = items$1[i];\n      const children = item.children;\n      if (children) {\n        const fullItem = item;\n        const target = item.end ? mapWithEnd : mapWithoutEnd;\n        const regex = children.regex;\n        if (!target[regex]) target[regex] = [fullItem];else target[regex].push(fullItem);\n      } else parsedItems.push(item.regex);\n    }\n    [mapWithEnd, mapWithoutEnd].forEach(source => {\n      for (const regex in source) {\n        const items$2 = source[regex];\n        const firstItem = items$2[0];\n        let childSequence = [createUTF16EmojiRegexItem([joinerEmoji]), firstItem.children];\n        if (firstItem.end) childSequence = [createOptionalEmojiRegexItem(createSequenceEmojiRegexItem(childSequence))];\n        let mergedRegex;\n        if (items$2.length === 1) mergedRegex = firstItem.regex;else mergedRegex = mergeSimilarItemsInSet(createSetEmojiRegexItem(items$2.map(item => item.regex)));\n        const sequence = createSequenceEmojiRegexItem([mergedRegex, ...childSequence]);\n        parsedItems.push(sequence);\n      }\n    });\n    if (parsedItems.length === 1) return parsedItems[0];\n    return mergeSimilarItemsInSet(createSetEmojiRegexItem(parsedItems));\n  }\n  function parseItemChildren(item) {\n    const result = {\n      regex: item.regex,\n      end: !!item.end\n    };\n    const children = item.children;\n    if (!children) return result;\n    result.children = mergeParsedChildren(children.map(parseItemChildren));\n    return result;\n  }\n  return mergeParsedChildren(items.map(parseItemChildren));\n}\nexport { createEmojisTree, parseEmojiTree };","map":{"version":3,"names":["joinerEmoji","convertEmojiSequenceToUTF32","splitEmojiSequences","createOptionalEmojiRegexItem","createSequenceEmojiRegexItem","createSetEmojiRegexItem","createUTF16EmojiRegexItem","createRegexForNumbersSequence","mergeSimilarItemsInSet","createEmojisTree","sequences","root","i","length","split","parent","j","regex","item","match","find","item$1","push","end","children","parseEmojiTree","items","mergeParsedChildren","items$1","parsedItems","mapWithoutEnd","Object","create","mapWithEnd","fullItem","target","forEach","source","items$2","firstItem","childSequence","mergedRegex","map","sequence","parseItemChildren","result"],"sources":["/home/saiadmin/k3s-cluster/dashboard/frontend/node_modules/@iconify/utils/lib/emoji/regex/tree.js"],"sourcesContent":["import { joinerEmoji } from \"../data.js\";\nimport { convertEmojiSequenceToUTF32 } from \"../convert.js\";\nimport { splitEmojiSequences } from \"../cleanup.js\";\nimport { createOptionalEmojiRegexItem, createSequenceEmojiRegexItem, createSetEmojiRegexItem, createUTF16EmojiRegexItem } from \"./base.js\";\nimport { createRegexForNumbersSequence } from \"./numbers.js\";\nimport { mergeSimilarItemsInSet } from \"./similar.js\";\n\n/**\n* Create tree\n*/\nfunction createEmojisTree(sequences) {\n\tconst root = [];\n\tfor (let i = 0; i < sequences.length; i++) {\n\t\tconst split = splitEmojiSequences(convertEmojiSequenceToUTF32(sequences[i]));\n\t\tlet parent = root;\n\t\tfor (let j = 0; j < split.length; j++) {\n\t\t\tconst regex = createRegexForNumbersSequence(split[j]);\n\t\t\tlet item;\n\t\t\tconst match = parent.find((item$1) => item$1.regex.regex === regex.regex);\n\t\t\tif (!match) {\n\t\t\t\titem = { regex };\n\t\t\t\tparent.push(item);\n\t\t\t} else item = match;\n\t\t\tif (j === split.length - 1) {\n\t\t\t\titem.end = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tparent = item.children || (item.children = []);\n\t\t}\n\t}\n\treturn root;\n}\n/**\n* Parse tree\n*/\nfunction parseEmojiTree(items) {\n\tfunction mergeParsedChildren(items$1) {\n\t\tconst parsedItems = [];\n\t\tconst mapWithoutEnd = Object.create(null);\n\t\tconst mapWithEnd = Object.create(null);\n\t\tfor (let i = 0; i < items$1.length; i++) {\n\t\t\tconst item = items$1[i];\n\t\t\tconst children = item.children;\n\t\t\tif (children) {\n\t\t\t\tconst fullItem = item;\n\t\t\t\tconst target = item.end ? mapWithEnd : mapWithoutEnd;\n\t\t\t\tconst regex = children.regex;\n\t\t\t\tif (!target[regex]) target[regex] = [fullItem];\n\t\t\t\telse target[regex].push(fullItem);\n\t\t\t} else parsedItems.push(item.regex);\n\t\t}\n\t\t[mapWithEnd, mapWithoutEnd].forEach((source) => {\n\t\t\tfor (const regex in source) {\n\t\t\t\tconst items$2 = source[regex];\n\t\t\t\tconst firstItem = items$2[0];\n\t\t\t\tlet childSequence = [createUTF16EmojiRegexItem([joinerEmoji]), firstItem.children];\n\t\t\t\tif (firstItem.end) childSequence = [createOptionalEmojiRegexItem(createSequenceEmojiRegexItem(childSequence))];\n\t\t\t\tlet mergedRegex;\n\t\t\t\tif (items$2.length === 1) mergedRegex = firstItem.regex;\n\t\t\t\telse mergedRegex = mergeSimilarItemsInSet(createSetEmojiRegexItem(items$2.map((item) => item.regex)));\n\t\t\t\tconst sequence = createSequenceEmojiRegexItem([mergedRegex, ...childSequence]);\n\t\t\t\tparsedItems.push(sequence);\n\t\t\t}\n\t\t});\n\t\tif (parsedItems.length === 1) return parsedItems[0];\n\t\treturn mergeSimilarItemsInSet(createSetEmojiRegexItem(parsedItems));\n\t}\n\tfunction parseItemChildren(item) {\n\t\tconst result = {\n\t\t\tregex: item.regex,\n\t\t\tend: !!item.end\n\t\t};\n\t\tconst children = item.children;\n\t\tif (!children) return result;\n\t\tresult.children = mergeParsedChildren(children.map(parseItemChildren));\n\t\treturn result;\n\t}\n\treturn mergeParsedChildren(items.map(parseItemChildren));\n}\n\nexport { createEmojisTree, parseEmojiTree };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}