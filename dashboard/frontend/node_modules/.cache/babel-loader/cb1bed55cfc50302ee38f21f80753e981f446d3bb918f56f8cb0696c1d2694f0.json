{"ast":null,"code":"import { clone, compact, difference, drop, dropRight, filter, first, flatMap, flatten, forEach, groupBy, includes, isEmpty, map, pickBy, reduce, reject, values } from \"lodash-es\";\nimport { ParserDefinitionErrorType } from \"../parser/parser.js\";\nimport { Alternation, Alternative as AlternativeGAST, GAstVisitor, getProductionDslName, isOptionalProd, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal } from \"@chevrotain/gast\";\nimport { containsPath, getLookaheadPathsForOptionalProd, getLookaheadPathsForOr, getProdType, isStrictPrefixOfPath } from \"./lookahead.js\";\nimport { nextPossibleTokensAfter } from \"./interpreter.js\";\nimport { tokenStructuredMatcher } from \"../../scan/tokens.js\";\nexport function validateLookahead(options) {\n  const lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({\n    rules: options.rules,\n    tokenTypes: options.tokenTypes,\n    grammarName: options.grammarName\n  });\n  return map(lookaheadValidationErrorMessages, errorMessage => Object.assign({\n    type: ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION\n  }, errorMessage));\n}\nexport function validateGrammar(topLevels, tokenTypes, errMsgProvider, grammarName) {\n  const duplicateErrors = flatMap(topLevels, currTopLevel => validateDuplicateProductions(currTopLevel, errMsgProvider));\n  const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n  const tooManyAltsErrors = flatMap(topLevels, curRule => validateTooManyAlts(curRule, errMsgProvider));\n  const duplicateRulesError = flatMap(topLevels, curRule => validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider));\n  return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);\n}\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n  const collectorVisitor = new OccurrenceValidationCollector();\n  topLevelRule.accept(collectorVisitor);\n  const allRuleProductions = collectorVisitor.allProductions;\n  const productionGroups = groupBy(allRuleProductions, identifyProductionForDuplicates);\n  const duplicates = pickBy(productionGroups, currGroup => {\n    return currGroup.length > 1;\n  });\n  const errors = map(values(duplicates), currDuplicates => {\n    const firstProd = first(currDuplicates);\n    const msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n    const dslName = getProductionDslName(firstProd);\n    const defError = {\n      message: msg,\n      type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx\n    };\n    const param = getExtraProductionArgument(firstProd);\n    if (param) {\n      defError.parameter = param;\n    }\n    return defError;\n  });\n  return errors;\n}\nexport function identifyProductionForDuplicates(prod) {\n  return \"\".concat(getProductionDslName(prod), \"_#_\").concat(prod.idx, \"_#_\").concat(getExtraProductionArgument(prod));\n}\nfunction getExtraProductionArgument(prod) {\n  if (prod instanceof Terminal) {\n    return prod.terminalType.name;\n  } else if (prod instanceof NonTerminal) {\n    return prod.nonTerminalName;\n  } else {\n    return \"\";\n  }\n}\nexport class OccurrenceValidationCollector extends GAstVisitor {\n  constructor() {\n    super(...arguments);\n    this.allProductions = [];\n  }\n  visitNonTerminal(subrule) {\n    this.allProductions.push(subrule);\n  }\n  visitOption(option) {\n    this.allProductions.push(option);\n  }\n  visitRepetitionWithSeparator(manySep) {\n    this.allProductions.push(manySep);\n  }\n  visitRepetitionMandatory(atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  }\n  visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  }\n  visitRepetition(many) {\n    this.allProductions.push(many);\n  }\n  visitAlternation(or) {\n    this.allProductions.push(or);\n  }\n  visitTerminal(terminal) {\n    this.allProductions.push(terminal);\n  }\n}\nexport function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n  const errors = [];\n  const occurrences = reduce(allRules, (result, curRule) => {\n    if (curRule.name === rule.name) {\n      return result + 1;\n    }\n    return result;\n  }, 0);\n  if (occurrences > 1) {\n    const errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    });\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    });\n  }\n  return errors;\n}\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nexport function validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n  const errors = [];\n  let errMsg;\n  if (!includes(definedRulesNames, ruleName)) {\n    errMsg = \"Invalid rule override, rule: ->\".concat(ruleName, \"<- cannot be overridden in the grammar: ->\").concat(className, \"<-\") + \"as it is not defined in any of the super grammars \";\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName\n    });\n  }\n  return errors;\n}\nexport function validateNoLeftRecursion(topRule, currRule, errMsgProvider) {\n  let path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  const errors = [];\n  const nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n  if (isEmpty(nextNonTerminals)) {\n    return [];\n  } else {\n    const ruleName = topRule.name;\n    const foundLeftRecursion = includes(nextNonTerminals, topRule);\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName\n      });\n    }\n    // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n    const validNextSteps = difference(nextNonTerminals, path.concat([topRule]));\n    const errorsFromNextSteps = flatMap(validNextSteps, currRefRule => {\n      const newPath = clone(path);\n      newPath.push(currRefRule);\n      return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n    });\n    return errors.concat(errorsFromNextSteps);\n  }\n}\nexport function getFirstNoneTerminal(definition) {\n  let result = [];\n  if (isEmpty(definition)) {\n    return result;\n  }\n  const firstProd = first(definition);\n  /* istanbul ignore else */\n  if (firstProd instanceof NonTerminal) {\n    result.push(firstProd.referencedRule);\n  } else if (firstProd instanceof AlternativeGAST || firstProd instanceof Option || firstProd instanceof RepetitionMandatory || firstProd instanceof RepetitionMandatoryWithSeparator || firstProd instanceof RepetitionWithSeparator || firstProd instanceof Repetition) {\n    result = result.concat(getFirstNoneTerminal(firstProd.definition));\n  } else if (firstProd instanceof Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = flatten(map(firstProd.definition, currSubDef => getFirstNoneTerminal(currSubDef.definition)));\n  } else if (firstProd instanceof Terminal) {\n    // nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n  const isFirstOptional = isOptionalProd(firstProd);\n  const hasMore = definition.length > 1;\n  if (isFirstOptional && hasMore) {\n    const rest = drop(definition);\n    return result.concat(getFirstNoneTerminal(rest));\n  } else {\n    return result;\n  }\n}\nclass OrCollector extends GAstVisitor {\n  constructor() {\n    super(...arguments);\n    this.alternations = [];\n  }\n  visitAlternation(node) {\n    this.alternations.push(node);\n  }\n}\nexport function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n  const orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  const ors = orCollector.alternations;\n  const errors = flatMap(ors, currOr => {\n    const exceptLast = dropRight(currOr.definition);\n    return flatMap(exceptLast, (currAlternative, currAltIdx) => {\n      const possibleFirstInAlt = nextPossibleTokensAfter([currAlternative], [], tokenStructuredMatcher, 1);\n      if (isEmpty(possibleFirstInAlt)) {\n        return [{\n          message: errMsgProvider.buildEmptyAlternationError({\n            topLevelRule: topLevelRule,\n            alternation: currOr,\n            emptyChoiceIdx: currAltIdx\n          }),\n          type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx,\n          alternative: currAltIdx + 1\n        }];\n      } else {\n        return [];\n      }\n    });\n  });\n  return errors;\n}\nexport function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n  const orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  let ors = orCollector.alternations;\n  // New Handling of ignoring ambiguities\n  // - https://github.com/chevrotain/chevrotain/issues/869\n  ors = reject(ors, currOr => currOr.ignoreAmbiguities === true);\n  const errors = flatMap(ors, currOr => {\n    const currOccurrence = currOr.idx;\n    const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n    const alternatives = getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n    const altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);\n  });\n  return errors;\n}\nexport class RepetitionCollector extends GAstVisitor {\n  constructor() {\n    super(...arguments);\n    this.allProductions = [];\n  }\n  visitRepetitionWithSeparator(manySep) {\n    this.allProductions.push(manySep);\n  }\n  visitRepetitionMandatory(atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  }\n  visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  }\n  visitRepetition(many) {\n    this.allProductions.push(many);\n  }\n}\nexport function validateTooManyAlts(topLevelRule, errMsgProvider) {\n  const orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  const ors = orCollector.alternations;\n  const errors = flatMap(ors, currOr => {\n    if (currOr.definition.length > 255) {\n      return [{\n        message: errMsgProvider.buildTooManyAlternativesError({\n          topLevelRule: topLevelRule,\n          alternation: currOr\n        }),\n        type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n        ruleName: topLevelRule.name,\n        occurrence: currOr.idx\n      }];\n    } else {\n      return [];\n    }\n  });\n  return errors;\n}\nexport function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n  const errors = [];\n  forEach(topLevelRules, currTopRule => {\n    const collectorVisitor = new RepetitionCollector();\n    currTopRule.accept(collectorVisitor);\n    const allRuleProductions = collectorVisitor.allProductions;\n    forEach(allRuleProductions, currProd => {\n      const prodType = getProdType(currProd);\n      const actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n      const currOccurrence = currProd.idx;\n      const paths = getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n      const pathsInsideProduction = paths[0];\n      if (isEmpty(flatten(pathsInsideProduction))) {\n        const errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        });\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        });\n      }\n    });\n  });\n  return errors;\n}\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  const foundAmbiguousPaths = [];\n  const identicalAmbiguities = reduce(alternatives, (result, currAlt, currAltIdx) => {\n    // ignore (skip) ambiguities with this alternative\n    if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n      return result;\n    }\n    forEach(currAlt, currPath => {\n      const altsCurrPathAppearsIn = [currAltIdx];\n      forEach(alternatives, (currOtherAlt, currOtherAltIdx) => {\n        if (currAltIdx !== currOtherAltIdx && containsPath(currOtherAlt, currPath) &&\n        // ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n          altsCurrPathAppearsIn.push(currOtherAltIdx);\n        }\n      });\n      if (altsCurrPathAppearsIn.length > 1 && !containsPath(foundAmbiguousPaths, currPath)) {\n        foundAmbiguousPaths.push(currPath);\n        result.push({\n          alts: altsCurrPathAppearsIn,\n          path: currPath\n        });\n      }\n    });\n    return result;\n  }, []);\n  const currErrors = map(identicalAmbiguities, currAmbDescriptor => {\n    const ambgIndices = map(currAmbDescriptor.alts, currAltIdx => currAltIdx + 1);\n    const currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    });\n    return {\n      message: currMessage,\n      type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: currAmbDescriptor.alts\n    };\n  });\n  return currErrors;\n}\nexport function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  // flatten\n  const pathsAndIndices = reduce(alternatives, (result, currAlt, idx) => {\n    const currPathsAndIdx = map(currAlt, currPath => {\n      return {\n        idx: idx,\n        path: currPath\n      };\n    });\n    return result.concat(currPathsAndIdx);\n  }, []);\n  const errors = compact(flatMap(pathsAndIndices, currPathAndIdx => {\n    const alternativeGast = alternation.definition[currPathAndIdx.idx];\n    // ignore (skip) ambiguities with this alternative\n    if (alternativeGast.ignoreAmbiguities === true) {\n      return [];\n    }\n    const targetIdx = currPathAndIdx.idx;\n    const targetPath = currPathAndIdx.path;\n    const prefixAmbiguitiesPathsAndIndices = filter(pathsAndIndices, searchPathAndIdx => {\n      // prefix ambiguity can only be created from lower idx (higher priority) path\n      return (\n        // ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx &&\n        // checking for strict prefix because identical lookaheads\n        // will be be detected using a different validation.\n        isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n      );\n    });\n    const currPathPrefixErrors = map(prefixAmbiguitiesPathsAndIndices, currAmbPathAndIdx => {\n      const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n      const occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n      const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n        topLevelRule: rule,\n        alternation: alternation,\n        ambiguityIndices: ambgIndices,\n        prefixPath: currAmbPathAndIdx.path\n      });\n      return {\n        message: message,\n        type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n        ruleName: rule.name,\n        occurrence: occurrence,\n        alternatives: ambgIndices\n      };\n    });\n    return currPathPrefixErrors;\n  }));\n  return errors;\n}\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n  const errors = [];\n  const tokenNames = map(tokenTypes, currToken => currToken.name);\n  forEach(topLevels, currRule => {\n    const currRuleName = currRule.name;\n    if (includes(tokenNames, currRuleName)) {\n      const errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      });\n    }\n  });\n  return errors;\n}","map":{"version":3,"names":["clone","compact","difference","drop","dropRight","filter","first","flatMap","flatten","forEach","groupBy","includes","isEmpty","map","pickBy","reduce","reject","values","ParserDefinitionErrorType","Alternation","Alternative","AlternativeGAST","GAstVisitor","getProductionDslName","isOptionalProd","NonTerminal","Option","Repetition","RepetitionMandatory","RepetitionMandatoryWithSeparator","RepetitionWithSeparator","Terminal","containsPath","getLookaheadPathsForOptionalProd","getLookaheadPathsForOr","getProdType","isStrictPrefixOfPath","nextPossibleTokensAfter","tokenStructuredMatcher","validateLookahead","options","lookaheadValidationErrorMessages","lookaheadStrategy","validate","rules","tokenTypes","grammarName","errorMessage","Object","assign","type","CUSTOM_LOOKAHEAD_VALIDATION","validateGrammar","topLevels","errMsgProvider","duplicateErrors","currTopLevel","validateDuplicateProductions","termsNamespaceConflictErrors","checkTerminalAndNoneTerminalsNameSpace","tooManyAltsErrors","curRule","validateTooManyAlts","duplicateRulesError","validateRuleDoesNotAlreadyExist","concat","topLevelRule","collectorVisitor","OccurrenceValidationCollector","accept","allRuleProductions","allProductions","productionGroups","identifyProductionForDuplicates","duplicates","currGroup","length","errors","currDuplicates","firstProd","msg","buildDuplicateFoundError","dslName","defError","message","DUPLICATE_PRODUCTIONS","ruleName","name","occurrence","idx","param","getExtraProductionArgument","parameter","prod","terminalType","nonTerminalName","constructor","visitNonTerminal","subrule","push","visitOption","option","visitRepetitionWithSeparator","manySep","visitRepetitionMandatory","atLeastOne","visitRepetitionMandatoryWithSeparator","atLeastOneSep","visitRepetition","many","visitAlternation","or","visitTerminal","terminal","rule","allRules","className","occurrences","result","errMsg","buildDuplicateRuleNameError","DUPLICATE_RULE_NAME","validateRuleIsOverridden","definedRulesNames","INVALID_RULE_OVERRIDE","validateNoLeftRecursion","topRule","currRule","path","arguments","undefined","nextNonTerminals","getFirstNoneTerminal","definition","foundLeftRecursion","buildLeftRecursionError","leftRecursionPath","LEFT_RECURSION","validNextSteps","errorsFromNextSteps","currRefRule","newPath","referencedRule","currSubDef","Error","isFirstOptional","hasMore","rest","OrCollector","alternations","node","validateEmptyOrAlternative","orCollector","ors","currOr","exceptLast","currAlternative","currAltIdx","possibleFirstInAlt","buildEmptyAlternationError","alternation","emptyChoiceIdx","NONE_LAST_EMPTY_ALT","alternative","validateAmbiguousAlternationAlternatives","globalMaxLookahead","ignoreAmbiguities","currOccurrence","actualMaxLookahead","maxLookahead","alternatives","altsAmbiguityErrors","checkAlternativesAmbiguities","altsPrefixAmbiguityErrors","checkPrefixAlternativesAmbiguities","RepetitionCollector","buildTooManyAlternativesError","TOO_MANY_ALTS","validateSomeNonEmptyLookaheadPath","topLevelRules","currTopRule","currProd","prodType","paths","pathsInsideProduction","buildEmptyRepetitionError","repetition","NO_NON_EMPTY_LOOKAHEAD","foundAmbiguousPaths","identicalAmbiguities","currAlt","currPath","altsCurrPathAppearsIn","currOtherAlt","currOtherAltIdx","alts","currErrors","currAmbDescriptor","ambgIndices","currMessage","buildAlternationAmbiguityError","ambiguityIndices","prefixPath","AMBIGUOUS_ALTS","pathsAndIndices","currPathsAndIdx","currPathAndIdx","alternativeGast","targetIdx","targetPath","prefixAmbiguitiesPathsAndIndices","searchPathAndIdx","currPathPrefixErrors","currAmbPathAndIdx","buildAlternationPrefixAmbiguityError","AMBIGUOUS_PREFIX_ALTS","tokenNames","currToken","currRuleName","buildNamespaceConflictError","CONFLICT_TOKENS_RULES_NAMESPACE"],"sources":["/home/saiadmin/k3s-cluster/dashboard/frontend/node_modules/chevrotain/src/parse/grammar/checks.ts"],"sourcesContent":["import {\n  clone,\n  compact,\n  difference,\n  drop,\n  dropRight,\n  filter,\n  first,\n  flatMap,\n  flatten,\n  forEach,\n  groupBy,\n  includes,\n  isEmpty,\n  map,\n  pickBy,\n  reduce,\n  reject,\n  values,\n} from \"lodash-es\";\nimport {\n  IParserAmbiguousAlternativesDefinitionError,\n  IParserDuplicatesDefinitionError,\n  IParserEmptyAlternativeDefinitionError,\n  ParserDefinitionErrorType,\n} from \"../parser/parser.js\";\nimport {\n  Alternation,\n  Alternative as AlternativeGAST,\n  GAstVisitor,\n  getProductionDslName,\n  isOptionalProd,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Terminal,\n} from \"@chevrotain/gast\";\nimport {\n  Alternative,\n  containsPath,\n  getLookaheadPathsForOptionalProd,\n  getLookaheadPathsForOr,\n  getProdType,\n  isStrictPrefixOfPath,\n} from \"./lookahead.js\";\nimport { nextPossibleTokensAfter } from \"./interpreter.js\";\nimport {\n  ILookaheadStrategy,\n  IProduction,\n  IProductionWithOccurrence,\n  Rule,\n  TokenType,\n} from \"@chevrotain/types\";\nimport {\n  IGrammarValidatorErrorMessageProvider,\n  IParserDefinitionError,\n} from \"./types.js\";\nimport { tokenStructuredMatcher } from \"../../scan/tokens.js\";\n\nexport function validateLookahead(options: {\n  lookaheadStrategy: ILookaheadStrategy;\n  rules: Rule[];\n  tokenTypes: TokenType[];\n  grammarName: string;\n}): IParserDefinitionError[] {\n  const lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({\n    rules: options.rules,\n    tokenTypes: options.tokenTypes,\n    grammarName: options.grammarName,\n  });\n  return map(lookaheadValidationErrorMessages, (errorMessage) => ({\n    type: ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION,\n    ...errorMessage,\n  }));\n}\n\nexport function validateGrammar(\n  topLevels: Rule[],\n  tokenTypes: TokenType[],\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n  grammarName: string,\n): IParserDefinitionError[] {\n  const duplicateErrors: IParserDefinitionError[] = flatMap(\n    topLevels,\n    (currTopLevel) =>\n      validateDuplicateProductions(currTopLevel, errMsgProvider),\n  );\n\n  const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(\n    topLevels,\n    tokenTypes,\n    errMsgProvider,\n  );\n\n  const tooManyAltsErrors = flatMap(topLevels, (curRule) =>\n    validateTooManyAlts(curRule, errMsgProvider),\n  );\n\n  const duplicateRulesError = flatMap(topLevels, (curRule) =>\n    validateRuleDoesNotAlreadyExist(\n      curRule,\n      topLevels,\n      grammarName,\n      errMsgProvider,\n    ),\n  );\n\n  return duplicateErrors.concat(\n    termsNamespaceConflictErrors,\n    tooManyAltsErrors,\n    duplicateRulesError,\n  );\n}\n\nfunction validateDuplicateProductions(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n): IParserDuplicatesDefinitionError[] {\n  const collectorVisitor = new OccurrenceValidationCollector();\n  topLevelRule.accept(collectorVisitor);\n  const allRuleProductions = collectorVisitor.allProductions;\n\n  const productionGroups = groupBy(\n    allRuleProductions,\n    identifyProductionForDuplicates,\n  );\n\n  const duplicates: any = pickBy(productionGroups, (currGroup) => {\n    return currGroup.length > 1;\n  });\n\n  const errors = map(values(duplicates), (currDuplicates: any) => {\n    const firstProd: any = first(currDuplicates);\n    const msg = errMsgProvider.buildDuplicateFoundError(\n      topLevelRule,\n      currDuplicates,\n    );\n    const dslName = getProductionDslName(firstProd);\n    const defError: IParserDuplicatesDefinitionError = {\n      message: msg,\n      type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx,\n    };\n\n    const param = getExtraProductionArgument(firstProd);\n    if (param) {\n      defError.parameter = param;\n    }\n\n    return defError;\n  });\n  return errors;\n}\n\nexport function identifyProductionForDuplicates(\n  prod: IProductionWithOccurrence,\n): string {\n  return `${getProductionDslName(prod)}_#_${\n    prod.idx\n  }_#_${getExtraProductionArgument(prod)}`;\n}\n\nfunction getExtraProductionArgument(prod: IProductionWithOccurrence): string {\n  if (prod instanceof Terminal) {\n    return prod.terminalType.name;\n  } else if (prod instanceof NonTerminal) {\n    return prod.nonTerminalName;\n  } else {\n    return \"\";\n  }\n}\n\nexport class OccurrenceValidationCollector extends GAstVisitor {\n  public allProductions: IProductionWithOccurrence[] = [];\n\n  public visitNonTerminal(subrule: NonTerminal): void {\n    this.allProductions.push(subrule);\n  }\n\n  public visitOption(option: Option): void {\n    this.allProductions.push(option);\n  }\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.allProductions.push(manySep);\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.allProductions.push(atLeastOne);\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator,\n  ): void {\n    this.allProductions.push(atLeastOneSep);\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.allProductions.push(many);\n  }\n\n  public visitAlternation(or: Alternation): void {\n    this.allProductions.push(or);\n  }\n\n  public visitTerminal(terminal: Terminal): void {\n    this.allProductions.push(terminal);\n  }\n}\n\nexport function validateRuleDoesNotAlreadyExist(\n  rule: Rule,\n  allRules: Rule[],\n  className: string,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n): IParserDefinitionError[] {\n  const errors = [];\n  const occurrences = reduce(\n    allRules,\n    (result, curRule) => {\n      if (curRule.name === rule.name) {\n        return result + 1;\n      }\n      return result;\n    },\n    0,\n  );\n  if (occurrences > 1) {\n    const errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className,\n    });\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name,\n    });\n  }\n\n  return errors;\n}\n\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nexport function validateRuleIsOverridden(\n  ruleName: string,\n  definedRulesNames: string[],\n  className: string,\n): IParserDefinitionError[] {\n  const errors = [];\n  let errMsg;\n\n  if (!includes(definedRulesNames, ruleName)) {\n    errMsg =\n      `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-` +\n      `as it is not defined in any of the super grammars `;\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName,\n    });\n  }\n\n  return errors;\n}\n\nexport function validateNoLeftRecursion(\n  topRule: Rule,\n  currRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n  path: Rule[] = [],\n): IParserDefinitionError[] {\n  const errors: IParserDefinitionError[] = [];\n  const nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n  if (isEmpty(nextNonTerminals)) {\n    return [];\n  } else {\n    const ruleName = topRule.name;\n    const foundLeftRecursion = includes(nextNonTerminals, topRule);\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path,\n        }),\n        type: ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName,\n      });\n    }\n\n    // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n    const validNextSteps = difference(nextNonTerminals, path.concat([topRule]));\n    const errorsFromNextSteps = flatMap(validNextSteps, (currRefRule) => {\n      const newPath = clone(path);\n      newPath.push(currRefRule);\n      return validateNoLeftRecursion(\n        topRule,\n        currRefRule,\n        errMsgProvider,\n        newPath,\n      );\n    });\n\n    return errors.concat(errorsFromNextSteps);\n  }\n}\n\nexport function getFirstNoneTerminal(definition: IProduction[]): Rule[] {\n  let result: Rule[] = [];\n  if (isEmpty(definition)) {\n    return result;\n  }\n  const firstProd = first(definition);\n\n  /* istanbul ignore else */\n  if (firstProd instanceof NonTerminal) {\n    result.push(firstProd.referencedRule);\n  } else if (\n    firstProd instanceof AlternativeGAST ||\n    firstProd instanceof Option ||\n    firstProd instanceof RepetitionMandatory ||\n    firstProd instanceof RepetitionMandatoryWithSeparator ||\n    firstProd instanceof RepetitionWithSeparator ||\n    firstProd instanceof Repetition\n  ) {\n    result = result.concat(\n      getFirstNoneTerminal(<IProduction[]>firstProd.definition),\n    );\n  } else if (firstProd instanceof Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = flatten(\n      map(firstProd.definition, (currSubDef) =>\n        getFirstNoneTerminal((<AlternativeGAST>currSubDef).definition),\n      ),\n    );\n  } else if (firstProd instanceof Terminal) {\n    // nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n\n  const isFirstOptional = isOptionalProd(firstProd);\n  const hasMore = definition.length > 1;\n  if (isFirstOptional && hasMore) {\n    const rest = drop(definition);\n    return result.concat(getFirstNoneTerminal(rest));\n  } else {\n    return result;\n  }\n}\n\nclass OrCollector extends GAstVisitor {\n  public alternations: Alternation[] = [];\n\n  public visitAlternation(node: Alternation): void {\n    this.alternations.push(node);\n  }\n}\n\nexport function validateEmptyOrAlternative(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n): IParserEmptyAlternativeDefinitionError[] {\n  const orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  const ors = orCollector.alternations;\n\n  const errors = flatMap<Alternation, IParserEmptyAlternativeDefinitionError>(\n    ors,\n    (currOr) => {\n      const exceptLast = dropRight(currOr.definition);\n      return flatMap(exceptLast, (currAlternative, currAltIdx) => {\n        const possibleFirstInAlt = nextPossibleTokensAfter(\n          [currAlternative],\n          [],\n          tokenStructuredMatcher,\n          1,\n        );\n        if (isEmpty(possibleFirstInAlt)) {\n          return [\n            {\n              message: errMsgProvider.buildEmptyAlternationError({\n                topLevelRule: topLevelRule,\n                alternation: currOr,\n                emptyChoiceIdx: currAltIdx,\n              }),\n              type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n              ruleName: topLevelRule.name,\n              occurrence: currOr.idx,\n              alternative: currAltIdx + 1,\n            },\n          ];\n        } else {\n          return [];\n        }\n      });\n    },\n  );\n\n  return errors;\n}\n\nexport function validateAmbiguousAlternationAlternatives(\n  topLevelRule: Rule,\n  globalMaxLookahead: number,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n): IParserAmbiguousAlternativesDefinitionError[] {\n  const orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  let ors = orCollector.alternations;\n\n  // New Handling of ignoring ambiguities\n  // - https://github.com/chevrotain/chevrotain/issues/869\n  ors = reject(ors, (currOr) => currOr.ignoreAmbiguities === true);\n\n  const errors = flatMap(ors, (currOr: Alternation) => {\n    const currOccurrence = currOr.idx;\n    const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n    const alternatives = getLookaheadPathsForOr(\n      currOccurrence,\n      topLevelRule,\n      actualMaxLookahead,\n      currOr,\n    );\n    const altsAmbiguityErrors = checkAlternativesAmbiguities(\n      alternatives,\n      currOr,\n      topLevelRule,\n      errMsgProvider,\n    );\n    const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(\n      alternatives,\n      currOr,\n      topLevelRule,\n      errMsgProvider,\n    );\n\n    return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);\n  });\n\n  return errors;\n}\n\nexport class RepetitionCollector extends GAstVisitor {\n  public allProductions: (IProductionWithOccurrence & {\n    maxLookahead?: number;\n  })[] = [];\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.allProductions.push(manySep);\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.allProductions.push(atLeastOne);\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator,\n  ): void {\n    this.allProductions.push(atLeastOneSep);\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.allProductions.push(many);\n  }\n}\n\nexport function validateTooManyAlts(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n): IParserDefinitionError[] {\n  const orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  const ors = orCollector.alternations;\n\n  const errors = flatMap(ors, (currOr) => {\n    if (currOr.definition.length > 255) {\n      return [\n        {\n          message: errMsgProvider.buildTooManyAlternativesError({\n            topLevelRule: topLevelRule,\n            alternation: currOr,\n          }),\n          type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx,\n        },\n      ];\n    } else {\n      return [];\n    }\n  });\n\n  return errors;\n}\n\nexport function validateSomeNonEmptyLookaheadPath(\n  topLevelRules: Rule[],\n  maxLookahead: number,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n): IParserDefinitionError[] {\n  const errors: IParserDefinitionError[] = [];\n  forEach(topLevelRules, (currTopRule) => {\n    const collectorVisitor = new RepetitionCollector();\n    currTopRule.accept(collectorVisitor);\n    const allRuleProductions = collectorVisitor.allProductions;\n    forEach(allRuleProductions, (currProd) => {\n      const prodType = getProdType(currProd);\n      const actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n      const currOccurrence = currProd.idx;\n      const paths = getLookaheadPathsForOptionalProd(\n        currOccurrence,\n        currTopRule,\n        prodType,\n        actualMaxLookahead,\n      );\n      const pathsInsideProduction = paths[0];\n      if (isEmpty(flatten(pathsInsideProduction))) {\n        const errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd,\n        });\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name,\n        });\n      }\n    });\n  });\n\n  return errors;\n}\n\nexport interface IAmbiguityDescriptor {\n  alts: number[];\n  path: TokenType[];\n}\n\nfunction checkAlternativesAmbiguities(\n  alternatives: Alternative[],\n  alternation: Alternation,\n  rule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n): IParserAmbiguousAlternativesDefinitionError[] {\n  const foundAmbiguousPaths: Alternative = [];\n  const identicalAmbiguities = reduce(\n    alternatives,\n    (result, currAlt, currAltIdx) => {\n      // ignore (skip) ambiguities with this alternative\n      if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n        return result;\n      }\n\n      forEach(currAlt, (currPath) => {\n        const altsCurrPathAppearsIn = [currAltIdx];\n        forEach(alternatives, (currOtherAlt, currOtherAltIdx) => {\n          if (\n            currAltIdx !== currOtherAltIdx &&\n            containsPath(currOtherAlt, currPath) &&\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true\n          ) {\n            altsCurrPathAppearsIn.push(currOtherAltIdx);\n          }\n        });\n\n        if (\n          altsCurrPathAppearsIn.length > 1 &&\n          !containsPath(foundAmbiguousPaths, currPath)\n        ) {\n          foundAmbiguousPaths.push(currPath);\n          result.push({\n            alts: altsCurrPathAppearsIn,\n            path: currPath,\n          });\n        }\n      });\n      return result;\n    },\n    [] as { alts: number[]; path: TokenType[] }[],\n  );\n\n  const currErrors = map(identicalAmbiguities, (currAmbDescriptor) => {\n    const ambgIndices = map(\n      currAmbDescriptor.alts,\n      (currAltIdx) => currAltIdx + 1,\n    );\n\n    const currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path,\n    });\n\n    return {\n      message: currMessage,\n      type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: currAmbDescriptor.alts,\n    };\n  });\n\n  return currErrors;\n}\n\nexport function checkPrefixAlternativesAmbiguities(\n  alternatives: Alternative[],\n  alternation: Alternation,\n  rule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n): IParserAmbiguousAlternativesDefinitionError[] {\n  // flatten\n  const pathsAndIndices = reduce(\n    alternatives,\n    (result, currAlt, idx) => {\n      const currPathsAndIdx = map(currAlt, (currPath) => {\n        return { idx: idx, path: currPath };\n      });\n      return result.concat(currPathsAndIdx);\n    },\n    [] as { idx: number; path: TokenType[] }[],\n  );\n\n  const errors = compact(\n    flatMap(pathsAndIndices, (currPathAndIdx) => {\n      const alternativeGast = alternation.definition[currPathAndIdx.idx];\n      // ignore (skip) ambiguities with this alternative\n      if (alternativeGast.ignoreAmbiguities === true) {\n        return [];\n      }\n      const targetIdx = currPathAndIdx.idx;\n      const targetPath = currPathAndIdx.path;\n\n      const prefixAmbiguitiesPathsAndIndices = filter(\n        pathsAndIndices,\n        (searchPathAndIdx) => {\n          // prefix ambiguity can only be created from lower idx (higher priority) path\n          return (\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !==\n              true &&\n            searchPathAndIdx.idx < targetIdx &&\n            // checking for strict prefix because identical lookaheads\n            // will be be detected using a different validation.\n            isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n          );\n        },\n      );\n\n      const currPathPrefixErrors = map(\n        prefixAmbiguitiesPathsAndIndices,\n        (currAmbPathAndIdx): IParserAmbiguousAlternativesDefinitionError => {\n          const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n          const occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n\n          const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbPathAndIdx.path,\n          });\n          return {\n            message: message,\n            type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n            ruleName: rule.name,\n            occurrence: occurrence,\n            alternatives: ambgIndices,\n          };\n        },\n      );\n\n      return currPathPrefixErrors;\n    }),\n  );\n\n  return errors;\n}\n\nfunction checkTerminalAndNoneTerminalsNameSpace(\n  topLevels: Rule[],\n  tokenTypes: TokenType[],\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n): IParserDefinitionError[] {\n  const errors: IParserDefinitionError[] = [];\n\n  const tokenNames = map(tokenTypes, (currToken) => currToken.name);\n\n  forEach(topLevels, (currRule) => {\n    const currRuleName = currRule.name;\n    if (includes(tokenNames, currRuleName)) {\n      const errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName,\n      });\n    }\n  });\n\n  return errors;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}