{"ast":null,"code":"/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { EMPTY_ALT, EOF } from 'chevrotain';\nimport { isAction, isAlternatives, isEndOfFile, isAssignment, isConjunction, isCrossReference, isDisjunction, isGroup, isKeyword, isNegation, isParameterReference, isParserRule, isRuleCall, isTerminalRule, isUnorderedGroup, isBooleanLiteral } from '../languages/generated/ast.js';\nimport { assertUnreachable, ErrorWithLocation } from '../utils/errors.js';\nimport { stream } from '../utils/stream.js';\nimport { findNameAssignment, getAllReachableRules, getTypeName } from '../utils/grammar-utils.js';\nexport function createParser(grammar, parser, tokens) {\n  const parserContext = {\n    parser,\n    tokens,\n    ruleNames: new Map()\n  };\n  buildRules(parserContext, grammar);\n  return parser;\n}\nfunction buildRules(parserContext, grammar) {\n  const reachable = getAllReachableRules(grammar, false);\n  const parserRules = stream(grammar.rules).filter(isParserRule).filter(rule => reachable.has(rule));\n  for (const rule of parserRules) {\n    const ctx = Object.assign(Object.assign({}, parserContext), {\n      consume: 1,\n      optional: 1,\n      subrule: 1,\n      many: 1,\n      or: 1\n    });\n    parserContext.parser.rule(rule, buildElement(ctx, rule.definition));\n  }\n}\nfunction buildElement(ctx, element) {\n  let ignoreGuard = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let method;\n  if (isKeyword(element)) {\n    method = buildKeyword(ctx, element);\n  } else if (isAction(element)) {\n    method = buildAction(ctx, element);\n  } else if (isAssignment(element)) {\n    method = buildElement(ctx, element.terminal);\n  } else if (isCrossReference(element)) {\n    method = buildCrossReference(ctx, element);\n  } else if (isRuleCall(element)) {\n    method = buildRuleCall(ctx, element);\n  } else if (isAlternatives(element)) {\n    method = buildAlternatives(ctx, element);\n  } else if (isUnorderedGroup(element)) {\n    method = buildUnorderedGroup(ctx, element);\n  } else if (isGroup(element)) {\n    method = buildGroup(ctx, element);\n  } else if (isEndOfFile(element)) {\n    const idx = ctx.consume++;\n    method = () => ctx.parser.consume(idx, EOF, element);\n  } else {\n    throw new ErrorWithLocation(element.$cstNode, \"Unexpected element type: \".concat(element.$type));\n  }\n  return wrap(ctx, ignoreGuard ? undefined : getGuardCondition(element), method, element.cardinality);\n}\nfunction buildAction(ctx, action) {\n  const actionType = getTypeName(action);\n  return () => ctx.parser.action(actionType, action);\n}\nfunction buildRuleCall(ctx, ruleCall) {\n  const rule = ruleCall.rule.ref;\n  if (isParserRule(rule)) {\n    const idx = ctx.subrule++;\n    const fragment = rule.fragment;\n    const predicate = ruleCall.arguments.length > 0 ? buildRuleCallPredicate(rule, ruleCall.arguments) : () => ({});\n    return args => ctx.parser.subrule(idx, getRule(ctx, rule), fragment, ruleCall, predicate(args));\n  } else if (isTerminalRule(rule)) {\n    const idx = ctx.consume++;\n    const method = getToken(ctx, rule.name);\n    return () => ctx.parser.consume(idx, method, ruleCall);\n  } else if (!rule) {\n    throw new ErrorWithLocation(ruleCall.$cstNode, \"Undefined rule: \".concat(ruleCall.rule.$refText));\n  } else {\n    assertUnreachable(rule);\n  }\n}\nfunction buildRuleCallPredicate(rule, namedArgs) {\n  const predicates = namedArgs.map(e => buildPredicate(e.value));\n  return args => {\n    const ruleArgs = {};\n    for (let i = 0; i < predicates.length; i++) {\n      const ruleTarget = rule.parameters[i];\n      const predicate = predicates[i];\n      ruleArgs[ruleTarget.name] = predicate(args);\n    }\n    return ruleArgs;\n  };\n}\nfunction buildPredicate(condition) {\n  if (isDisjunction(condition)) {\n    const left = buildPredicate(condition.left);\n    const right = buildPredicate(condition.right);\n    return args => left(args) || right(args);\n  } else if (isConjunction(condition)) {\n    const left = buildPredicate(condition.left);\n    const right = buildPredicate(condition.right);\n    return args => left(args) && right(args);\n  } else if (isNegation(condition)) {\n    const value = buildPredicate(condition.value);\n    return args => !value(args);\n  } else if (isParameterReference(condition)) {\n    const name = condition.parameter.ref.name;\n    return args => args !== undefined && args[name] === true;\n  } else if (isBooleanLiteral(condition)) {\n    const value = Boolean(condition.true);\n    return () => value;\n  }\n  assertUnreachable(condition);\n}\nfunction buildAlternatives(ctx, alternatives) {\n  if (alternatives.elements.length === 1) {\n    return buildElement(ctx, alternatives.elements[0]);\n  } else {\n    const methods = [];\n    for (const element of alternatives.elements) {\n      const predicatedMethod = {\n        // Since we handle the guard condition in the alternative already\n        // We can ignore the group guard condition inside\n        ALT: buildElement(ctx, element, true)\n      };\n      const guard = getGuardCondition(element);\n      if (guard) {\n        predicatedMethod.GATE = buildPredicate(guard);\n      }\n      methods.push(predicatedMethod);\n    }\n    const idx = ctx.or++;\n    return args => ctx.parser.alternatives(idx, methods.map(method => {\n      const alt = {\n        ALT: () => method.ALT(args)\n      };\n      const gate = method.GATE;\n      if (gate) {\n        alt.GATE = () => gate(args);\n      }\n      return alt;\n    }));\n  }\n}\nfunction buildUnorderedGroup(ctx, group) {\n  if (group.elements.length === 1) {\n    return buildElement(ctx, group.elements[0]);\n  }\n  const methods = [];\n  for (const element of group.elements) {\n    const predicatedMethod = {\n      // Since we handle the guard condition in the alternative already\n      // We can ignore the group guard condition inside\n      ALT: buildElement(ctx, element, true)\n    };\n    const guard = getGuardCondition(element);\n    if (guard) {\n      predicatedMethod.GATE = buildPredicate(guard);\n    }\n    methods.push(predicatedMethod);\n  }\n  const orIdx = ctx.or++;\n  const idFunc = (groupIdx, lParser) => {\n    const stackId = lParser.getRuleStack().join('-');\n    return \"uGroup_\".concat(groupIdx, \"_\").concat(stackId);\n  };\n  const alternatives = args => ctx.parser.alternatives(orIdx, methods.map((method, idx) => {\n    const alt = {\n      ALT: () => true\n    };\n    const parser = ctx.parser;\n    alt.ALT = () => {\n      method.ALT(args);\n      if (!parser.isRecording()) {\n        const key = idFunc(orIdx, parser);\n        if (!parser.unorderedGroups.get(key)) {\n          // init after clear state\n          parser.unorderedGroups.set(key, []);\n        }\n        const groupState = parser.unorderedGroups.get(key);\n        if (typeof (groupState === null || groupState === void 0 ? void 0 : groupState[idx]) === 'undefined') {\n          // Not accessed yet\n          groupState[idx] = true;\n        }\n      }\n    };\n    const gate = method.GATE;\n    if (gate) {\n      alt.GATE = () => gate(args);\n    } else {\n      alt.GATE = () => {\n        const trackedAlternatives = parser.unorderedGroups.get(idFunc(orIdx, parser));\n        const allow = !(trackedAlternatives === null || trackedAlternatives === void 0 ? void 0 : trackedAlternatives[idx]);\n        return allow;\n      };\n    }\n    return alt;\n  }));\n  const wrapped = wrap(ctx, getGuardCondition(group), alternatives, '*');\n  return args => {\n    wrapped(args);\n    if (!ctx.parser.isRecording()) {\n      ctx.parser.unorderedGroups.delete(idFunc(orIdx, ctx.parser));\n    }\n  };\n}\nfunction buildGroup(ctx, group) {\n  const methods = group.elements.map(e => buildElement(ctx, e));\n  return args => methods.forEach(method => method(args));\n}\nfunction getGuardCondition(element) {\n  if (isGroup(element)) {\n    return element.guardCondition;\n  }\n  return undefined;\n}\nfunction buildCrossReference(ctx, crossRef) {\n  let terminal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : crossRef.terminal;\n  if (!terminal) {\n    if (!crossRef.type.ref) {\n      throw new Error('Could not resolve reference to type: ' + crossRef.type.$refText);\n    }\n    const assignment = findNameAssignment(crossRef.type.ref);\n    const assignTerminal = assignment === null || assignment === void 0 ? void 0 : assignment.terminal;\n    if (!assignTerminal) {\n      throw new Error('Could not find name assignment for type: ' + getTypeName(crossRef.type.ref));\n    }\n    return buildCrossReference(ctx, crossRef, assignTerminal);\n  } else if (isRuleCall(terminal) && isParserRule(terminal.rule.ref)) {\n    // The terminal is a data type rule here. Everything else will result in a validation error.\n    const rule = terminal.rule.ref;\n    const idx = ctx.subrule++;\n    return args => ctx.parser.subrule(idx, getRule(ctx, rule), false, crossRef, args);\n  } else if (isRuleCall(terminal) && isTerminalRule(terminal.rule.ref)) {\n    const idx = ctx.consume++;\n    const terminalRule = getToken(ctx, terminal.rule.ref.name);\n    return () => ctx.parser.consume(idx, terminalRule, crossRef);\n  } else if (isKeyword(terminal)) {\n    const idx = ctx.consume++;\n    const keyword = getToken(ctx, terminal.value);\n    return () => ctx.parser.consume(idx, keyword, crossRef);\n  } else {\n    throw new Error('Could not build cross reference parser');\n  }\n}\nfunction buildKeyword(ctx, keyword) {\n  const idx = ctx.consume++;\n  const token = ctx.tokens[keyword.value];\n  if (!token) {\n    throw new Error('Could not find token for keyword: ' + keyword.value);\n  }\n  return () => ctx.parser.consume(idx, token, keyword);\n}\nfunction wrap(ctx, guard, method, cardinality) {\n  const gate = guard && buildPredicate(guard);\n  if (!cardinality) {\n    if (gate) {\n      const idx = ctx.or++;\n      return args => ctx.parser.alternatives(idx, [{\n        ALT: () => method(args),\n        GATE: () => gate(args)\n      }, {\n        ALT: EMPTY_ALT(),\n        GATE: () => !gate(args)\n      }]);\n    } else {\n      return method;\n    }\n  }\n  if (cardinality === '*') {\n    const idx = ctx.many++;\n    return args => ctx.parser.many(idx, {\n      DEF: () => method(args),\n      GATE: gate ? () => gate(args) : undefined\n    });\n  } else if (cardinality === '+') {\n    const idx = ctx.many++;\n    if (gate) {\n      const orIdx = ctx.or++;\n      // In the case of a guard condition for the `+` group\n      // We combine it with an empty alternative\n      // If the condition returns true, it needs to parse at least a single iteration\n      // If its false, it is not allowed to parse anything\n      return args => ctx.parser.alternatives(orIdx, [{\n        ALT: () => ctx.parser.atLeastOne(idx, {\n          DEF: () => method(args)\n        }),\n        GATE: () => gate(args)\n      }, {\n        ALT: EMPTY_ALT(),\n        GATE: () => !gate(args)\n      }]);\n    } else {\n      return args => ctx.parser.atLeastOne(idx, {\n        DEF: () => method(args)\n      });\n    }\n  } else if (cardinality === '?') {\n    const idx = ctx.optional++;\n    return args => ctx.parser.optional(idx, {\n      DEF: () => method(args),\n      GATE: gate ? () => gate(args) : undefined\n    });\n  } else {\n    assertUnreachable(cardinality);\n  }\n}\nfunction getRule(ctx, element) {\n  const name = getRuleName(ctx, element);\n  const rule = ctx.parser.getRule(name);\n  if (!rule) throw new Error(\"Rule \\\"\".concat(name, \"\\\" not found.\\\"\"));\n  return rule;\n}\nfunction getRuleName(ctx, element) {\n  if (isParserRule(element)) {\n    return element.name;\n  } else if (ctx.ruleNames.has(element)) {\n    return ctx.ruleNames.get(element);\n  } else {\n    let item = element;\n    let parent = item.$container;\n    let ruleName = element.$type;\n    while (!isParserRule(parent)) {\n      if (isGroup(parent) || isAlternatives(parent) || isUnorderedGroup(parent)) {\n        const index = parent.elements.indexOf(item);\n        ruleName = index.toString() + ':' + ruleName;\n      }\n      item = parent;\n      parent = parent.$container;\n    }\n    const rule = parent;\n    ruleName = rule.name + ':' + ruleName;\n    ctx.ruleNames.set(element, ruleName);\n    return ruleName;\n  }\n}\nfunction getToken(ctx, name) {\n  const token = ctx.tokens[name];\n  if (!token) throw new Error(\"Token \\\"\".concat(name, \"\\\" not found.\\\"\"));\n  return token;\n}","map":{"version":3,"names":["EMPTY_ALT","EOF","isAction","isAlternatives","isEndOfFile","isAssignment","isConjunction","isCrossReference","isDisjunction","isGroup","isKeyword","isNegation","isParameterReference","isParserRule","isRuleCall","isTerminalRule","isUnorderedGroup","isBooleanLiteral","assertUnreachable","ErrorWithLocation","stream","findNameAssignment","getAllReachableRules","getTypeName","createParser","grammar","parser","tokens","parserContext","ruleNames","Map","buildRules","reachable","parserRules","rules","filter","rule","has","ctx","Object","assign","consume","optional","subrule","many","or","buildElement","definition","element","ignoreGuard","arguments","length","undefined","method","buildKeyword","buildAction","terminal","buildCrossReference","buildRuleCall","buildAlternatives","buildUnorderedGroup","buildGroup","idx","$cstNode","concat","$type","wrap","getGuardCondition","cardinality","action","actionType","ruleCall","ref","fragment","predicate","buildRuleCallPredicate","args","getRule","getToken","name","$refText","namedArgs","predicates","map","e","buildPredicate","value","ruleArgs","i","ruleTarget","parameters","condition","left","right","parameter","Boolean","true","alternatives","elements","methods","predicatedMethod","ALT","guard","GATE","push","alt","gate","group","orIdx","idFunc","groupIdx","lParser","stackId","getRuleStack","join","isRecording","key","unorderedGroups","get","set","groupState","trackedAlternatives","allow","wrapped","delete","forEach","guardCondition","crossRef","type","Error","assignment","assignTerminal","terminalRule","keyword","token","DEF","atLeastOne","getRuleName","item","parent","$container","ruleName","index","indexOf","toString"],"sources":["/home/saiadmin/k3s-cluster/dashboard/frontend/node_modules/langium/src/parser/parser-builder-base.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { IOrAlt, TokenType, TokenTypeDictionary } from 'chevrotain';\r\nimport type { AbstractElement, Action, Alternatives, Condition, CrossReference, Grammar, Group, Keyword, NamedArgument, ParserRule, RuleCall, UnorderedGroup } from '../languages/generated/ast.js';\r\nimport type { BaseParser } from './langium-parser.js';\r\nimport type { AstNode } from '../syntax-tree.js';\r\nimport type { Cardinality } from '../utils/grammar-utils.js';\r\nimport { EMPTY_ALT, EOF } from 'chevrotain';\r\nimport { isAction, isAlternatives, isEndOfFile, isAssignment, isConjunction, isCrossReference, isDisjunction, isGroup, isKeyword, isNegation, isParameterReference, isParserRule, isRuleCall, isTerminalRule, isUnorderedGroup, isBooleanLiteral } from '../languages/generated/ast.js';\r\nimport { assertUnreachable, ErrorWithLocation } from '../utils/errors.js';\r\nimport { stream } from '../utils/stream.js';\r\nimport { findNameAssignment, getAllReachableRules, getTypeName } from '../utils/grammar-utils.js';\r\n\r\ntype RuleContext = {\r\n    optional: number,\r\n    consume: number,\r\n    subrule: number,\r\n    many: number,\r\n    or: number\r\n} & ParserContext;\r\n\r\ntype ParserContext = {\r\n    parser: BaseParser\r\n    tokens: TokenTypeDictionary\r\n    ruleNames: Map<AstNode, string>\r\n}\r\n\r\ntype Rule = (args: Args) => unknown;\r\n\r\ntype Args = Record<string, boolean>;\r\n\r\ntype Predicate = (args: Args) => boolean;\r\n\r\ntype Method = (args: Args) => void;\r\n\r\nexport function createParser<T extends BaseParser>(grammar: Grammar, parser: T, tokens: TokenTypeDictionary): T {\r\n    const parserContext: ParserContext = {\r\n        parser,\r\n        tokens,\r\n        ruleNames: new Map()\r\n    };\r\n    buildRules(parserContext, grammar);\r\n    return parser;\r\n}\r\n\r\nfunction buildRules(parserContext: ParserContext, grammar: Grammar): void {\r\n    const reachable = getAllReachableRules(grammar, false);\r\n    const parserRules = stream(grammar.rules).filter(isParserRule).filter(rule => reachable.has(rule));\r\n    for (const rule of parserRules) {\r\n        const ctx: RuleContext = {\r\n            ...parserContext,\r\n            consume: 1,\r\n            optional: 1,\r\n            subrule: 1,\r\n            many: 1,\r\n            or: 1\r\n        };\r\n        parserContext.parser.rule(rule, buildElement(ctx, rule.definition));\r\n    }\r\n}\r\n\r\nfunction buildElement(ctx: RuleContext, element: AbstractElement, ignoreGuard = false): Method {\r\n    let method: Method;\r\n    if (isKeyword(element)) {\r\n        method = buildKeyword(ctx, element);\r\n    } else if (isAction(element)) {\r\n        method = buildAction(ctx, element);\r\n    } else if (isAssignment(element)) {\r\n        method = buildElement(ctx, element.terminal);\r\n    } else if (isCrossReference(element)) {\r\n        method = buildCrossReference(ctx, element);\r\n    } else if (isRuleCall(element)) {\r\n        method = buildRuleCall(ctx, element);\r\n    } else if (isAlternatives(element)) {\r\n        method = buildAlternatives(ctx, element);\r\n    } else if (isUnorderedGroup(element)) {\r\n        method = buildUnorderedGroup(ctx, element);\r\n    } else if (isGroup(element)) {\r\n        method = buildGroup(ctx, element);\r\n    } else if(isEndOfFile(element)) {\r\n        const idx = ctx.consume++;\r\n        method = () => ctx.parser.consume(idx, EOF, element);\r\n    } else {\r\n        throw new ErrorWithLocation(element.$cstNode, `Unexpected element type: ${element.$type}`);\r\n    }\r\n    return wrap(ctx, ignoreGuard ? undefined : getGuardCondition(element), method, element.cardinality);\r\n}\r\n\r\nfunction buildAction(ctx: RuleContext, action: Action): Method {\r\n    const actionType = getTypeName(action);\r\n    return () => ctx.parser.action(actionType, action);\r\n}\r\n\r\nfunction buildRuleCall(ctx: RuleContext, ruleCall: RuleCall): Method {\r\n    const rule = ruleCall.rule.ref;\r\n    if (isParserRule(rule)) {\r\n        const idx = ctx.subrule++;\r\n        const fragment = rule.fragment;\r\n        const predicate = ruleCall.arguments.length > 0 ? buildRuleCallPredicate(rule, ruleCall.arguments) : () => ({});\r\n        return (args) => ctx.parser.subrule(idx, getRule(ctx, rule), fragment, ruleCall, predicate(args));\r\n    } else if (isTerminalRule(rule)) {\r\n        const idx = ctx.consume++;\r\n        const method = getToken(ctx, rule.name);\r\n        return () => ctx.parser.consume(idx, method, ruleCall);\r\n    } else if (!rule) {\r\n        throw new ErrorWithLocation(ruleCall.$cstNode, `Undefined rule: ${ruleCall.rule.$refText}`);\r\n    } else {\r\n        assertUnreachable(rule);\r\n    }\r\n}\r\n\r\nfunction buildRuleCallPredicate(rule: ParserRule, namedArgs: NamedArgument[]): (args: Args) => Args {\r\n    const predicates = namedArgs.map(e => buildPredicate(e.value));\r\n    return (args) => {\r\n        const ruleArgs: Args = {};\r\n        for (let i = 0; i < predicates.length; i++) {\r\n            const ruleTarget = rule.parameters[i];\r\n            const predicate = predicates[i];\r\n            ruleArgs[ruleTarget.name] = predicate(args);\r\n        }\r\n        return ruleArgs;\r\n    };\r\n}\r\n\r\ninterface PredicatedMethod {\r\n    ALT: Method,\r\n    GATE?: Predicate\r\n}\r\n\r\nfunction buildPredicate(condition: Condition): Predicate {\r\n    if (isDisjunction(condition)) {\r\n        const left = buildPredicate(condition.left);\r\n        const right = buildPredicate(condition.right);\r\n        return (args) => (left(args) || right(args));\r\n    } else if (isConjunction(condition)) {\r\n        const left = buildPredicate(condition.left);\r\n        const right = buildPredicate(condition.right);\r\n        return (args) => (left(args) && right(args));\r\n    } else if (isNegation(condition)) {\r\n        const value = buildPredicate(condition.value);\r\n        return (args) => !value(args);\r\n    } else if (isParameterReference(condition)) {\r\n        const name = condition.parameter.ref!.name;\r\n        return (args) => args !== undefined && args[name] === true;\r\n    } else if (isBooleanLiteral(condition)) {\r\n        const value = Boolean(condition.true);\r\n        return () => value;\r\n    }\r\n    assertUnreachable(condition);\r\n}\r\n\r\nfunction buildAlternatives(ctx: RuleContext, alternatives: Alternatives): Method {\r\n    if (alternatives.elements.length === 1) {\r\n        return buildElement(ctx, alternatives.elements[0]);\r\n    } else {\r\n        const methods: PredicatedMethod[] = [];\r\n\r\n        for (const element of alternatives.elements) {\r\n            const predicatedMethod: PredicatedMethod = {\r\n                // Since we handle the guard condition in the alternative already\r\n                // We can ignore the group guard condition inside\r\n                ALT: buildElement(ctx, element, true)\r\n            };\r\n            const guard = getGuardCondition(element);\r\n            if (guard) {\r\n                predicatedMethod.GATE = buildPredicate(guard);\r\n            }\r\n            methods.push(predicatedMethod);\r\n        }\r\n\r\n        const idx = ctx.or++;\r\n        return (args) => ctx.parser.alternatives(idx, methods.map(method => {\r\n            const alt: IOrAlt<unknown> = {\r\n                ALT: () => method.ALT(args)\r\n            };\r\n            const gate = method.GATE;\r\n            if (gate) {\r\n                alt.GATE = () => gate(args);\r\n            }\r\n            return alt;\r\n        }));\r\n    }\r\n}\r\n\r\nfunction buildUnorderedGroup(ctx: RuleContext, group: UnorderedGroup): Method {\r\n    if (group.elements.length === 1) {\r\n        return buildElement(ctx, group.elements[0]);\r\n    }\r\n    const methods: PredicatedMethod[] = [];\r\n\r\n    for (const element of group.elements) {\r\n        const predicatedMethod: PredicatedMethod = {\r\n            // Since we handle the guard condition in the alternative already\r\n            // We can ignore the group guard condition inside\r\n            ALT: buildElement(ctx, element, true)\r\n        };\r\n        const guard = getGuardCondition(element);\r\n        if (guard) {\r\n            predicatedMethod.GATE = buildPredicate(guard);\r\n        }\r\n        methods.push(predicatedMethod);\r\n    }\r\n\r\n    const orIdx = ctx.or++;\r\n\r\n    const idFunc = (groupIdx: number, lParser: BaseParser) => {\r\n        const stackId = lParser.getRuleStack().join('-');\r\n        return `uGroup_${groupIdx}_${stackId}`;\r\n    };\r\n    const alternatives: Method = (args) => ctx.parser.alternatives(orIdx, methods.map((method, idx) => {\r\n        const alt: IOrAlt<unknown> = { ALT: () => true };\r\n        const parser = ctx.parser;\r\n        alt.ALT = () => {\r\n            method.ALT(args);\r\n            if (!parser.isRecording()) {\r\n                const key = idFunc(orIdx, parser);\r\n                if (!parser.unorderedGroups.get(key)) {\r\n                    // init after clear state\r\n                    parser.unorderedGroups.set(key, []);\r\n                }\r\n                const groupState = parser.unorderedGroups.get(key)!;\r\n                if (typeof groupState?.[idx] === 'undefined') {\r\n                    // Not accessed yet\r\n                    groupState[idx] = true;\r\n                }\r\n            }\r\n        };\r\n        const gate = method.GATE;\r\n        if (gate) {\r\n            alt.GATE = () => gate(args);\r\n        } else {\r\n            alt.GATE = () => {\r\n                const trackedAlternatives = parser.unorderedGroups.get(idFunc(orIdx, parser));\r\n                const allow = !trackedAlternatives?.[idx];\r\n                return allow;\r\n            };\r\n        }\r\n        return alt;\r\n    }));\r\n    const wrapped = wrap(ctx, getGuardCondition(group), alternatives, '*');\r\n    return (args) => {\r\n        wrapped(args);\r\n        if (!ctx.parser.isRecording()) {\r\n            ctx.parser.unorderedGroups.delete(idFunc(orIdx, ctx.parser));\r\n        }\r\n    };\r\n}\r\n\r\nfunction buildGroup(ctx: RuleContext, group: Group): Method {\r\n    const methods = group.elements.map(e => buildElement(ctx, e));\r\n    return (args) => methods.forEach(method => method(args));\r\n}\r\n\r\nfunction getGuardCondition(element: AbstractElement): Condition | undefined {\r\n    if (isGroup(element)) {\r\n        return element.guardCondition;\r\n    }\r\n    return undefined;\r\n}\r\n\r\nfunction buildCrossReference(ctx: RuleContext, crossRef: CrossReference, terminal = crossRef.terminal): Method {\r\n    if (!terminal) {\r\n        if (!crossRef.type.ref) {\r\n            throw new Error('Could not resolve reference to type: ' + crossRef.type.$refText);\r\n        }\r\n        const assignment = findNameAssignment(crossRef.type.ref);\r\n        const assignTerminal = assignment?.terminal;\r\n        if (!assignTerminal) {\r\n            throw new Error('Could not find name assignment for type: ' + getTypeName(crossRef.type.ref));\r\n        }\r\n        return buildCrossReference(ctx, crossRef, assignTerminal);\r\n    } else if (isRuleCall(terminal) && isParserRule(terminal.rule.ref)) {\r\n        // The terminal is a data type rule here. Everything else will result in a validation error.\r\n        const rule = terminal.rule.ref;\r\n        const idx = ctx.subrule++;\r\n        return (args) => ctx.parser.subrule(idx, getRule(ctx, rule), false, crossRef, args);\r\n    } else if (isRuleCall(terminal) && isTerminalRule(terminal.rule.ref)) {\r\n        const idx = ctx.consume++;\r\n        const terminalRule = getToken(ctx, terminal.rule.ref.name);\r\n        return () => ctx.parser.consume(idx, terminalRule, crossRef);\r\n    } else if (isKeyword(terminal)) {\r\n        const idx = ctx.consume++;\r\n        const keyword = getToken(ctx, terminal.value);\r\n        return () => ctx.parser.consume(idx, keyword, crossRef);\r\n    }\r\n    else {\r\n        throw new Error('Could not build cross reference parser');\r\n    }\r\n}\r\n\r\nfunction buildKeyword(ctx: RuleContext, keyword: Keyword): Method {\r\n    const idx = ctx.consume++;\r\n    const token = ctx.tokens[keyword.value];\r\n    if (!token) {\r\n        throw new Error('Could not find token for keyword: ' + keyword.value);\r\n    }\r\n    return () => ctx.parser.consume(idx, token, keyword);\r\n}\r\n\r\nfunction wrap(ctx: RuleContext, guard: Condition | undefined, method: Method, cardinality: Cardinality): Method {\r\n    const gate = guard && buildPredicate(guard);\r\n\r\n    if (!cardinality) {\r\n        if (gate) {\r\n            const idx = ctx.or++;\r\n            return (args) => ctx.parser.alternatives(idx, [\r\n                {\r\n                    ALT: () => method(args),\r\n                    GATE: () => gate(args)\r\n                },\r\n                {\r\n                    ALT: EMPTY_ALT(),\r\n                    GATE: () => !gate(args)\r\n                }\r\n            ]);\r\n        } else {\r\n            return method;\r\n        }\r\n    }\r\n\r\n    if (cardinality === '*') {\r\n        const idx = ctx.many++;\r\n        return (args) => ctx.parser.many(idx, {\r\n            DEF: () => method(args),\r\n            GATE: gate ? () => gate(args) : undefined\r\n        });\r\n    } else if (cardinality === '+') {\r\n        const idx = ctx.many++;\r\n        if (gate) {\r\n            const orIdx = ctx.or++;\r\n            // In the case of a guard condition for the `+` group\r\n            // We combine it with an empty alternative\r\n            // If the condition returns true, it needs to parse at least a single iteration\r\n            // If its false, it is not allowed to parse anything\r\n            return (args) => ctx.parser.alternatives(orIdx, [\r\n                {\r\n                    ALT: () => ctx.parser.atLeastOne(idx, {\r\n                        DEF: () => method(args)\r\n                    }),\r\n                    GATE: () => gate(args)\r\n                },\r\n                {\r\n                    ALT: EMPTY_ALT(),\r\n                    GATE: () => !gate(args)\r\n                }\r\n            ]);\r\n        } else {\r\n            return (args) => ctx.parser.atLeastOne(idx, {\r\n                DEF: () => method(args),\r\n            });\r\n        }\r\n    } else if (cardinality === '?') {\r\n        const idx = ctx.optional++;\r\n        return (args) => ctx.parser.optional(idx, {\r\n            DEF: () => method(args),\r\n            GATE: gate ? () => gate(args) : undefined\r\n        });\r\n    } else {\r\n        assertUnreachable(cardinality);\r\n    }\r\n}\r\n\r\nfunction getRule(ctx: ParserContext, element: ParserRule | AbstractElement): Rule {\r\n    const name = getRuleName(ctx, element);\r\n    const rule = ctx.parser.getRule(name);\r\n    if (!rule) throw new Error(`Rule \"${name}\" not found.\"`);\r\n    return rule;\r\n}\r\n\r\nfunction getRuleName(ctx: ParserContext, element: ParserRule | AbstractElement): string {\r\n    if (isParserRule(element)) {\r\n        return element.name;\r\n    } else if (ctx.ruleNames.has(element)) {\r\n        return ctx.ruleNames.get(element)!;\r\n    } else {\r\n        let item: AstNode = element;\r\n        let parent: AstNode = item.$container!;\r\n        let ruleName: string = element.$type;\r\n        while (!isParserRule(parent)) {\r\n            if (isGroup(parent) || isAlternatives(parent) || isUnorderedGroup(parent)) {\r\n                const index = parent.elements.indexOf(item as AbstractElement);\r\n                ruleName = index.toString() + ':' + ruleName;\r\n            }\r\n            item = parent;\r\n            parent = parent.$container!;\r\n        }\r\n        const rule = parent as ParserRule;\r\n        ruleName = rule.name + ':' + ruleName;\r\n        ctx.ruleNames.set(element, ruleName);\r\n        return ruleName;\r\n    }\r\n}\r\n\r\nfunction getToken(ctx: ParserContext, name: string): TokenType {\r\n    const token = ctx.tokens[name];\r\n    if (!token) throw new Error(`Token \"${name}\" not found.\"`);\r\n    return token;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}