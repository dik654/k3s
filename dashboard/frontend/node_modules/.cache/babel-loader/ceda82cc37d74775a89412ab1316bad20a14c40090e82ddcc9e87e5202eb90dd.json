{"ast":null,"code":"import { endUTF32Pair, minUTF32, startUTF32Pair1, startUTF32Pair2 } from \"./data.js\";\n\n/**\n* Convert string to number\n*/\nfunction getEmojiCodePoint(code) {\n  return parseInt(code, 16);\n}\n/**\n* First part of UTF-32 to UTF-16\n*/\nfunction utf32FirstNum(code) {\n  return (code - minUTF32 >> 10 | 0) + startUTF32Pair1;\n}\n/**\n* First part of UTF-32 to UTF-16\n*/\nfunction utf32SecondNum(code) {\n  return (code - minUTF32 & 1023) + startUTF32Pair2;\n}\n/**\n* Get UTF-32 as UTF-16 sequence\n*/\nfunction splitUTF32Number(code) {\n  if (code >= minUTF32) return [utf32FirstNum(code), utf32SecondNum(code)];\n}\n/**\n* Check if number is UTF-32 split as UTF-16\n*\n* @returns\n* - 1 if number fits first number in sequence\n* - 2 if number fits second number in sequence\n* - false on failure\n*/\nfunction isUTF32SplitNumber(value) {\n  if (value >= startUTF32Pair1) {\n    if (value < startUTF32Pair2) return 1;\n    if (value < endUTF32Pair) return 2;\n  }\n  return false;\n}\n/**\n* Get UTF-16 sequence as UTF-32\n*/\nfunction mergeUTF32Numbers(part1, part2) {\n  if (part1 < startUTF32Pair1 || part1 >= startUTF32Pair2 || part2 < startUTF32Pair2 || part2 >= endUTF32Pair) return;\n  return (part1 - startUTF32Pair1 << 10) + (part2 - startUTF32Pair2) + minUTF32;\n}\n/**\n* Convert hexadecimal string or number to unicode\n*/\nfunction getEmojiUnicode(code) {\n  return String.fromCodePoint(typeof code === \"number\" ? code : getEmojiCodePoint(code));\n}\n/**\n* Convert sequence to UTF-16\n*/\nfunction convertEmojiSequenceToUTF16(numbers) {\n  const results = [];\n  for (let i = 0; i < numbers.length; i++) {\n    const code = numbers[i];\n    if (code >= minUTF32) {\n      results.push(utf32FirstNum(code));\n      results.push(utf32SecondNum(code));\n    } else results.push(code);\n  }\n  return results;\n}\n/**\n* Convert sequence to UTF-32\n*/\nfunction convertEmojiSequenceToUTF32(numbers) {\n  let throwOnError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  const results = [];\n  for (let i = 0; i < numbers.length; i++) {\n    const code = numbers[i];\n    if (code >= minUTF32) {\n      results.push(code);\n      continue;\n    }\n    const part = isUTF32SplitNumber(code);\n    if (!part) {\n      results.push(code);\n      continue;\n    }\n    if (part === 1 && numbers.length > i + 1) {\n      const merged = mergeUTF32Numbers(code, numbers[i + 1]);\n      if (merged) {\n        i++;\n        results.push(merged);\n        continue;\n      }\n    }\n    if (throwOnError) {\n      const nextCode = numbers[i + 1];\n      throw new Error(\"Invalid UTF-16 sequence: \".concat(code.toString(16), \"-\").concat(nextCode ? nextCode.toString(16) : \"undefined\"));\n    }\n    results.push(code);\n  }\n  return results;\n}\nexport { convertEmojiSequenceToUTF16, convertEmojiSequenceToUTF32, getEmojiCodePoint, getEmojiUnicode, isUTF32SplitNumber, mergeUTF32Numbers, splitUTF32Number };","map":{"version":3,"names":["endUTF32Pair","minUTF32","startUTF32Pair1","startUTF32Pair2","getEmojiCodePoint","code","parseInt","utf32FirstNum","utf32SecondNum","splitUTF32Number","isUTF32SplitNumber","value","mergeUTF32Numbers","part1","part2","getEmojiUnicode","String","fromCodePoint","convertEmojiSequenceToUTF16","numbers","results","i","length","push","convertEmojiSequenceToUTF32","throwOnError","arguments","undefined","part","merged","nextCode","Error","concat","toString"],"sources":["/home/saiadmin/k3s-cluster/dashboard/frontend/node_modules/@iconify/utils/lib/emoji/convert.js"],"sourcesContent":["import { endUTF32Pair, minUTF32, startUTF32Pair1, startUTF32Pair2 } from \"./data.js\";\n\n/**\n* Convert string to number\n*/\nfunction getEmojiCodePoint(code) {\n\treturn parseInt(code, 16);\n}\n/**\n* First part of UTF-32 to UTF-16\n*/\nfunction utf32FirstNum(code) {\n\treturn (code - minUTF32 >> 10 | 0) + startUTF32Pair1;\n}\n/**\n* First part of UTF-32 to UTF-16\n*/\nfunction utf32SecondNum(code) {\n\treturn (code - minUTF32 & 1023) + startUTF32Pair2;\n}\n/**\n* Get UTF-32 as UTF-16 sequence\n*/\nfunction splitUTF32Number(code) {\n\tif (code >= minUTF32) return [utf32FirstNum(code), utf32SecondNum(code)];\n}\n/**\n* Check if number is UTF-32 split as UTF-16\n*\n* @returns\n* - 1 if number fits first number in sequence\n* - 2 if number fits second number in sequence\n* - false on failure\n*/\nfunction isUTF32SplitNumber(value) {\n\tif (value >= startUTF32Pair1) {\n\t\tif (value < startUTF32Pair2) return 1;\n\t\tif (value < endUTF32Pair) return 2;\n\t}\n\treturn false;\n}\n/**\n* Get UTF-16 sequence as UTF-32\n*/\nfunction mergeUTF32Numbers(part1, part2) {\n\tif (part1 < startUTF32Pair1 || part1 >= startUTF32Pair2 || part2 < startUTF32Pair2 || part2 >= endUTF32Pair) return;\n\treturn (part1 - startUTF32Pair1 << 10) + (part2 - startUTF32Pair2) + minUTF32;\n}\n/**\n* Convert hexadecimal string or number to unicode\n*/\nfunction getEmojiUnicode(code) {\n\treturn String.fromCodePoint(typeof code === \"number\" ? code : getEmojiCodePoint(code));\n}\n/**\n* Convert sequence to UTF-16\n*/\nfunction convertEmojiSequenceToUTF16(numbers) {\n\tconst results = [];\n\tfor (let i = 0; i < numbers.length; i++) {\n\t\tconst code = numbers[i];\n\t\tif (code >= minUTF32) {\n\t\t\tresults.push(utf32FirstNum(code));\n\t\t\tresults.push(utf32SecondNum(code));\n\t\t} else results.push(code);\n\t}\n\treturn results;\n}\n/**\n* Convert sequence to UTF-32\n*/\nfunction convertEmojiSequenceToUTF32(numbers, throwOnError = true) {\n\tconst results = [];\n\tfor (let i = 0; i < numbers.length; i++) {\n\t\tconst code = numbers[i];\n\t\tif (code >= minUTF32) {\n\t\t\tresults.push(code);\n\t\t\tcontinue;\n\t\t}\n\t\tconst part = isUTF32SplitNumber(code);\n\t\tif (!part) {\n\t\t\tresults.push(code);\n\t\t\tcontinue;\n\t\t}\n\t\tif (part === 1 && numbers.length > i + 1) {\n\t\t\tconst merged = mergeUTF32Numbers(code, numbers[i + 1]);\n\t\t\tif (merged) {\n\t\t\t\ti++;\n\t\t\t\tresults.push(merged);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (throwOnError) {\n\t\t\tconst nextCode = numbers[i + 1];\n\t\t\tthrow new Error(`Invalid UTF-16 sequence: ${code.toString(16)}-${nextCode ? nextCode.toString(16) : \"undefined\"}`);\n\t\t}\n\t\tresults.push(code);\n\t}\n\treturn results;\n}\n\nexport { convertEmojiSequenceToUTF16, convertEmojiSequenceToUTF32, getEmojiCodePoint, getEmojiUnicode, isUTF32SplitNumber, mergeUTF32Numbers, splitUTF32Number };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}