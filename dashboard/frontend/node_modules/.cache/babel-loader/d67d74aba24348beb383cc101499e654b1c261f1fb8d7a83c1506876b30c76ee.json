{"ast":null,"code":"/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n/**\n * Re-export 'TextDocument' from 'vscode-languageserver-textdocument' for convenience,\n *  including both type _and_ symbol (namespace), as we here and there also refer to the symbol,\n *  the overhead is very small, just a few kilobytes.\n * Everything else of that package (at the time contributing) is also defined\n *  in 'vscode-languageserver-protocol' or 'vscode-languageserver-types'.\n */\nexport { TextDocument } from 'vscode-languageserver-textdocument';\nimport { TextDocument } from './documents.js';\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { stream } from '../utils/stream.js';\nimport { URI } from '../utils/uri-utils.js';\n/**\n * A document is subject to several phases that are run in predefined order. Any state value implies that\n * smaller state values are finished as well.\n */\nexport var DocumentState;\n(function (DocumentState) {\n  /**\n   * The text content has changed and needs to be parsed again. The AST held by this outdated\n   * document instance is no longer valid.\n   */\n  DocumentState[DocumentState[\"Changed\"] = 0] = \"Changed\";\n  /**\n   * An AST has been created from the text content. The document structure can be traversed,\n   * but cross-references cannot be resolved yet. If necessary, the structure can be manipulated\n   * at this stage as a preprocessing step.\n   */\n  DocumentState[DocumentState[\"Parsed\"] = 1] = \"Parsed\";\n  /**\n   * The `IndexManager` service has processed AST nodes of this document. This means the\n   * exported symbols are available in the global scope and can be resolved from other documents.\n   */\n  DocumentState[DocumentState[\"IndexedContent\"] = 2] = \"IndexedContent\";\n  /**\n   * The `ScopeComputation` service has processed this document. This means the local symbols\n   * are stored in a MultiMap so they can be looked up by the `ScopeProvider` service.\n   * Once a document has reached this state, you may follow every reference - it will lazily\n   * resolve its `ref` property and yield either the target AST node or `undefined` in case\n   * the target is not in scope.\n   */\n  DocumentState[DocumentState[\"ComputedScopes\"] = 3] = \"ComputedScopes\";\n  /**\n   * The `Linker` service has processed this document. All outgoing references have been\n   * resolved or marked as erroneous.\n   */\n  DocumentState[DocumentState[\"Linked\"] = 4] = \"Linked\";\n  /**\n   * The `IndexManager` service has processed AST node references of this document. This is\n   * necessary to determine which documents are affected by a change in one of the workspace\n   * documents.\n   */\n  DocumentState[DocumentState[\"IndexedReferences\"] = 5] = \"IndexedReferences\";\n  /**\n   * The `DocumentValidator` service has processed this document. The language server listens\n   * to the results of this phase and sends diagnostics to the client.\n   */\n  DocumentState[DocumentState[\"Validated\"] = 6] = \"Validated\";\n})(DocumentState || (DocumentState = {}));\nexport class DefaultLangiumDocumentFactory {\n  constructor(services) {\n    this.serviceRegistry = services.ServiceRegistry;\n    this.textDocuments = services.workspace.TextDocuments;\n    this.fileSystemProvider = services.workspace.FileSystemProvider;\n  }\n  async fromUri(uri) {\n    let cancellationToken = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CancellationToken.None;\n    const content = await this.fileSystemProvider.readFile(uri);\n    return this.createAsync(uri, content, cancellationToken);\n  }\n  fromTextDocument(textDocument, uri, token) {\n    uri = uri !== null && uri !== void 0 ? uri : URI.parse(textDocument.uri);\n    if (CancellationToken.is(token)) {\n      return this.createAsync(uri, textDocument, token);\n    } else {\n      return this.create(uri, textDocument, token);\n    }\n  }\n  fromString(text, uri, token) {\n    if (CancellationToken.is(token)) {\n      return this.createAsync(uri, text, token);\n    } else {\n      return this.create(uri, text, token);\n    }\n  }\n  fromModel(model, uri) {\n    return this.create(uri, {\n      $model: model\n    });\n  }\n  create(uri, content, options) {\n    if (typeof content === 'string') {\n      const parseResult = this.parse(uri, content, options);\n      return this.createLangiumDocument(parseResult, uri, undefined, content);\n    } else if ('$model' in content) {\n      const parseResult = {\n        value: content.$model,\n        parserErrors: [],\n        lexerErrors: []\n      };\n      return this.createLangiumDocument(parseResult, uri);\n    } else {\n      const parseResult = this.parse(uri, content.getText(), options);\n      return this.createLangiumDocument(parseResult, uri, content);\n    }\n  }\n  async createAsync(uri, content, cancelToken) {\n    if (typeof content === 'string') {\n      const parseResult = await this.parseAsync(uri, content, cancelToken);\n      return this.createLangiumDocument(parseResult, uri, undefined, content);\n    } else {\n      const parseResult = await this.parseAsync(uri, content.getText(), cancelToken);\n      return this.createLangiumDocument(parseResult, uri, content);\n    }\n  }\n  /**\n   * Create a LangiumDocument from a given parse result.\n   *\n   * A TextDocument is created on demand if it is not provided as argument here. Usually this\n   * should not be necessary because the main purpose of the TextDocument is to convert between\n   * text ranges and offsets, which is done solely in LSP request handling.\n   *\n   * With the introduction of {@link update} below this method is supposed to be mainly called\n   * during workspace initialization and on addition/recognition of new files, while changes in\n   * existing documents are processed via {@link update}.\n   */\n  createLangiumDocument(parseResult, uri, textDocument, text) {\n    let document;\n    if (textDocument) {\n      document = {\n        parseResult,\n        uri,\n        state: DocumentState.Parsed,\n        references: [],\n        textDocument\n      };\n    } else {\n      const textDocumentGetter = this.createTextDocumentGetter(uri, text);\n      document = {\n        parseResult,\n        uri,\n        state: DocumentState.Parsed,\n        references: [],\n        get textDocument() {\n          return textDocumentGetter();\n        }\n      };\n    }\n    parseResult.value.$document = document;\n    return document;\n  }\n  async update(document, cancellationToken) {\n    var _a, _b;\n    // The CST full text property contains the original text that was used to create the AST.\n    const oldText = (_a = document.parseResult.value.$cstNode) === null || _a === void 0 ? void 0 : _a.root.fullText;\n    const textDocument = (_b = this.textDocuments) === null || _b === void 0 ? void 0 : _b.get(document.uri.toString());\n    const text = textDocument ? textDocument.getText() : await this.fileSystemProvider.readFile(document.uri);\n    if (textDocument) {\n      Object.defineProperty(document, 'textDocument', {\n        value: textDocument\n      });\n    } else {\n      const textDocumentGetter = this.createTextDocumentGetter(document.uri, text);\n      Object.defineProperty(document, 'textDocument', {\n        get: textDocumentGetter\n      });\n    }\n    // Some of these documents can be pretty large, so parsing them again can be quite expensive.\n    // Therefore, we only parse if the text has actually changed.\n    if (oldText !== text) {\n      document.parseResult = await this.parseAsync(document.uri, text, cancellationToken);\n      document.parseResult.value.$document = document;\n    }\n    document.state = DocumentState.Parsed;\n    return document;\n  }\n  parse(uri, text, options) {\n    const services = this.serviceRegistry.getServices(uri);\n    return services.parser.LangiumParser.parse(text, options);\n  }\n  parseAsync(uri, text, cancellationToken) {\n    const services = this.serviceRegistry.getServices(uri);\n    return services.parser.AsyncParser.parse(text, cancellationToken);\n  }\n  createTextDocumentGetter(uri, text) {\n    const serviceRegistry = this.serviceRegistry;\n    let textDoc = undefined;\n    return () => {\n      return textDoc !== null && textDoc !== void 0 ? textDoc : textDoc = TextDocument.create(uri.toString(), serviceRegistry.getServices(uri).LanguageMetaData.languageId, 0, text !== null && text !== void 0 ? text : '');\n    };\n  }\n}\nexport class DefaultLangiumDocuments {\n  constructor(services) {\n    this.documentMap = new Map();\n    this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;\n    this.serviceRegistry = services.ServiceRegistry;\n  }\n  get all() {\n    return stream(this.documentMap.values());\n  }\n  addDocument(document) {\n    const uriString = document.uri.toString();\n    if (this.documentMap.has(uriString)) {\n      throw new Error(\"A document with the URI '\".concat(uriString, \"' is already present.\"));\n    }\n    this.documentMap.set(uriString, document);\n  }\n  getDocument(uri) {\n    const uriString = uri.toString();\n    return this.documentMap.get(uriString);\n  }\n  async getOrCreateDocument(uri, cancellationToken) {\n    let document = this.getDocument(uri);\n    if (document) {\n      return document;\n    }\n    document = await this.langiumDocumentFactory.fromUri(uri, cancellationToken);\n    this.addDocument(document);\n    return document;\n  }\n  createDocument(uri, text, cancellationToken) {\n    if (cancellationToken) {\n      return this.langiumDocumentFactory.fromString(text, uri, cancellationToken).then(document => {\n        this.addDocument(document);\n        return document;\n      });\n    } else {\n      const document = this.langiumDocumentFactory.fromString(text, uri);\n      this.addDocument(document);\n      return document;\n    }\n  }\n  hasDocument(uri) {\n    return this.documentMap.has(uri.toString());\n  }\n  invalidateDocument(uri) {\n    const uriString = uri.toString();\n    const langiumDoc = this.documentMap.get(uriString);\n    if (langiumDoc) {\n      const linker = this.serviceRegistry.getServices(uri).references.Linker;\n      linker.unlink(langiumDoc);\n      langiumDoc.state = DocumentState.Changed;\n      langiumDoc.precomputedScopes = undefined;\n      langiumDoc.diagnostics = undefined;\n    }\n    return langiumDoc;\n  }\n  deleteDocument(uri) {\n    const uriString = uri.toString();\n    const langiumDoc = this.documentMap.get(uriString);\n    if (langiumDoc) {\n      langiumDoc.state = DocumentState.Changed;\n      this.documentMap.delete(uriString);\n    }\n    return langiumDoc;\n  }\n}","map":{"version":3,"names":["TextDocument","CancellationToken","stream","URI","DocumentState","DefaultLangiumDocumentFactory","constructor","services","serviceRegistry","ServiceRegistry","textDocuments","workspace","TextDocuments","fileSystemProvider","FileSystemProvider","fromUri","uri","cancellationToken","arguments","length","undefined","None","content","readFile","createAsync","fromTextDocument","textDocument","token","parse","is","create","fromString","text","fromModel","model","$model","options","parseResult","createLangiumDocument","value","parserErrors","lexerErrors","getText","cancelToken","parseAsync","document","state","Parsed","references","textDocumentGetter","createTextDocumentGetter","$document","update","oldText","_a","$cstNode","root","fullText","_b","get","toString","Object","defineProperty","getServices","parser","LangiumParser","AsyncParser","textDoc","LanguageMetaData","languageId","DefaultLangiumDocuments","documentMap","Map","langiumDocumentFactory","LangiumDocumentFactory","all","values","addDocument","uriString","has","Error","concat","set","getDocument","getOrCreateDocument","createDocument","then","hasDocument","invalidateDocument","langiumDoc","linker","Linker","unlink","Changed","precomputedScopes","diagnostics","deleteDocument","delete"],"sources":["/home/saiadmin/k3s-cluster/dashboard/frontend/node_modules/langium/src/workspace/documents.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\n/**\r\n * Re-export 'TextDocument' from 'vscode-languageserver-textdocument' for convenience,\r\n *  including both type _and_ symbol (namespace), as we here and there also refer to the symbol,\r\n *  the overhead is very small, just a few kilobytes.\r\n * Everything else of that package (at the time contributing) is also defined\r\n *  in 'vscode-languageserver-protocol' or 'vscode-languageserver-types'.\r\n */\r\nexport { TextDocument } from 'vscode-languageserver-textdocument';\r\n\r\nimport type { Diagnostic, Range } from 'vscode-languageserver-types';\r\nimport type { FileSystemProvider } from './file-system-provider.js';\r\nimport type { ParseResult, ParserOptions } from '../parser/langium-parser.js';\r\nimport type { ServiceRegistry } from '../service-registry.js';\r\nimport type { LangiumSharedCoreServices } from '../services.js';\r\nimport type { AstNode, AstNodeDescription, Mutable, Reference } from '../syntax-tree.js';\r\nimport type { MultiMap } from '../utils/collections.js';\r\nimport type { Stream } from '../utils/stream.js';\r\nimport { TextDocument } from './documents.js';\r\nimport { CancellationToken } from '../utils/cancellation.js';\r\nimport { stream } from '../utils/stream.js';\r\nimport { URI } from '../utils/uri-utils.js';\r\n\r\n/**\r\n * A Langium document holds the parse result (AST and CST) and any additional state that is derived\r\n * from the AST, e.g. the result of scope precomputation.\r\n */\r\nexport interface LangiumDocument<T extends AstNode = AstNode> {\r\n    /** The Uniform Resource Identifier (URI) of the document */\r\n    readonly uri: URI;\r\n    /** The text document used to convert between offsets and positions */\r\n    readonly textDocument: TextDocument;\r\n    /** The current state of the document */\r\n    state: DocumentState;\r\n    /** The parse result holds the Abstract Syntax Tree (AST) and potentially also parser / lexer errors */\r\n    parseResult: ParseResult<T>;\r\n    /** Result of the scope precomputation phase */\r\n    precomputedScopes?: PrecomputedScopes;\r\n    /** An array of all cross-references found in the AST while linking */\r\n    references: Reference[];\r\n    /** Result of the validation phase */\r\n    diagnostics?: Diagnostic[]\r\n}\r\n\r\n/**\r\n * A document is subject to several phases that are run in predefined order. Any state value implies that\r\n * smaller state values are finished as well.\r\n */\r\nexport enum DocumentState {\r\n    /**\r\n     * The text content has changed and needs to be parsed again. The AST held by this outdated\r\n     * document instance is no longer valid.\r\n     */\r\n    Changed = 0,\r\n    /**\r\n     * An AST has been created from the text content. The document structure can be traversed,\r\n     * but cross-references cannot be resolved yet. If necessary, the structure can be manipulated\r\n     * at this stage as a preprocessing step.\r\n     */\r\n    Parsed = 1,\r\n    /**\r\n     * The `IndexManager` service has processed AST nodes of this document. This means the\r\n     * exported symbols are available in the global scope and can be resolved from other documents.\r\n     */\r\n    IndexedContent = 2,\r\n    /**\r\n     * The `ScopeComputation` service has processed this document. This means the local symbols\r\n     * are stored in a MultiMap so they can be looked up by the `ScopeProvider` service.\r\n     * Once a document has reached this state, you may follow every reference - it will lazily\r\n     * resolve its `ref` property and yield either the target AST node or `undefined` in case\r\n     * the target is not in scope.\r\n     */\r\n    ComputedScopes = 3,\r\n    /**\r\n     * The `Linker` service has processed this document. All outgoing references have been\r\n     * resolved or marked as erroneous.\r\n     */\r\n    Linked = 4,\r\n    /**\r\n     * The `IndexManager` service has processed AST node references of this document. This is\r\n     * necessary to determine which documents are affected by a change in one of the workspace\r\n     * documents.\r\n     */\r\n    IndexedReferences = 5,\r\n    /**\r\n     * The `DocumentValidator` service has processed this document. The language server listens\r\n     * to the results of this phase and sends diagnostics to the client.\r\n     */\r\n    Validated = 6\r\n}\r\n\r\n/**\r\n * Result of the scope precomputation phase (`ScopeComputation` service).\r\n * It maps every AST node to the set of symbols that are visible in the subtree of that node.\r\n */\r\nexport type PrecomputedScopes = MultiMap<AstNode, AstNodeDescription>\r\n\r\nexport interface DocumentSegment {\r\n    readonly range: Range\r\n    readonly offset: number\r\n    readonly length: number\r\n    readonly end: number\r\n}\r\n\r\n/**\r\n * Surrogate definition of the `TextDocuments` interface from the `vscode-languageserver` package.\r\n * No implementation object is expected to be offered by `LangiumCoreServices`, but only by `LangiumLSPServices`.\r\n */\r\nexport type TextDocumentProvider = {\r\n    get(uri: string | URI): TextDocument | undefined\r\n}\r\n\r\n/**\r\n * Shared service for creating `LangiumDocument` instances.\r\n *\r\n * Register a custom implementation if special (additional) behavior is required for your language(s).\r\n * Note: If you specialize {@link fromString} or {@link fromTextDocument} you probably might want to\r\n * specialize {@link update}, too!\r\n */\r\nexport interface LangiumDocumentFactory {\r\n    /**\r\n     * Create a Langium document from a `TextDocument` (usually associated with a file).\r\n     */\r\n    fromTextDocument<T extends AstNode = AstNode>(textDocument: TextDocument, uri?: URI, options?: ParserOptions): LangiumDocument<T>;\r\n    /**\r\n     * Create a Langium document from a `TextDocument` asynchronously. This action can be cancelled if a cancellable parser implementation has been provided.\r\n     */\r\n    fromTextDocument<T extends AstNode = AstNode>(textDocument: TextDocument, uri: URI | undefined, cancellationToken: CancellationToken): Promise<LangiumDocument<T>>;\r\n\r\n    /**\r\n     * Create an Langium document from an in-memory string.\r\n     */\r\n    fromString<T extends AstNode = AstNode>(text: string, uri: URI, options?: ParserOptions): LangiumDocument<T>;\r\n    /**\r\n     * Create a Langium document from an in-memory string asynchronously. This action can be cancelled if a cancellable parser implementation has been provided.\r\n     */\r\n    fromString<T extends AstNode = AstNode>(text: string, uri: URI, cancellationToken: CancellationToken): Promise<LangiumDocument<T>>;\r\n\r\n    /**\r\n     * Create an Langium document from a model that has been constructed in memory.\r\n     */\r\n    fromModel<T extends AstNode = AstNode>(model: T, uri: URI): LangiumDocument<T>;\r\n\r\n    /**\r\n     * Create an Langium document from a specified `URI`. The factory will use the `FileSystemAccess` service to read the file.\r\n     */\r\n    fromUri<T extends AstNode = AstNode>(uri: URI, cancellationToken?: CancellationToken): Promise<LangiumDocument<T>>;\r\n\r\n    /**\r\n     * Update the given document after changes in the corresponding textual representation.\r\n     * Method is called by the document builder after it has been requested to build an existing\r\n     * document and the document's state is {@link DocumentState.Changed}.\r\n     * The text parsing is expected to be done the same way as in {@link fromTextDocument}\r\n     * and {@link fromString}.\r\n     */\r\n    update<T extends AstNode = AstNode>(document: LangiumDocument<T>, cancellationToken: CancellationToken): Promise<LangiumDocument<T>>\r\n}\r\n\r\nexport class DefaultLangiumDocumentFactory implements LangiumDocumentFactory {\r\n\r\n    protected readonly serviceRegistry: ServiceRegistry;\r\n    protected readonly textDocuments?: TextDocumentProvider;\r\n    protected readonly fileSystemProvider: FileSystemProvider;\r\n\r\n    constructor(services: LangiumSharedCoreServices) {\r\n        this.serviceRegistry = services.ServiceRegistry;\r\n        this.textDocuments = services.workspace.TextDocuments;\r\n        this.fileSystemProvider = services.workspace.FileSystemProvider;\r\n    }\r\n\r\n    async fromUri<T extends AstNode = AstNode>(uri: URI, cancellationToken = CancellationToken.None): Promise<LangiumDocument<T>> {\r\n        const content = await this.fileSystemProvider.readFile(uri);\r\n        return this.createAsync<T>(uri, content, cancellationToken);\r\n    }\r\n\r\n    fromTextDocument<T extends AstNode = AstNode>(textDocument: TextDocument, uri?: URI, options?: ParserOptions): LangiumDocument<T>;\r\n    fromTextDocument<T extends AstNode = AstNode>(textDocument: TextDocument, uri: URI | undefined, cancellationToken: CancellationToken): Promise<LangiumDocument<T>>;\r\n    fromTextDocument<T extends AstNode = AstNode>(textDocument: TextDocument, uri?: URI, token?: CancellationToken | ParserOptions): LangiumDocument<T> | Promise<LangiumDocument<T>> {\r\n        uri = uri ?? URI.parse(textDocument.uri);\r\n        if (CancellationToken.is(token)) {\r\n            return this.createAsync<T>(uri, textDocument, token);\r\n        } else {\r\n            return this.create<T>(uri, textDocument, token);\r\n        }\r\n    }\r\n\r\n    fromString<T extends AstNode = AstNode>(text: string, uri: URI, options?: ParserOptions): LangiumDocument<T>;\r\n    fromString<T extends AstNode = AstNode>(text: string, uri: URI, cancellationToken: CancellationToken): Promise<LangiumDocument<T>>;\r\n    fromString<T extends AstNode = AstNode>(text: string, uri: URI, token?: CancellationToken | ParserOptions): LangiumDocument<T> | Promise<LangiumDocument<T>> {\r\n        if (CancellationToken.is(token)) {\r\n            return this.createAsync<T>(uri, text, token);\r\n        } else {\r\n            return this.create<T>(uri, text, token);\r\n        }\r\n    }\r\n\r\n    fromModel<T extends AstNode = AstNode>(model: T, uri: URI): LangiumDocument<T> {\r\n        return this.create<T>(uri, { $model: model });\r\n    }\r\n\r\n    protected create<T extends AstNode = AstNode>(uri: URI, content: string | TextDocument | { $model: T }, options?: ParserOptions): LangiumDocument<T> {\r\n        if (typeof content === 'string') {\r\n            const parseResult = this.parse<T>(uri, content, options);\r\n            return this.createLangiumDocument<T>(parseResult, uri, undefined, content);\r\n\r\n        } else if ('$model' in content) {\r\n            const parseResult = { value: content.$model, parserErrors: [], lexerErrors: [] };\r\n            return this.createLangiumDocument<T>(parseResult, uri);\r\n\r\n        } else {\r\n            const parseResult = this.parse<T>(uri, content.getText(), options);\r\n            return this.createLangiumDocument(parseResult, uri, content);\r\n        }\r\n    }\r\n\r\n    protected async createAsync<T extends AstNode = AstNode>(uri: URI, content: string | TextDocument, cancelToken: CancellationToken): Promise<LangiumDocument<T>> {\r\n        if (typeof content === 'string') {\r\n            const parseResult = await this.parseAsync<T>(uri, content, cancelToken);\r\n            return this.createLangiumDocument<T>(parseResult, uri, undefined, content);\r\n        } else {\r\n            const parseResult = await this.parseAsync<T>(uri, content.getText(), cancelToken);\r\n            return this.createLangiumDocument(parseResult, uri, content);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a LangiumDocument from a given parse result.\r\n     *\r\n     * A TextDocument is created on demand if it is not provided as argument here. Usually this\r\n     * should not be necessary because the main purpose of the TextDocument is to convert between\r\n     * text ranges and offsets, which is done solely in LSP request handling.\r\n     *\r\n     * With the introduction of {@link update} below this method is supposed to be mainly called\r\n     * during workspace initialization and on addition/recognition of new files, while changes in\r\n     * existing documents are processed via {@link update}.\r\n     */\r\n    protected createLangiumDocument<T extends AstNode = AstNode>(parseResult: ParseResult<T>, uri: URI, textDocument?: TextDocument, text?: string): LangiumDocument<T> {\r\n        let document: LangiumDocument<T>;\r\n        if (textDocument) {\r\n            document = {\r\n                parseResult,\r\n                uri,\r\n                state: DocumentState.Parsed,\r\n                references: [],\r\n                textDocument\r\n            };\r\n        } else {\r\n            const textDocumentGetter = this.createTextDocumentGetter(uri, text);\r\n            document = {\r\n                parseResult,\r\n                uri,\r\n                state: DocumentState.Parsed,\r\n                references: [],\r\n                get textDocument() {\r\n                    return textDocumentGetter();\r\n                }\r\n            };\r\n        }\r\n        (parseResult.value as Mutable<AstNode>).$document = document;\r\n        return document;\r\n    }\r\n\r\n    async update<T extends AstNode = AstNode>(document: Mutable<LangiumDocument<T>>, cancellationToken: CancellationToken): Promise<LangiumDocument<T>> {\r\n        // The CST full text property contains the original text that was used to create the AST.\r\n        const oldText = document.parseResult.value.$cstNode?.root.fullText;\r\n        const textDocument = this.textDocuments?.get(document.uri.toString());\r\n        const text = textDocument ? textDocument.getText() : await this.fileSystemProvider.readFile(document.uri);\r\n\r\n        if (textDocument) {\r\n            Object.defineProperty(\r\n                document,\r\n                'textDocument',\r\n                {\r\n                    value: textDocument\r\n                }\r\n            );\r\n        } else {\r\n            const textDocumentGetter = this.createTextDocumentGetter(document.uri, text);\r\n            Object.defineProperty(\r\n                document,\r\n                'textDocument',\r\n                {\r\n                    get: textDocumentGetter\r\n                }\r\n            );\r\n        }\r\n\r\n        // Some of these documents can be pretty large, so parsing them again can be quite expensive.\r\n        // Therefore, we only parse if the text has actually changed.\r\n        if (oldText !== text) {\r\n            document.parseResult = await this.parseAsync(document.uri, text, cancellationToken);\r\n            (document.parseResult.value as Mutable<AstNode>).$document = document;\r\n        }\r\n        document.state = DocumentState.Parsed;\r\n        return document;\r\n    }\r\n\r\n    protected parse<T extends AstNode>(uri: URI, text: string, options?: ParserOptions): ParseResult<T> {\r\n        const services = this.serviceRegistry.getServices(uri);\r\n        return services.parser.LangiumParser.parse<T>(text, options);\r\n    }\r\n\r\n    protected parseAsync<T extends AstNode>(uri: URI, text: string, cancellationToken: CancellationToken): Promise<ParseResult<T>> {\r\n        const services = this.serviceRegistry.getServices(uri);\r\n        return services.parser.AsyncParser.parse<T>(text, cancellationToken);\r\n    }\r\n\r\n    protected createTextDocumentGetter(uri: URI, text?: string): () => TextDocument {\r\n        const serviceRegistry = this.serviceRegistry;\r\n        let textDoc: TextDocument | undefined = undefined;\r\n        return () => {\r\n            return textDoc ??= TextDocument.create(\r\n                uri.toString(), serviceRegistry.getServices(uri).LanguageMetaData.languageId, 0, text ?? ''\r\n            );\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Shared service for managing Langium documents.\r\n */\r\nexport interface LangiumDocuments {\r\n\r\n    /**\r\n     * A stream of all documents managed under this service.\r\n     */\r\n    readonly all: Stream<LangiumDocument>\r\n\r\n    /**\r\n     * Manage a new document under this service.\r\n     * @throws an error if a document with the same URI is already present.\r\n     */\r\n    addDocument(document: LangiumDocument): void;\r\n\r\n    /**\r\n     * Retrieve the document with the given URI, if present. Otherwise returns `undefined`.\r\n     */\r\n    getDocument(uri: URI): LangiumDocument | undefined;\r\n\r\n    /**\r\n     * Retrieve the document with the given URI. If not present, a new one will be created using the file system access.\r\n     * The new document will be added to the list of documents managed under this service.\r\n     */\r\n    getOrCreateDocument(uri: URI, cancellationToken?: CancellationToken): Promise<LangiumDocument>;\r\n\r\n    /**\r\n     * Creates a new document with the given URI and text content.\r\n     * The new document is automatically added to this service and can be retrieved using {@link getDocument}.\r\n     *\r\n     * @throws an error if a document with the same URI is already present.\r\n     */\r\n    createDocument(uri: URI, text: string): LangiumDocument;\r\n\r\n    /**\r\n     * Creates a new document with the given URI and text content asynchronously.\r\n     * The process can be interrupted with a cancellation token.\r\n     * The new document is automatically added to this service and can be retrieved using {@link getDocument}.\r\n     *\r\n     * @throws an error if a document with the same URI is already present.\r\n     */\r\n    createDocument(uri: URI, text: string, cancellationToken: CancellationToken): Promise<LangiumDocument>;\r\n\r\n    /**\r\n     * Returns `true` if a document with the given URI is managed under this service.\r\n     */\r\n    hasDocument(uri: URI): boolean;\r\n\r\n    /**\r\n     * Flag the document with the given URI as `Changed`, if present, meaning that its content\r\n     * is no longer valid. The content (parseResult) stays untouched, while internal data may\r\n     * be dropped to reduce memory footprint.\r\n     *\r\n     * @returns the affected {@link LangiumDocument} if existing for convenience\r\n     */\r\n    invalidateDocument(uri: URI): LangiumDocument | undefined;\r\n\r\n    /**\r\n     * Remove the document with the given URI, if present, and mark it as `Changed`, meaning\r\n     * that its content is no longer valid. The next call to `getOrCreateDocument` with the same\r\n     * URI will create a new document instance.\r\n     *\r\n     * @returns the affected {@link LangiumDocument} if existing for convenience\r\n     */\r\n    deleteDocument(uri: URI): LangiumDocument | undefined;\r\n}\r\n\r\nexport class DefaultLangiumDocuments implements LangiumDocuments {\r\n\r\n    protected readonly langiumDocumentFactory: LangiumDocumentFactory;\r\n    protected readonly serviceRegistry: ServiceRegistry;\r\n\r\n    protected readonly documentMap: Map<string, LangiumDocument> = new Map();\r\n\r\n    constructor(services: LangiumSharedCoreServices) {\r\n        this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;\r\n        this.serviceRegistry = services.ServiceRegistry;\r\n    }\r\n\r\n    get all(): Stream<LangiumDocument> {\r\n        return stream(this.documentMap.values());\r\n    }\r\n\r\n    addDocument(document: LangiumDocument): void {\r\n        const uriString = document.uri.toString();\r\n        if (this.documentMap.has(uriString)) {\r\n            throw new Error(`A document with the URI '${uriString}' is already present.`);\r\n        }\r\n        this.documentMap.set(uriString, document);\r\n    }\r\n\r\n    getDocument(uri: URI): LangiumDocument | undefined {\r\n        const uriString = uri.toString();\r\n        return this.documentMap.get(uriString);\r\n    }\r\n\r\n    async getOrCreateDocument(uri: URI, cancellationToken?: CancellationToken): Promise<LangiumDocument> {\r\n        let document = this.getDocument(uri);\r\n        if (document) {\r\n            return document;\r\n        }\r\n        document = await this.langiumDocumentFactory.fromUri(uri, cancellationToken);\r\n        this.addDocument(document);\r\n        return document;\r\n    }\r\n\r\n    createDocument(uri: URI, text: string): LangiumDocument;\r\n    createDocument(uri: URI, text: string, cancellationToken: CancellationToken): Promise<LangiumDocument>;\r\n    createDocument(uri: URI, text: string, cancellationToken?: CancellationToken): LangiumDocument | Promise<LangiumDocument> {\r\n        if (cancellationToken) {\r\n            return this.langiumDocumentFactory.fromString(text, uri, cancellationToken).then(document => {\r\n                this.addDocument(document);\r\n                return document;\r\n            });\r\n        } else {\r\n            const document = this.langiumDocumentFactory.fromString(text, uri);\r\n            this.addDocument(document);\r\n            return document;\r\n        }\r\n    }\r\n\r\n    hasDocument(uri: URI): boolean {\r\n        return this.documentMap.has(uri.toString());\r\n    }\r\n\r\n    invalidateDocument(uri: URI): LangiumDocument | undefined {\r\n        const uriString = uri.toString();\r\n        const langiumDoc = this.documentMap.get(uriString);\r\n        if (langiumDoc) {\r\n            const linker = this.serviceRegistry.getServices(uri).references.Linker;\r\n            linker.unlink(langiumDoc);\r\n            langiumDoc.state = DocumentState.Changed;\r\n            langiumDoc.precomputedScopes = undefined;\r\n            langiumDoc.diagnostics = undefined;\r\n        }\r\n        return langiumDoc;\r\n    }\r\n\r\n    deleteDocument(uri: URI): LangiumDocument | undefined {\r\n        const uriString = uri.toString();\r\n        const langiumDoc = this.documentMap.get(uriString);\r\n        if (langiumDoc) {\r\n            langiumDoc.state = DocumentState.Changed;\r\n            this.documentMap.delete(uriString);\r\n        }\r\n        return langiumDoc;\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}