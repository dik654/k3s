{"ast":null,"code":"/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { isAstNode, isAstNodeDescription, isLinkingError } from '../syntax-tree.js';\nimport { findRootNode, streamAst, streamReferences } from '../utils/ast-utils.js';\nimport { interruptAndCheck } from '../utils/promise-utils.js';\nimport { DocumentState } from '../workspace/documents.js';\nconst ref_resolving = Symbol('ref_resolving');\nexport class DefaultLinker {\n  constructor(services) {\n    this.reflection = services.shared.AstReflection;\n    this.langiumDocuments = () => services.shared.workspace.LangiumDocuments;\n    this.scopeProvider = services.references.ScopeProvider;\n    this.astNodeLocator = services.workspace.AstNodeLocator;\n  }\n  async link(document) {\n    let cancelToken = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CancellationToken.None;\n    for (const node of streamAst(document.parseResult.value)) {\n      await interruptAndCheck(cancelToken);\n      streamReferences(node).forEach(ref => this.doLink(ref, document));\n    }\n  }\n  doLink(refInfo, document) {\n    var _a;\n    const ref = refInfo.reference;\n    // The reference may already have been resolved lazily by accessing its `ref` property.\n    if (ref._ref === undefined) {\n      ref._ref = ref_resolving;\n      try {\n        const description = this.getCandidate(refInfo);\n        if (isLinkingError(description)) {\n          ref._ref = description;\n        } else {\n          ref._nodeDescription = description;\n          if (this.langiumDocuments().hasDocument(description.documentUri)) {\n            // The target document is already loaded\n            const linkedNode = this.loadAstNode(description);\n            ref._ref = linkedNode !== null && linkedNode !== void 0 ? linkedNode : this.createLinkingError(refInfo, description);\n          } else {\n            // Try to load the target AST node later using the already provided description\n            ref._ref = undefined;\n          }\n        }\n      } catch (err) {\n        console.error(\"An error occurred while resolving reference to '\".concat(ref.$refText, \"':\"), err);\n        const errorMessage = (_a = err.message) !== null && _a !== void 0 ? _a : String(err);\n        ref._ref = Object.assign(Object.assign({}, refInfo), {\n          message: \"An error occurred while resolving reference to '\".concat(ref.$refText, \"': \").concat(errorMessage)\n        });\n      }\n      // Add the reference to the document's array of references\n      // Only add if the reference has been not been resolved earlier\n      // Otherwise we end up with duplicates\n      // See also implementation of `buildReference`\n      document.references.push(ref);\n    }\n  }\n  unlink(document) {\n    for (const ref of document.references) {\n      delete ref._ref;\n      delete ref._nodeDescription;\n    }\n    document.references = [];\n  }\n  getCandidate(refInfo) {\n    const scope = this.scopeProvider.getScope(refInfo);\n    const description = scope.getElement(refInfo.reference.$refText);\n    return description !== null && description !== void 0 ? description : this.createLinkingError(refInfo);\n  }\n  buildReference(node, property, refNode, refText) {\n    // See behavior description in doc of Linker, update that on changes in here.\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const linker = this;\n    const reference = {\n      $refNode: refNode,\n      $refText: refText,\n      get ref() {\n        var _a;\n        if (isAstNode(this._ref)) {\n          // Most frequent case: the target is already resolved.\n          return this._ref;\n        } else if (isAstNodeDescription(this._nodeDescription)) {\n          // A candidate has been found before, but it is not loaded yet.\n          const linkedNode = linker.loadAstNode(this._nodeDescription);\n          this._ref = linkedNode !== null && linkedNode !== void 0 ? linkedNode : linker.createLinkingError({\n            reference,\n            container: node,\n            property\n          }, this._nodeDescription);\n        } else if (this._ref === undefined) {\n          // The reference has not been linked yet, so do that now.\n          this._ref = ref_resolving;\n          const document = findRootNode(node).$document;\n          const refData = linker.getLinkedNode({\n            reference,\n            container: node,\n            property\n          });\n          if (refData.error && document && document.state < DocumentState.ComputedScopes) {\n            // Document scope is not ready, don't set `this._ref` so linker can retry later.\n            return this._ref = undefined;\n          }\n          this._ref = (_a = refData.node) !== null && _a !== void 0 ? _a : refData.error;\n          this._nodeDescription = refData.descr;\n          document === null || document === void 0 ? void 0 : document.references.push(this);\n        } else if (this._ref === ref_resolving) {\n          throw new Error(\"Cyclic reference resolution detected: \".concat(linker.astNodeLocator.getAstNodePath(node), \"/\").concat(property, \" (symbol '\").concat(refText, \"')\"));\n        }\n        return isAstNode(this._ref) ? this._ref : undefined;\n      },\n      get $nodeDescription() {\n        return this._nodeDescription;\n      },\n      get error() {\n        return isLinkingError(this._ref) ? this._ref : undefined;\n      }\n    };\n    return reference;\n  }\n  getLinkedNode(refInfo) {\n    var _a;\n    try {\n      const description = this.getCandidate(refInfo);\n      if (isLinkingError(description)) {\n        return {\n          error: description\n        };\n      }\n      const linkedNode = this.loadAstNode(description);\n      if (linkedNode) {\n        return {\n          node: linkedNode,\n          descr: description\n        };\n      } else {\n        return {\n          descr: description,\n          error: this.createLinkingError(refInfo, description)\n        };\n      }\n    } catch (err) {\n      console.error(\"An error occurred while resolving reference to '\".concat(refInfo.reference.$refText, \"':\"), err);\n      const errorMessage = (_a = err.message) !== null && _a !== void 0 ? _a : String(err);\n      return {\n        error: Object.assign(Object.assign({}, refInfo), {\n          message: \"An error occurred while resolving reference to '\".concat(refInfo.reference.$refText, \"': \").concat(errorMessage)\n        })\n      };\n    }\n  }\n  loadAstNode(nodeDescription) {\n    if (nodeDescription.node) {\n      return nodeDescription.node;\n    }\n    const doc = this.langiumDocuments().getDocument(nodeDescription.documentUri);\n    if (!doc) {\n      return undefined;\n    }\n    return this.astNodeLocator.getAstNode(doc.parseResult.value, nodeDescription.path);\n  }\n  createLinkingError(refInfo, targetDescription) {\n    // Check whether the document is sufficiently processed by the DocumentBuilder. If not, this is a hint for a bug\n    // in the language implementation.\n    const document = findRootNode(refInfo.container).$document;\n    if (document && document.state < DocumentState.ComputedScopes) {\n      console.warn(\"Attempted reference resolution before document reached ComputedScopes state (\".concat(document.uri, \").\"));\n    }\n    const referenceType = this.reflection.getReferenceType(refInfo);\n    return Object.assign(Object.assign({}, refInfo), {\n      message: \"Could not resolve reference to \".concat(referenceType, \" named '\").concat(refInfo.reference.$refText, \"'.\"),\n      targetDescription\n    });\n  }\n}","map":{"version":3,"names":["CancellationToken","isAstNode","isAstNodeDescription","isLinkingError","findRootNode","streamAst","streamReferences","interruptAndCheck","DocumentState","ref_resolving","Symbol","DefaultLinker","constructor","services","reflection","shared","AstReflection","langiumDocuments","workspace","LangiumDocuments","scopeProvider","references","ScopeProvider","astNodeLocator","AstNodeLocator","link","document","cancelToken","arguments","length","undefined","None","node","parseResult","value","forEach","ref","doLink","refInfo","reference","_ref","description","getCandidate","_nodeDescription","hasDocument","documentUri","linkedNode","loadAstNode","createLinkingError","err","console","error","concat","$refText","errorMessage","_a","message","String","Object","assign","push","unlink","scope","getScope","getElement","buildReference","property","refNode","refText","linker","$refNode","container","$document","refData","getLinkedNode","state","ComputedScopes","descr","Error","getAstNodePath","$nodeDescription","nodeDescription","doc","getDocument","getAstNode","path","targetDescription","warn","uri","referenceType","getReferenceType"],"sources":["/home/saiadmin/k3s-cluster/dashboard/frontend/node_modules/langium/src/references/linker.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { LangiumCoreServices } from '../services.js';\r\nimport type { AstNode, AstNodeDescription, AstReflection, CstNode, LinkingError, Reference, ReferenceInfo } from '../syntax-tree.js';\r\nimport type { AstNodeLocator } from '../workspace/ast-node-locator.js';\r\nimport type { LangiumDocument, LangiumDocuments } from '../workspace/documents.js';\r\nimport type { ScopeProvider } from './scope-provider.js';\r\nimport { CancellationToken } from '../utils/cancellation.js';\r\nimport { isAstNode, isAstNodeDescription, isLinkingError } from '../syntax-tree.js';\r\nimport { findRootNode, streamAst, streamReferences } from '../utils/ast-utils.js';\r\nimport { interruptAndCheck } from '../utils/promise-utils.js';\r\nimport { DocumentState } from '../workspace/documents.js';\r\n\r\n/**\r\n * Language-specific service for resolving cross-references in the AST.\r\n */\r\nexport interface Linker {\r\n\r\n    /**\r\n     * Links all cross-references within the specified document. The default implementation loads only target\r\n     * elements from documents that are present in the `LangiumDocuments` service. The linked references are\r\n     * stored in the document's `references` property.\r\n     *\r\n     * @param document A LangiumDocument that shall be linked.\r\n     * @param cancelToken A token for cancelling the operation.\r\n     *\r\n     * @throws `OperationCancelled` if a cancellation event is detected\r\n     */\r\n    link(document: LangiumDocument, cancelToken?: CancellationToken): Promise<void>;\r\n\r\n    /**\r\n     * Unlinks all references within the specified document and removes them from the list of `references`.\r\n     *\r\n     * @param document A LangiumDocument that shall be unlinked.\r\n     */\r\n    unlink(document: LangiumDocument): void;\r\n\r\n    /**\r\n     * Determines a candidate AST node description for linking the given reference.\r\n     *\r\n     * @param refInfo Information about the reference.\r\n     */\r\n    getCandidate(refInfo: ReferenceInfo): AstNodeDescription | LinkingError;\r\n\r\n    /**\r\n     * Creates a cross reference node being aware of its containing AstNode, the corresponding CstNode,\r\n     * the cross reference text denoting the target AstNode being already extracted of the document text,\r\n     * as well as the unique cross reference identifier.\r\n     *\r\n     * Default behavior:\r\n     *  - The returned Reference's 'ref' property pointing to the target AstNode is populated lazily on its\r\n     *    first visit.\r\n     *  - If the target AstNode cannot be resolved on the first visit, an error indicator will be installed\r\n     *    and further resolution attempts will *not* be performed.\r\n     *\r\n     * @param node The containing AST node\r\n     * @param property The AST node property being referenced\r\n     * @param refNode The corresponding CST node\r\n     * @param refText The cross reference text denoting the target AstNode\r\n     * @returns the desired Reference node, whose behavior wrt. resolving the cross reference is implementation specific.\r\n     */\r\n    buildReference(node: AstNode, property: string, refNode: CstNode | undefined, refText: string): Reference;\r\n\r\n}\r\n\r\nconst ref_resolving = Symbol('ref_resolving');\r\n\r\ninterface DefaultReference extends Reference {\r\n    _ref?: AstNode | LinkingError | typeof ref_resolving;\r\n    _nodeDescription?: AstNodeDescription;\r\n}\r\n\r\nexport class DefaultLinker implements Linker {\r\n    protected readonly reflection: AstReflection;\r\n    protected readonly scopeProvider: ScopeProvider;\r\n    protected readonly astNodeLocator: AstNodeLocator;\r\n    protected readonly langiumDocuments: () => LangiumDocuments;\r\n\r\n    constructor(services: LangiumCoreServices) {\r\n        this.reflection = services.shared.AstReflection;\r\n        this.langiumDocuments = () => services.shared.workspace.LangiumDocuments;\r\n        this.scopeProvider = services.references.ScopeProvider;\r\n        this.astNodeLocator = services.workspace.AstNodeLocator;\r\n    }\r\n\r\n    async link(document: LangiumDocument, cancelToken = CancellationToken.None): Promise<void> {\r\n        for (const node of streamAst(document.parseResult.value)) {\r\n            await interruptAndCheck(cancelToken);\r\n            streamReferences(node).forEach(ref => this.doLink(ref, document));\r\n        }\r\n    }\r\n\r\n    protected doLink(refInfo: ReferenceInfo, document: LangiumDocument): void {\r\n        const ref = refInfo.reference as DefaultReference;\r\n        // The reference may already have been resolved lazily by accessing its `ref` property.\r\n        if (ref._ref === undefined) {\r\n            ref._ref = ref_resolving;\r\n            try {\r\n                const description = this.getCandidate(refInfo);\r\n                if (isLinkingError(description)) {\r\n                    ref._ref = description;\r\n                } else {\r\n                    ref._nodeDescription = description;\r\n                    if (this.langiumDocuments().hasDocument(description.documentUri)) {\r\n                        // The target document is already loaded\r\n                        const linkedNode = this.loadAstNode(description);\r\n                        ref._ref = linkedNode ?? this.createLinkingError(refInfo, description);\r\n                    } else {\r\n                        // Try to load the target AST node later using the already provided description\r\n                        ref._ref = undefined;\r\n                    }\r\n                }\r\n            } catch (err) {\r\n                console.error(`An error occurred while resolving reference to '${ref.$refText}':`, err);\r\n                const errorMessage = (err as Error).message ?? String(err);\r\n                ref._ref = {\r\n                    ...refInfo,\r\n                    message: `An error occurred while resolving reference to '${ref.$refText}': ${errorMessage}`\r\n                };\r\n            }\r\n            // Add the reference to the document's array of references\r\n            // Only add if the reference has been not been resolved earlier\r\n            // Otherwise we end up with duplicates\r\n            // See also implementation of `buildReference`\r\n            document.references.push(ref);\r\n        }\r\n    }\r\n\r\n    unlink(document: LangiumDocument): void {\r\n        for (const ref of document.references) {\r\n            delete (ref as DefaultReference)._ref;\r\n            delete (ref as DefaultReference)._nodeDescription;\r\n        }\r\n        document.references = [];\r\n    }\r\n\r\n    getCandidate(refInfo: ReferenceInfo): AstNodeDescription | LinkingError {\r\n        const scope = this.scopeProvider.getScope(refInfo);\r\n        const description = scope.getElement(refInfo.reference.$refText);\r\n        return description ?? this.createLinkingError(refInfo);\r\n    }\r\n\r\n    buildReference(node: AstNode, property: string, refNode: CstNode | undefined, refText: string): Reference {\r\n        // See behavior description in doc of Linker, update that on changes in here.\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const linker = this;\r\n        const reference: DefaultReference = {\r\n            $refNode: refNode,\r\n            $refText: refText,\r\n\r\n            get ref() {\r\n                if (isAstNode(this._ref)) {\r\n                    // Most frequent case: the target is already resolved.\r\n                    return this._ref;\r\n                } else if (isAstNodeDescription(this._nodeDescription)) {\r\n                    // A candidate has been found before, but it is not loaded yet.\r\n                    const linkedNode = linker.loadAstNode(this._nodeDescription);\r\n                    this._ref = linkedNode ??\r\n                        linker.createLinkingError({ reference, container: node, property }, this._nodeDescription);\r\n                } else if (this._ref === undefined) {\r\n                    // The reference has not been linked yet, so do that now.\r\n                    this._ref = ref_resolving;\r\n                    const document = findRootNode(node).$document;\r\n                    const refData = linker.getLinkedNode({ reference, container: node, property });\r\n                    if (refData.error && document && document.state < DocumentState.ComputedScopes) {\r\n                        // Document scope is not ready, don't set `this._ref` so linker can retry later.\r\n                        return this._ref = undefined;\r\n                    }\r\n                    this._ref = refData.node ?? refData.error;\r\n                    this._nodeDescription = refData.descr;\r\n                    document?.references.push(this);\r\n                } else if (this._ref === ref_resolving) {\r\n                    throw new Error(`Cyclic reference resolution detected: ${linker.astNodeLocator.getAstNodePath(node)}/${property} (symbol '${refText}')`);\r\n                }\r\n                return isAstNode(this._ref) ? this._ref : undefined;\r\n            },\r\n            get $nodeDescription() {\r\n                return this._nodeDescription;\r\n            },\r\n            get error() {\r\n                return isLinkingError(this._ref) ? this._ref : undefined;\r\n            }\r\n        };\r\n        return reference;\r\n    }\r\n\r\n    protected getLinkedNode(refInfo: ReferenceInfo): { node?: AstNode, descr?: AstNodeDescription, error?: LinkingError } {\r\n        try {\r\n            const description = this.getCandidate(refInfo);\r\n            if (isLinkingError(description)) {\r\n                return { error: description };\r\n            }\r\n            const linkedNode = this.loadAstNode(description);\r\n            if (linkedNode) {\r\n                return { node: linkedNode, descr: description };\r\n            }\r\n            else {\r\n                return {\r\n                    descr: description,\r\n                    error:\r\n                        this.createLinkingError(refInfo, description)\r\n                };\r\n            }\r\n        } catch (err) {\r\n            console.error(`An error occurred while resolving reference to '${refInfo.reference.$refText}':`, err);\r\n            const errorMessage = (err as Error).message ?? String(err);\r\n            return {\r\n                error: {\r\n                    ...refInfo,\r\n                    message: `An error occurred while resolving reference to '${refInfo.reference.$refText}': ${errorMessage}`\r\n                }\r\n            };\r\n        }\r\n    }\r\n\r\n    protected loadAstNode(nodeDescription: AstNodeDescription): AstNode | undefined {\r\n        if (nodeDescription.node) {\r\n            return nodeDescription.node;\r\n        }\r\n        const doc = this.langiumDocuments().getDocument(nodeDescription.documentUri);\r\n        if (!doc) {\r\n            return undefined;\r\n        }\r\n        return this.astNodeLocator.getAstNode(doc.parseResult.value, nodeDescription.path);\r\n    }\r\n\r\n    protected createLinkingError(refInfo: ReferenceInfo, targetDescription?: AstNodeDescription): LinkingError {\r\n        // Check whether the document is sufficiently processed by the DocumentBuilder. If not, this is a hint for a bug\r\n        // in the language implementation.\r\n        const document = findRootNode(refInfo.container).$document;\r\n        if (document && document.state < DocumentState.ComputedScopes) {\r\n            console.warn(`Attempted reference resolution before document reached ComputedScopes state (${document.uri}).`);\r\n        }\r\n        const referenceType = this.reflection.getReferenceType(refInfo);\r\n        return {\r\n            ...refInfo,\r\n            message: `Could not resolve reference to ${referenceType} named '${refInfo.reference.$refText}'.`,\r\n            targetDescription\r\n        };\r\n    }\r\n\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}