{"ast":null,"code":"/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { isCompositeCstNode, isLeafCstNode, isRootCstNode } from '../syntax-tree.js';\nimport { TreeStreamImpl } from './stream.js';\n/**\n * Create a stream of all CST nodes that are directly and indirectly contained in the given root node,\n * including the root node itself.\n */\nexport function streamCst(node) {\n  return new TreeStreamImpl(node, element => {\n    if (isCompositeCstNode(element)) {\n      return element.content;\n    } else {\n      return [];\n    }\n  }, {\n    includeRoot: true\n  });\n}\n/**\n * Create a stream of all leaf nodes that are directly and indirectly contained in the given root node.\n */\nexport function flattenCst(node) {\n  return streamCst(node).filter(isLeafCstNode);\n}\n/**\n * Determines whether the specified cst node is a child of the specified parent node.\n */\nexport function isChildNode(child, parent) {\n  while (child.container) {\n    child = child.container;\n    if (child === parent) {\n      return true;\n    }\n  }\n  return false;\n}\nexport function tokenToRange(token) {\n  // Chevrotain uses 1-based indices everywhere\n  // So we subtract 1 from every value to align with the LSP\n  return {\n    start: {\n      character: token.startColumn - 1,\n      line: token.startLine - 1\n    },\n    end: {\n      character: token.endColumn,\n      // endColumn uses the correct index\n      line: token.endLine - 1\n    }\n  };\n}\nexport function toDocumentSegment(node) {\n  if (!node) {\n    return undefined;\n  }\n  const {\n    offset,\n    end,\n    range\n  } = node;\n  return {\n    range,\n    offset,\n    end,\n    length: end - offset\n  };\n}\nexport var RangeComparison;\n(function (RangeComparison) {\n  RangeComparison[RangeComparison[\"Before\"] = 0] = \"Before\";\n  RangeComparison[RangeComparison[\"After\"] = 1] = \"After\";\n  RangeComparison[RangeComparison[\"OverlapFront\"] = 2] = \"OverlapFront\";\n  RangeComparison[RangeComparison[\"OverlapBack\"] = 3] = \"OverlapBack\";\n  RangeComparison[RangeComparison[\"Inside\"] = 4] = \"Inside\";\n  RangeComparison[RangeComparison[\"Outside\"] = 5] = \"Outside\";\n})(RangeComparison || (RangeComparison = {}));\nexport function compareRange(range, to) {\n  if (range.end.line < to.start.line || range.end.line === to.start.line && range.end.character <= to.start.character) {\n    return RangeComparison.Before;\n  } else if (range.start.line > to.end.line || range.start.line === to.end.line && range.start.character >= to.end.character) {\n    return RangeComparison.After;\n  }\n  const startInside = range.start.line > to.start.line || range.start.line === to.start.line && range.start.character >= to.start.character;\n  const endInside = range.end.line < to.end.line || range.end.line === to.end.line && range.end.character <= to.end.character;\n  if (startInside && endInside) {\n    return RangeComparison.Inside;\n  } else if (startInside) {\n    return RangeComparison.OverlapBack;\n  } else if (endInside) {\n    return RangeComparison.OverlapFront;\n  } else {\n    return RangeComparison.Outside;\n  }\n}\nexport function inRange(range, to) {\n  const comparison = compareRange(range, to);\n  return comparison > RangeComparison.After;\n}\n// The \\p{L} regex matches any unicode letter character, i.e. characters from non-english alphabets\n// Together with \\w it matches any kind of character which can commonly appear in IDs\nexport const DefaultNameRegexp = /^(?:[0-9A-Z_a-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088F\\u08A0-\\u08C9\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C5C\\u0C5D\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDC-\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16F1-\\u16F8\\u1700-\\u1711\\u171F-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1878\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4C\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C8A\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7DC\\uA7F1-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF2D-\\uDF40\\uDF42-\\uDF49\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDD70-\\uDD7A\\uDD7C-\\uDD8A\\uDD8C-\\uDD92\\uDD94\\uDD95\\uDD97-\\uDDA1\\uDDA3-\\uDDB1\\uDDB3-\\uDDB9\\uDDBB\\uDDBC\\uDDC0-\\uDDF3\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67\\uDF80-\\uDF85\\uDF87-\\uDFB0\\uDFB2-\\uDFBA]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD40-\\uDD59\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD23\\uDD4A-\\uDD65\\uDD6F-\\uDD85\\uDE80-\\uDEA9\\uDEB0\\uDEB1\\uDEC2-\\uDEC7\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF45\\uDF70-\\uDF81\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC03-\\uDC37\\uDC71\\uDC72\\uDC75\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD44\\uDD47\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE3F\\uDE40\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61\\uDF80-\\uDF89\\uDF8B\\uDF8E\\uDF90-\\uDFB5\\uDFB7\\uDFD1\\uDFD3]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC5F-\\uDC61\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDEB8\\uDF00-\\uDF1A\\uDF40-\\uDF46]|\\uD806[\\uDC00-\\uDC2B\\uDCA0-\\uDCDF\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD2F\\uDD3F\\uDD41\\uDDA0-\\uDDA7\\uDDAA-\\uDDD0\\uDDE1\\uDDE3\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE89\\uDE9D\\uDEB0-\\uDEF8\\uDFC0-\\uDFE0]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD89\\uDD98\\uDDB0-\\uDDDB\\uDEE0-\\uDEF2\\uDF02\\uDF04-\\uDF10\\uDF12-\\uDF33\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC80-\\uDD43]|\\uD80B[\\uDF90-\\uDFF0]|[\\uD80C\\uD80E\\uD80F\\uD81C-\\uD822\\uD840-\\uD868\\uD86A-\\uD86D\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883\\uD885-\\uD88C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2F\\uDC41-\\uDC46\\uDC60-\\uDFFF]|\\uD810[\\uDC00-\\uDFFA]|\\uD811[\\uDC00-\\uDE46]|\\uD818[\\uDD00-\\uDD1D]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE70-\\uDEBE\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDD40-\\uDD6C\\uDE40-\\uDE7F\\uDEA0-\\uDEB8\\uDEBB-\\uDED3\\uDF00-\\uDF4A\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1\\uDFE3\\uDFF2\\uDFF3]|\\uD823[\\uDC00-\\uDCD5\\uDCFF-\\uDD1E\\uDD80-\\uDDF2]|\\uD82B[\\uDFF0-\\uDFF3\\uDFF5-\\uDFFB\\uDFFD\\uDFFE]|\\uD82C[\\uDC00-\\uDD22\\uDD32\\uDD50-\\uDD52\\uDD55\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD837[\\uDF00-\\uDF1E\\uDF25-\\uDF2A]|\\uD838[\\uDC30-\\uDC6D\\uDD00-\\uDD2C\\uDD37-\\uDD3D\\uDD4E\\uDE90-\\uDEAD\\uDEC0-\\uDEEB]|\\uD839[\\uDCD0-\\uDCEB\\uDDD0-\\uDDED\\uDDF0\\uDEC0-\\uDEDE\\uDEE0-\\uDEE2\\uDEE4\\uDEE5\\uDEE7-\\uDEED\\uDEF0-\\uDEF4\\uDEFE\\uDEFF\\uDFE0-\\uDFE6\\uDFE8-\\uDFEB\\uDFED\\uDFEE\\uDFF0-\\uDFFE]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43\\uDD4B]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDEDF\\uDF00-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEAD\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0\\uDFF0-\\uDFFF]|\\uD87B[\\uDC00-\\uDE5D]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A\\uDF50-\\uDFFF]|\\uD88D[\\uDC00-\\uDC79])$/;\n/**\n * Performs `findLeafNodeAtOffset` with a minor difference: When encountering a character that matches the `nameRegexp` argument,\n * it will instead return the leaf node at the `offset - 1` position.\n *\n * For LSP services, users expect that the declaration of an element is available if the cursor is directly after the element.\n */\nexport function findDeclarationNodeAtOffset(cstNode, offset) {\n  let nameRegexp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DefaultNameRegexp;\n  if (cstNode) {\n    if (offset > 0) {\n      const localOffset = offset - cstNode.offset;\n      const textAtOffset = cstNode.text.charAt(localOffset);\n      if (!nameRegexp.test(textAtOffset)) {\n        offset--;\n      }\n    }\n    return findLeafNodeAtOffset(cstNode, offset);\n  }\n  return undefined;\n}\nexport function findCommentNode(cstNode, commentNames) {\n  if (cstNode) {\n    const previous = getPreviousNode(cstNode, true);\n    if (previous && isCommentNode(previous, commentNames)) {\n      return previous;\n    }\n    if (isRootCstNode(cstNode)) {\n      // Go from the first non-hidden node through all nodes in reverse order\n      // We do this to find the comment node which directly precedes the root node\n      const endIndex = cstNode.content.findIndex(e => !e.hidden);\n      for (let i = endIndex - 1; i >= 0; i--) {\n        const child = cstNode.content[i];\n        if (isCommentNode(child, commentNames)) {\n          return child;\n        }\n      }\n    }\n  }\n  return undefined;\n}\nexport function isCommentNode(cstNode, commentNames) {\n  return isLeafCstNode(cstNode) && commentNames.includes(cstNode.tokenType.name);\n}\n/**\n * Finds the leaf CST node at the specified 0-based string offset.\n * Note that the given offset will be within the range of the returned leaf node.\n *\n * If the offset does not point to a CST node (but just white space), this method will return `undefined`.\n *\n * @param node The CST node to search through.\n * @param offset The specified offset.\n * @returns The CST node at the specified offset.\n */\nexport function findLeafNodeAtOffset(node, offset) {\n  if (isLeafCstNode(node)) {\n    return node;\n  } else if (isCompositeCstNode(node)) {\n    const searchResult = binarySearch(node, offset, false);\n    if (searchResult) {\n      return findLeafNodeAtOffset(searchResult, offset);\n    }\n  }\n  return undefined;\n}\n/**\n * Finds the leaf CST node at the specified 0-based string offset.\n * If no CST node exists at the specified position, it will return the leaf node before it.\n *\n * If there is no leaf node before the specified offset, this method will return `undefined`.\n *\n * @param node The CST node to search through.\n * @param offset The specified offset.\n * @returns The CST node closest to the specified offset.\n */\nexport function findLeafNodeBeforeOffset(node, offset) {\n  if (isLeafCstNode(node)) {\n    return node;\n  } else if (isCompositeCstNode(node)) {\n    const searchResult = binarySearch(node, offset, true);\n    if (searchResult) {\n      return findLeafNodeBeforeOffset(searchResult, offset);\n    }\n  }\n  return undefined;\n}\nfunction binarySearch(node, offset, closest) {\n  let left = 0;\n  let right = node.content.length - 1;\n  let closestNode = undefined;\n  while (left <= right) {\n    const middle = Math.floor((left + right) / 2);\n    const middleNode = node.content[middle];\n    if (middleNode.offset <= offset && middleNode.end > offset) {\n      // Found an exact match\n      return middleNode;\n    }\n    if (middleNode.end <= offset) {\n      // Update the closest node (less than offset) and move to the right half\n      closestNode = closest ? middleNode : undefined;\n      left = middle + 1;\n    } else {\n      // Move to the left half\n      right = middle - 1;\n    }\n  }\n  return closestNode;\n}\nexport function getPreviousNode(node) {\n  let hidden = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  while (node.container) {\n    const parent = node.container;\n    let index = parent.content.indexOf(node);\n    while (index > 0) {\n      index--;\n      const previous = parent.content[index];\n      if (hidden || !previous.hidden) {\n        return previous;\n      }\n    }\n    node = parent;\n  }\n  return undefined;\n}\nexport function getNextNode(node) {\n  let hidden = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  while (node.container) {\n    const parent = node.container;\n    let index = parent.content.indexOf(node);\n    const last = parent.content.length - 1;\n    while (index < last) {\n      index++;\n      const next = parent.content[index];\n      if (hidden || !next.hidden) {\n        return next;\n      }\n    }\n    node = parent;\n  }\n  return undefined;\n}\nexport function getStartlineNode(node) {\n  if (node.range.start.character === 0) {\n    return node;\n  }\n  const line = node.range.start.line;\n  let last = node;\n  let index;\n  while (node.container) {\n    const parent = node.container;\n    const selfIndex = index !== null && index !== void 0 ? index : parent.content.indexOf(node);\n    if (selfIndex === 0) {\n      node = parent;\n      index = undefined;\n    } else {\n      index = selfIndex - 1;\n      node = parent.content[index];\n    }\n    if (node.range.start.line !== line) {\n      break;\n    }\n    last = node;\n  }\n  return last;\n}\nexport function getInteriorNodes(start, end) {\n  const commonParent = getCommonParent(start, end);\n  if (!commonParent) {\n    return [];\n  }\n  return commonParent.parent.content.slice(commonParent.a + 1, commonParent.b);\n}\nfunction getCommonParent(a, b) {\n  const aParents = getParentChain(a);\n  const bParents = getParentChain(b);\n  let current;\n  for (let i = 0; i < aParents.length && i < bParents.length; i++) {\n    const aParent = aParents[i];\n    const bParent = bParents[i];\n    if (aParent.parent === bParent.parent) {\n      current = {\n        parent: aParent.parent,\n        a: aParent.index,\n        b: bParent.index\n      };\n    } else {\n      break;\n    }\n  }\n  return current;\n}\nfunction getParentChain(node) {\n  const chain = [];\n  while (node.container) {\n    const parent = node.container;\n    const index = parent.content.indexOf(node);\n    chain.push({\n      parent,\n      index\n    });\n    node = parent;\n  }\n  return chain.reverse();\n}","map":{"version":3,"names":["isCompositeCstNode","isLeafCstNode","isRootCstNode","TreeStreamImpl","streamCst","node","element","content","includeRoot","flattenCst","filter","isChildNode","child","parent","container","tokenToRange","token","start","character","startColumn","line","startLine","end","endColumn","endLine","toDocumentSegment","undefined","offset","range","length","RangeComparison","compareRange","to","Before","After","startInside","endInside","Inside","OverlapBack","OverlapFront","Outside","inRange","comparison","DefaultNameRegexp","findDeclarationNodeAtOffset","cstNode","nameRegexp","arguments","localOffset","textAtOffset","text","charAt","test","findLeafNodeAtOffset","findCommentNode","commentNames","previous","getPreviousNode","isCommentNode","endIndex","findIndex","e","hidden","i","includes","tokenType","name","searchResult","binarySearch","findLeafNodeBeforeOffset","closest","left","right","closestNode","middle","Math","floor","middleNode","index","indexOf","getNextNode","last","next","getStartlineNode","selfIndex","getInteriorNodes","commonParent","getCommonParent","slice","a","b","aParents","getParentChain","bParents","current","aParent","bParent","chain","push","reverse"],"sources":["/home/saiadmin/k3s-cluster/dashboard/frontend/node_modules/langium/src/utils/cst-utils.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { IToken } from '@chevrotain/types';\r\nimport type { Range } from 'vscode-languageserver-types';\r\nimport type { CstNode, CompositeCstNode, LeafCstNode } from '../syntax-tree.js';\r\nimport type { DocumentSegment } from '../workspace/documents.js';\r\nimport type { Stream, TreeStream } from './stream.js';\r\nimport { isCompositeCstNode, isLeafCstNode, isRootCstNode } from '../syntax-tree.js';\r\nimport { TreeStreamImpl } from './stream.js';\r\n\r\n/**\r\n * Create a stream of all CST nodes that are directly and indirectly contained in the given root node,\r\n * including the root node itself.\r\n */\r\nexport function streamCst(node: CstNode): TreeStream<CstNode> {\r\n    return new TreeStreamImpl(node, element => {\r\n        if (isCompositeCstNode(element)) {\r\n            return element.content;\r\n        } else {\r\n            return [];\r\n        }\r\n    }, { includeRoot: true });\r\n}\r\n\r\n/**\r\n * Create a stream of all leaf nodes that are directly and indirectly contained in the given root node.\r\n */\r\nexport function flattenCst(node: CstNode): Stream<LeafCstNode> {\r\n    return streamCst(node).filter(isLeafCstNode);\r\n}\r\n\r\n/**\r\n * Determines whether the specified cst node is a child of the specified parent node.\r\n */\r\nexport function isChildNode(child: CstNode, parent: CstNode): boolean {\r\n    while (child.container) {\r\n        child = child.container;\r\n        if (child === parent) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nexport function tokenToRange(token: IToken): Range {\r\n    // Chevrotain uses 1-based indices everywhere\r\n    // So we subtract 1 from every value to align with the LSP\r\n    return {\r\n        start: {\r\n            character: token.startColumn! - 1,\r\n            line: token.startLine! - 1\r\n        },\r\n        end: {\r\n            character: token.endColumn!, // endColumn uses the correct index\r\n            line: token.endLine! - 1\r\n        }\r\n    };\r\n}\r\n\r\nexport function toDocumentSegment(node: CstNode): DocumentSegment;\r\nexport function toDocumentSegment(node?: CstNode): DocumentSegment | undefined;\r\nexport function toDocumentSegment(node?: CstNode): DocumentSegment | undefined {\r\n    if (!node) {\r\n        return undefined;\r\n    }\r\n    const { offset, end, range } = node;\r\n    return {\r\n        range,\r\n        offset,\r\n        end,\r\n        length: end - offset\r\n    };\r\n}\r\n\r\nexport enum RangeComparison {\r\n    Before = 0,\r\n    After = 1,\r\n    OverlapFront = 2,\r\n    OverlapBack = 3,\r\n    Inside = 4,\r\n    Outside = 5,\r\n}\r\n\r\nexport function compareRange(range: Range, to: Range): RangeComparison {\r\n    if (range.end.line < to.start.line || (range.end.line === to.start.line && range.end.character <= to.start.character)) {\r\n        return RangeComparison.Before;\r\n    } else if (range.start.line > to.end.line || (range.start.line === to.end.line && range.start.character >= to.end.character)) {\r\n        return RangeComparison.After;\r\n    }\r\n    const startInside = range.start.line > to.start.line || (range.start.line === to.start.line && range.start.character >= to.start.character);\r\n    const endInside = range.end.line < to.end.line || (range.end.line === to.end.line && range.end.character <= to.end.character);\r\n    if (startInside && endInside) {\r\n        return RangeComparison.Inside;\r\n    } else if (startInside) {\r\n        return RangeComparison.OverlapBack;\r\n    } else if (endInside) {\r\n        return RangeComparison.OverlapFront;\r\n    } else {\r\n        return RangeComparison.Outside;\r\n    }\r\n}\r\n\r\nexport function inRange(range: Range, to: Range): boolean {\r\n    const comparison = compareRange(range, to);\r\n    return comparison > RangeComparison.After;\r\n}\r\n\r\n// The \\p{L} regex matches any unicode letter character, i.e. characters from non-english alphabets\r\n// Together with \\w it matches any kind of character which can commonly appear in IDs\r\nexport const DefaultNameRegexp = /^[\\w\\p{L}]$/u;\r\n\r\n/**\r\n * Performs `findLeafNodeAtOffset` with a minor difference: When encountering a character that matches the `nameRegexp` argument,\r\n * it will instead return the leaf node at the `offset - 1` position.\r\n *\r\n * For LSP services, users expect that the declaration of an element is available if the cursor is directly after the element.\r\n */\r\nexport function findDeclarationNodeAtOffset(cstNode: CstNode | undefined, offset: number, nameRegexp = DefaultNameRegexp): LeafCstNode | undefined {\r\n    if (cstNode) {\r\n        if (offset > 0) {\r\n            const localOffset = offset - cstNode.offset;\r\n            const textAtOffset = cstNode.text.charAt(localOffset);\r\n            if (!nameRegexp.test(textAtOffset)) {\r\n                offset--;\r\n            }\r\n        }\r\n        return findLeafNodeAtOffset(cstNode, offset);\r\n    }\r\n    return undefined;\r\n}\r\n\r\nexport function findCommentNode(cstNode: CstNode | undefined, commentNames: string[]): CstNode | undefined {\r\n    if (cstNode) {\r\n        const previous = getPreviousNode(cstNode, true);\r\n        if (previous && isCommentNode(previous, commentNames)) {\r\n            return previous;\r\n        }\r\n        if (isRootCstNode(cstNode)) {\r\n            // Go from the first non-hidden node through all nodes in reverse order\r\n            // We do this to find the comment node which directly precedes the root node\r\n            const endIndex = cstNode.content.findIndex(e => !e.hidden);\r\n            for (let i = endIndex - 1; i >= 0; i--) {\r\n                const child = cstNode.content[i];\r\n                if (isCommentNode(child, commentNames)) {\r\n                    return child;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\nexport function isCommentNode(cstNode: CstNode, commentNames: string[]): boolean {\r\n    return isLeafCstNode(cstNode) && commentNames.includes(cstNode.tokenType.name);\r\n}\r\n\r\n/**\r\n * Finds the leaf CST node at the specified 0-based string offset.\r\n * Note that the given offset will be within the range of the returned leaf node.\r\n *\r\n * If the offset does not point to a CST node (but just white space), this method will return `undefined`.\r\n *\r\n * @param node The CST node to search through.\r\n * @param offset The specified offset.\r\n * @returns The CST node at the specified offset.\r\n */\r\nexport function findLeafNodeAtOffset(node: CstNode, offset: number): LeafCstNode | undefined {\r\n    if (isLeafCstNode(node)) {\r\n        return node;\r\n    } else if (isCompositeCstNode(node)) {\r\n        const searchResult = binarySearch(node, offset, false);\r\n        if (searchResult) {\r\n            return findLeafNodeAtOffset(searchResult, offset);\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * Finds the leaf CST node at the specified 0-based string offset.\r\n * If no CST node exists at the specified position, it will return the leaf node before it.\r\n *\r\n * If there is no leaf node before the specified offset, this method will return `undefined`.\r\n *\r\n * @param node The CST node to search through.\r\n * @param offset The specified offset.\r\n * @returns The CST node closest to the specified offset.\r\n */\r\nexport function findLeafNodeBeforeOffset(node: CstNode, offset: number): LeafCstNode | undefined {\r\n    if (isLeafCstNode(node)) {\r\n        return node;\r\n    } else if (isCompositeCstNode(node)) {\r\n        const searchResult = binarySearch(node, offset, true);\r\n        if (searchResult) {\r\n            return findLeafNodeBeforeOffset(searchResult, offset);\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\nfunction binarySearch(node: CompositeCstNode, offset: number, closest: boolean): CstNode | undefined {\r\n    let left = 0;\r\n    let right = node.content.length - 1;\r\n    let closestNode: CstNode | undefined = undefined;\r\n\r\n    while (left <= right) {\r\n        const middle = Math.floor((left + right) / 2);\r\n        const middleNode = node.content[middle];\r\n\r\n        if (middleNode.offset <= offset && middleNode.end > offset) {\r\n            // Found an exact match\r\n            return middleNode;\r\n        }\r\n\r\n        if (middleNode.end <= offset) {\r\n            // Update the closest node (less than offset) and move to the right half\r\n            closestNode = closest ? middleNode : undefined;\r\n            left = middle + 1;\r\n        } else {\r\n            // Move to the left half\r\n            right = middle - 1;\r\n        }\r\n    }\r\n\r\n    return closestNode;\r\n}\r\n\r\nexport function getPreviousNode(node: CstNode, hidden = true): CstNode | undefined {\r\n    while (node.container) {\r\n        const parent = node.container;\r\n        let index = parent.content.indexOf(node);\r\n        while (index > 0) {\r\n            index--;\r\n            const previous = parent.content[index];\r\n            if (hidden || !previous.hidden) {\r\n                return previous;\r\n            }\r\n        }\r\n        node = parent;\r\n    }\r\n    return undefined;\r\n}\r\n\r\nexport function getNextNode(node: CstNode, hidden = true): CstNode | undefined {\r\n    while (node.container) {\r\n        const parent = node.container;\r\n        let index = parent.content.indexOf(node);\r\n        const last = parent.content.length - 1;\r\n        while (index < last) {\r\n            index++;\r\n            const next = parent.content[index];\r\n            if (hidden || !next.hidden) {\r\n                return next;\r\n            }\r\n        }\r\n        node = parent;\r\n    }\r\n    return undefined;\r\n}\r\n\r\nexport function getStartlineNode(node: CstNode): CstNode {\r\n    if (node.range.start.character === 0) {\r\n        return node;\r\n    }\r\n    const line = node.range.start.line;\r\n    let last = node;\r\n    let index: number | undefined;\r\n    while (node.container) {\r\n        const parent = node.container;\r\n        const selfIndex = index ?? parent.content.indexOf(node);\r\n        if (selfIndex === 0) {\r\n            node = parent;\r\n            index = undefined;\r\n        } else {\r\n            index = selfIndex - 1;\r\n            node = parent.content[index];\r\n        }\r\n        if (node.range.start.line !== line) {\r\n            break;\r\n        }\r\n        last = node;\r\n    }\r\n    return last;\r\n}\r\n\r\nexport function getInteriorNodes(start: CstNode, end: CstNode): CstNode[] {\r\n    const commonParent = getCommonParent(start, end);\r\n    if (!commonParent) {\r\n        return [];\r\n    }\r\n    return commonParent.parent.content.slice(commonParent.a + 1, commonParent.b);\r\n}\r\n\r\nfunction getCommonParent(a: CstNode, b: CstNode): CommonParent | undefined {\r\n    const aParents = getParentChain(a);\r\n    const bParents = getParentChain(b);\r\n    let current: CommonParent | undefined;\r\n    for (let i = 0; i < aParents.length && i < bParents.length; i++) {\r\n        const aParent = aParents[i];\r\n        const bParent = bParents[i];\r\n        if (aParent.parent === bParent.parent) {\r\n            current = {\r\n                parent: aParent.parent,\r\n                a: aParent.index,\r\n                b: bParent.index\r\n            };\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    return current;\r\n}\r\n\r\ninterface CommonParent {\r\n    parent: CompositeCstNode\r\n    a: number\r\n    b: number\r\n}\r\n\r\nfunction getParentChain(node: CstNode): ParentLink[] {\r\n    const chain: ParentLink[] = [];\r\n    while (node.container) {\r\n        const parent = node.container;\r\n        const index = parent.content.indexOf(node);\r\n        chain.push({\r\n            parent,\r\n            index\r\n        });\r\n        node = parent;\r\n    }\r\n    return chain.reverse();\r\n}\r\n\r\ninterface ParentLink {\r\n    parent: CompositeCstNode\r\n    index: number\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}