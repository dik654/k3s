{"ast":null,"code":"import { cloneEmojiRegexItem, createOptionalEmojiRegexItem, createSequenceEmojiRegexItem, createSetEmojiRegexItem } from \"./base.js\";\nimport { optimiseNumbersSet } from \"./numbers.js\";\n\n/**\n* Typescript stuff\n*/\nfunction assertNever(v) {}\n/**\n* Find similar item sequences\n*\n* Returns sequence(s) with highest score. Only one of results should be\n* applied to items. If there are multiple sequences, clone items list,\n* attempt to apply each sequence, run further optimisations on each fork\n* and see which one returns better result.\n*\n* Returns undefined if no common sequences found\n*/\nfunction findSimilarRegexItemSequences(items) {\n  const startRegex = Object.create(null);\n  const endRegex = Object.create(null);\n  const addMapItem = (target, index, regex, slice) => {\n    if (!target[regex]) {\n      target[regex] = {\n        score: 0,\n        slices: [{\n          index,\n          slice\n        }]\n      };\n      return;\n    }\n    const item = target[regex];\n    item.score += regex.length;\n    item.slices.push({\n      index,\n      slice\n    });\n  };\n  for (let index = 0; index < items.length; index++) {\n    const baseItem = items[index];\n    switch (baseItem.type) {\n      case \"optional\":\n      case \"utf16\":\n        addMapItem(startRegex, index, baseItem.regex, \"full\");\n        addMapItem(endRegex, index, baseItem.regex, \"full\");\n        break;\n      case \"sequence\":\n        {\n          addMapItem(startRegex, index, baseItem.regex, \"full\");\n          addMapItem(endRegex, index, baseItem.regex, \"full\");\n          const sequence = baseItem.items;\n          for (let i = 1; i < sequence.length; i++) {\n            const startSequence = createSequenceEmojiRegexItem(sequence.slice(0, i));\n            addMapItem(startRegex, index, startSequence.regex, i);\n            const endSequence = createSequenceEmojiRegexItem(sequence.slice(i));\n            addMapItem(endRegex, index, endSequence.regex, i);\n          }\n          break;\n        }\n      case \"set\":\n        throw new Error(\"Unexpected set within a set\");\n      default:\n        assertNever(baseItem);\n    }\n  }\n  let result;\n  const checkResults = (target, type) => {\n    for (const regex in target) {\n      const item = target[regex];\n      if (!item.score) continue;\n      if (!result || result.score < item.score) {\n        result = {\n          score: item.score,\n          sequences: [{\n            type,\n            slices: item.slices\n          }]\n        };\n        continue;\n      }\n      if (result.score === item.score) result.sequences.push({\n        type,\n        slices: item.slices\n      });\n    }\n  };\n  checkResults(startRegex, \"start\");\n  checkResults(endRegex, \"end\");\n  return result;\n}\n/**\n* Merge similar sequences\n*\n* Accepts callback to run optimisation on created subset\n*/\nfunction mergeSimilarRegexItemSequences(items, merge, optimise) {\n  const {\n    type,\n    slices\n  } = merge;\n  const indexes = /* @__PURE__ */new Set();\n  let hasFullSequence = false;\n  let longestMatch = 0;\n  let longestMatchIndex = -1;\n  const differentSequences = [];\n  for (let i = 0; i < slices.length; i++) {\n    const {\n      index,\n      slice\n    } = slices[i];\n    const item = items[index];\n    let length;\n    if (slice === \"full\") {\n      hasFullSequence = true;\n      if (item.type === \"sequence\") length = item.items.length;else length = 1;\n    } else {\n      if (item.type !== \"sequence\") throw new Error(\"Unexpected partial match for type \\\"\".concat(item.type, \"\\\"\"));\n      length = type === \"start\" ? slice : item.items.length - slice;\n      differentSequences.push(type === \"start\" ? item.items.slice(slice) : item.items.slice(0, slice));\n    }\n    if (length > longestMatch) {\n      longestMatchIndex = index;\n      longestMatch = length;\n    }\n    indexes.add(index);\n  }\n  if (longestMatch < 1 || longestMatchIndex < 0) throw new Error(\"Cannot find common sequence\");\n  const commonItem = items[longestMatchIndex];\n  let sequence;\n  if (commonItem.type !== \"sequence\") {\n    if (longestMatch !== 1) throw new Error(\"Something went wrong. Cannot have long match in non-sequence\");\n    sequence = [commonItem];\n  } else sequence = type === \"start\" ? commonItem.items.slice(0, longestMatch) : commonItem.items.slice(commonItem.items.length - longestMatch);\n  const setItems = [];\n  for (let i = 0; i < differentSequences.length; i++) {\n    const list = differentSequences[i];\n    if (list.length === 1) setItems.push(list[0]);else setItems.push(createSequenceEmojiRegexItem(list));\n  }\n  const set = createSetEmojiRegexItem(setItems);\n  let mergedChunk = set.sets.length === 1 ? set.sets[0] : optimise ? optimise(set) : set;\n  if (hasFullSequence) mergedChunk = createOptionalEmojiRegexItem(mergedChunk);\n  sequence[type === \"start\" ? \"push\" : \"unshift\"](mergedChunk);\n  return [createSequenceEmojiRegexItem(sequence), ...items.filter((item, index) => !indexes.has(index))];\n}\n/**\n* Merge similar items\n*/\nfunction mergeSimilarItemsInSet(set) {\n  const updatedSet = optimiseNumbersSet(set);\n  if (updatedSet.type !== \"set\") return updatedSet;\n  set = updatedSet;\n  let merges;\n  while (merges = findSimilarRegexItemSequences(set.sets)) {\n    const sequences = merges.sequences;\n    if (sequences.length === 1) {\n      const merged = mergeSimilarRegexItemSequences(set.sets.map(item => cloneEmojiRegexItem(item, true)), sequences[0], mergeSimilarItemsInSet);\n      if (merged.length === 1) return merged[0];\n      set = createSetEmojiRegexItem(merged);\n      continue;\n    }\n    let newItem;\n    for (let i = 0; i < sequences.length; i++) {\n      const merged = mergeSimilarRegexItemSequences(set.sets.map(item => cloneEmojiRegexItem(item, true)), sequences[i], mergeSimilarItemsInSet);\n      const mergedItem = merged.length === 1 ? merged[0] : createSetEmojiRegexItem(merged);\n      if (!newItem || mergedItem.regex.length < newItem.regex.length) newItem = mergedItem;\n    }\n    if (!newItem) throw new Error(\"Empty sequences list\");\n    if (newItem.type !== \"set\") return newItem;\n    set = newItem;\n  }\n  return set;\n}\nexport { findSimilarRegexItemSequences, mergeSimilarItemsInSet, mergeSimilarRegexItemSequences };","map":{"version":3,"names":["cloneEmojiRegexItem","createOptionalEmojiRegexItem","createSequenceEmojiRegexItem","createSetEmojiRegexItem","optimiseNumbersSet","assertNever","v","findSimilarRegexItemSequences","items","startRegex","Object","create","endRegex","addMapItem","target","index","regex","slice","score","slices","item","length","push","baseItem","type","sequence","i","startSequence","endSequence","Error","result","checkResults","sequences","mergeSimilarRegexItemSequences","merge","optimise","indexes","Set","hasFullSequence","longestMatch","longestMatchIndex","differentSequences","concat","add","commonItem","setItems","list","set","mergedChunk","sets","filter","has","mergeSimilarItemsInSet","updatedSet","merges","merged","map","newItem","mergedItem"],"sources":["/home/saiadmin/k3s-cluster/dashboard/frontend/node_modules/@iconify/utils/lib/emoji/regex/similar.js"],"sourcesContent":["import { cloneEmojiRegexItem, createOptionalEmojiRegexItem, createSequenceEmojiRegexItem, createSetEmojiRegexItem } from \"./base.js\";\nimport { optimiseNumbersSet } from \"./numbers.js\";\n\n/**\n* Typescript stuff\n*/\nfunction assertNever(v) {}\n/**\n* Find similar item sequences\n*\n* Returns sequence(s) with highest score. Only one of results should be\n* applied to items. If there are multiple sequences, clone items list,\n* attempt to apply each sequence, run further optimisations on each fork\n* and see which one returns better result.\n*\n* Returns undefined if no common sequences found\n*/\nfunction findSimilarRegexItemSequences(items) {\n\tconst startRegex = Object.create(null);\n\tconst endRegex = Object.create(null);\n\tconst addMapItem = (target, index, regex, slice) => {\n\t\tif (!target[regex]) {\n\t\t\ttarget[regex] = {\n\t\t\t\tscore: 0,\n\t\t\t\tslices: [{\n\t\t\t\t\tindex,\n\t\t\t\t\tslice\n\t\t\t\t}]\n\t\t\t};\n\t\t\treturn;\n\t\t}\n\t\tconst item = target[regex];\n\t\titem.score += regex.length;\n\t\titem.slices.push({\n\t\t\tindex,\n\t\t\tslice\n\t\t});\n\t};\n\tfor (let index = 0; index < items.length; index++) {\n\t\tconst baseItem = items[index];\n\t\tswitch (baseItem.type) {\n\t\t\tcase \"optional\":\n\t\t\tcase \"utf16\":\n\t\t\t\taddMapItem(startRegex, index, baseItem.regex, \"full\");\n\t\t\t\taddMapItem(endRegex, index, baseItem.regex, \"full\");\n\t\t\t\tbreak;\n\t\t\tcase \"sequence\": {\n\t\t\t\taddMapItem(startRegex, index, baseItem.regex, \"full\");\n\t\t\t\taddMapItem(endRegex, index, baseItem.regex, \"full\");\n\t\t\t\tconst sequence = baseItem.items;\n\t\t\t\tfor (let i = 1; i < sequence.length; i++) {\n\t\t\t\t\tconst startSequence = createSequenceEmojiRegexItem(sequence.slice(0, i));\n\t\t\t\t\taddMapItem(startRegex, index, startSequence.regex, i);\n\t\t\t\t\tconst endSequence = createSequenceEmojiRegexItem(sequence.slice(i));\n\t\t\t\t\taddMapItem(endRegex, index, endSequence.regex, i);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"set\": throw new Error(\"Unexpected set within a set\");\n\t\t\tdefault: assertNever(baseItem);\n\t\t}\n\t}\n\tlet result;\n\tconst checkResults = (target, type) => {\n\t\tfor (const regex in target) {\n\t\t\tconst item = target[regex];\n\t\t\tif (!item.score) continue;\n\t\t\tif (!result || result.score < item.score) {\n\t\t\t\tresult = {\n\t\t\t\t\tscore: item.score,\n\t\t\t\t\tsequences: [{\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\tslices: item.slices\n\t\t\t\t\t}]\n\t\t\t\t};\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (result.score === item.score) result.sequences.push({\n\t\t\t\ttype,\n\t\t\t\tslices: item.slices\n\t\t\t});\n\t\t}\n\t};\n\tcheckResults(startRegex, \"start\");\n\tcheckResults(endRegex, \"end\");\n\treturn result;\n}\n/**\n* Merge similar sequences\n*\n* Accepts callback to run optimisation on created subset\n*/\nfunction mergeSimilarRegexItemSequences(items, merge, optimise) {\n\tconst { type, slices } = merge;\n\tconst indexes = /* @__PURE__ */ new Set();\n\tlet hasFullSequence = false;\n\tlet longestMatch = 0;\n\tlet longestMatchIndex = -1;\n\tconst differentSequences = [];\n\tfor (let i = 0; i < slices.length; i++) {\n\t\tconst { index, slice } = slices[i];\n\t\tconst item = items[index];\n\t\tlet length;\n\t\tif (slice === \"full\") {\n\t\t\thasFullSequence = true;\n\t\t\tif (item.type === \"sequence\") length = item.items.length;\n\t\t\telse length = 1;\n\t\t} else {\n\t\t\tif (item.type !== \"sequence\") throw new Error(`Unexpected partial match for type \"${item.type}\"`);\n\t\t\tlength = type === \"start\" ? slice : item.items.length - slice;\n\t\t\tdifferentSequences.push(type === \"start\" ? item.items.slice(slice) : item.items.slice(0, slice));\n\t\t}\n\t\tif (length > longestMatch) {\n\t\t\tlongestMatchIndex = index;\n\t\t\tlongestMatch = length;\n\t\t}\n\t\tindexes.add(index);\n\t}\n\tif (longestMatch < 1 || longestMatchIndex < 0) throw new Error(\"Cannot find common sequence\");\n\tconst commonItem = items[longestMatchIndex];\n\tlet sequence;\n\tif (commonItem.type !== \"sequence\") {\n\t\tif (longestMatch !== 1) throw new Error(\"Something went wrong. Cannot have long match in non-sequence\");\n\t\tsequence = [commonItem];\n\t} else sequence = type === \"start\" ? commonItem.items.slice(0, longestMatch) : commonItem.items.slice(commonItem.items.length - longestMatch);\n\tconst setItems = [];\n\tfor (let i = 0; i < differentSequences.length; i++) {\n\t\tconst list = differentSequences[i];\n\t\tif (list.length === 1) setItems.push(list[0]);\n\t\telse setItems.push(createSequenceEmojiRegexItem(list));\n\t}\n\tconst set = createSetEmojiRegexItem(setItems);\n\tlet mergedChunk = set.sets.length === 1 ? set.sets[0] : optimise ? optimise(set) : set;\n\tif (hasFullSequence) mergedChunk = createOptionalEmojiRegexItem(mergedChunk);\n\tsequence[type === \"start\" ? \"push\" : \"unshift\"](mergedChunk);\n\treturn [createSequenceEmojiRegexItem(sequence), ...items.filter((item, index) => !indexes.has(index))];\n}\n/**\n* Merge similar items\n*/\nfunction mergeSimilarItemsInSet(set) {\n\tconst updatedSet = optimiseNumbersSet(set);\n\tif (updatedSet.type !== \"set\") return updatedSet;\n\tset = updatedSet;\n\tlet merges;\n\twhile (merges = findSimilarRegexItemSequences(set.sets)) {\n\t\tconst sequences = merges.sequences;\n\t\tif (sequences.length === 1) {\n\t\t\tconst merged = mergeSimilarRegexItemSequences(set.sets.map((item) => cloneEmojiRegexItem(item, true)), sequences[0], mergeSimilarItemsInSet);\n\t\t\tif (merged.length === 1) return merged[0];\n\t\t\tset = createSetEmojiRegexItem(merged);\n\t\t\tcontinue;\n\t\t}\n\t\tlet newItem;\n\t\tfor (let i = 0; i < sequences.length; i++) {\n\t\t\tconst merged = mergeSimilarRegexItemSequences(set.sets.map((item) => cloneEmojiRegexItem(item, true)), sequences[i], mergeSimilarItemsInSet);\n\t\t\tconst mergedItem = merged.length === 1 ? merged[0] : createSetEmojiRegexItem(merged);\n\t\t\tif (!newItem || mergedItem.regex.length < newItem.regex.length) newItem = mergedItem;\n\t\t}\n\t\tif (!newItem) throw new Error(\"Empty sequences list\");\n\t\tif (newItem.type !== \"set\") return newItem;\n\t\tset = newItem;\n\t}\n\treturn set;\n}\n\nexport { findSimilarRegexItemSequences, mergeSimilarItemsInSet, mergeSimilarRegexItemSequences };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}