{"ast":null,"code":"import _objectSpread from \"/home/saiadmin/k3s-cluster/dashboard/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { __name, log } from \"./chunk-AGHRB4JF.mjs\";\n\n// src/rendering-util/layout-algorithms/cose-bilkent/cytoscape-setup.ts\nimport cytoscape from \"cytoscape\";\nimport coseBilkent from \"cytoscape-cose-bilkent\";\nimport { select } from \"d3\";\ncytoscape.use(coseBilkent);\nfunction addNodes(nodes, cy) {\n  nodes.forEach(node => {\n    var _node$padding, _node$x, _node$y;\n    const nodeData = {\n      id: node.id,\n      labelText: node.label,\n      height: node.height,\n      width: node.width,\n      padding: (_node$padding = node.padding) !== null && _node$padding !== void 0 ? _node$padding : 0\n    };\n    Object.keys(node).forEach(key => {\n      if (![\"id\", \"label\", \"height\", \"width\", \"padding\", \"x\", \"y\"].includes(key)) {\n        nodeData[key] = node[key];\n      }\n    });\n    cy.add({\n      group: \"nodes\",\n      data: nodeData,\n      position: {\n        x: (_node$x = node.x) !== null && _node$x !== void 0 ? _node$x : 0,\n        y: (_node$y = node.y) !== null && _node$y !== void 0 ? _node$y : 0\n      }\n    });\n  });\n}\n__name(addNodes, \"addNodes\");\nfunction addEdges(edges, cy) {\n  edges.forEach(edge => {\n    const edgeData = {\n      id: edge.id,\n      source: edge.start,\n      target: edge.end\n    };\n    Object.keys(edge).forEach(key => {\n      if (![\"id\", \"start\", \"end\"].includes(key)) {\n        edgeData[key] = edge[key];\n      }\n    });\n    cy.add({\n      group: \"edges\",\n      data: edgeData\n    });\n  });\n}\n__name(addEdges, \"addEdges\");\nfunction createCytoscapeInstance(data) {\n  return new Promise(resolve => {\n    const renderEl = select(\"body\").append(\"div\").attr(\"id\", \"cy\").attr(\"style\", \"display:none\");\n    const cy = cytoscape({\n      container: document.getElementById(\"cy\"),\n      // container to render in\n      style: [{\n        selector: \"edge\",\n        style: {\n          \"curve-style\": \"bezier\"\n        }\n      }]\n    });\n    renderEl.remove();\n    addNodes(data.nodes, cy);\n    addEdges(data.edges, cy);\n    cy.nodes().forEach(function (n) {\n      n.layoutDimensions = () => {\n        const nodeData = n.data();\n        return {\n          w: nodeData.width,\n          h: nodeData.height\n        };\n      };\n    });\n    const layoutConfig = {\n      name: \"cose-bilkent\",\n      // @ts-ignore Types for cose-bilkent are not correct?\n      quality: \"proof\",\n      styleEnabled: false,\n      animate: false\n    };\n    cy.layout(layoutConfig).run();\n    cy.ready(e => {\n      log.info(\"Cytoscape ready\", e);\n      resolve(cy);\n    });\n  });\n}\n__name(createCytoscapeInstance, \"createCytoscapeInstance\");\nfunction extractPositionedNodes(cy) {\n  return cy.nodes().map(node => {\n    const data = node.data();\n    const position = node.position();\n    const positionedNode = {\n      id: data.id,\n      x: position.x,\n      y: position.y\n    };\n    Object.keys(data).forEach(key => {\n      if (key !== \"id\") {\n        positionedNode[key] = data[key];\n      }\n    });\n    return positionedNode;\n  });\n}\n__name(extractPositionedNodes, \"extractPositionedNodes\");\nfunction extractPositionedEdges(cy) {\n  return cy.edges().map(edge => {\n    const data = edge.data();\n    const rscratch = edge._private.rscratch;\n    const positionedEdge = {\n      id: data.id,\n      source: data.source,\n      target: data.target,\n      startX: rscratch.startX,\n      startY: rscratch.startY,\n      midX: rscratch.midX,\n      midY: rscratch.midY,\n      endX: rscratch.endX,\n      endY: rscratch.endY\n    };\n    Object.keys(data).forEach(key => {\n      if (![\"id\", \"source\", \"target\"].includes(key)) {\n        positionedEdge[key] = data[key];\n      }\n    });\n    return positionedEdge;\n  });\n}\n__name(extractPositionedEdges, \"extractPositionedEdges\");\n\n// src/rendering-util/layout-algorithms/cose-bilkent/layout.ts\nasync function executeCoseBilkentLayout(data, _config) {\n  log.debug(\"Starting cose-bilkent layout algorithm\");\n  try {\n    validateLayoutData(data);\n    const cy = await createCytoscapeInstance(data);\n    const positionedNodes = extractPositionedNodes(cy);\n    const positionedEdges = extractPositionedEdges(cy);\n    log.debug(\"Layout completed: \".concat(positionedNodes.length, \" nodes, \").concat(positionedEdges.length, \" edges\"));\n    return {\n      nodes: positionedNodes,\n      edges: positionedEdges\n    };\n  } catch (error) {\n    log.error(\"Error in cose-bilkent layout algorithm:\", error);\n    throw error;\n  }\n}\n__name(executeCoseBilkentLayout, \"executeCoseBilkentLayout\");\nfunction validateLayoutData(data) {\n  if (!data) {\n    throw new Error(\"Layout data is required\");\n  }\n  if (!data.config) {\n    throw new Error(\"Configuration is required in layout data\");\n  }\n  if (!data.rootNode) {\n    throw new Error(\"Root node is required\");\n  }\n  if (!data.nodes || !Array.isArray(data.nodes)) {\n    throw new Error(\"No nodes found in layout data\");\n  }\n  if (!Array.isArray(data.edges)) {\n    throw new Error(\"Edges array is required in layout data\");\n  }\n  return true;\n}\n__name(validateLayoutData, \"validateLayoutData\");\n\n// src/rendering-util/layout-algorithms/cose-bilkent/render.ts\nvar render = /* @__PURE__ */__name(async (data4Layout, svg, _ref, _ref2) => {\n  let {\n    insertCluster,\n    insertEdge,\n    insertEdgeLabel,\n    insertMarkers,\n    insertNode,\n    log: log2,\n    positionEdgeLabel\n  } = _ref;\n  let {\n    algorithm: _algorithm\n  } = _ref2;\n  const nodeDb = {};\n  const clusterDb = {};\n  const element = svg.select(\"g\");\n  insertMarkers(element, data4Layout.markers, data4Layout.type, data4Layout.diagramId);\n  const subGraphsEl = element.insert(\"g\").attr(\"class\", \"subgraphs\");\n  const edgePaths = element.insert(\"g\").attr(\"class\", \"edgePaths\");\n  const edgeLabels = element.insert(\"g\").attr(\"class\", \"edgeLabels\");\n  const nodes = element.insert(\"g\").attr(\"class\", \"nodes\");\n  log2.debug(\"Inserting nodes into DOM for dimension calculation\");\n  await Promise.all(data4Layout.nodes.map(async node => {\n    if (node.isGroup) {\n      const clusterNode = _objectSpread({}, node);\n      clusterDb[node.id] = clusterNode;\n      nodeDb[node.id] = clusterNode;\n      await insertCluster(subGraphsEl, node);\n    } else {\n      const nodeWithPosition = _objectSpread({}, node);\n      nodeDb[node.id] = nodeWithPosition;\n      const nodeEl = await insertNode(nodes, node, {\n        config: data4Layout.config,\n        dir: data4Layout.direction || \"TB\"\n      });\n      const boundingBox = nodeEl.node().getBBox();\n      nodeWithPosition.width = boundingBox.width;\n      nodeWithPosition.height = boundingBox.height;\n      nodeWithPosition.domId = nodeEl;\n      log2.debug(\"Node \".concat(node.id, \" dimensions: \").concat(boundingBox.width, \"x\").concat(boundingBox.height));\n    }\n  }));\n  log2.debug(\"Running cose-bilkent layout algorithm\");\n  const updatedLayoutData = _objectSpread(_objectSpread({}, data4Layout), {}, {\n    nodes: data4Layout.nodes.map(node => {\n      const nodeWithDimensions = nodeDb[node.id];\n      return _objectSpread(_objectSpread({}, node), {}, {\n        width: nodeWithDimensions.width,\n        height: nodeWithDimensions.height\n      });\n    })\n  });\n  const layoutResult = await executeCoseBilkentLayout(updatedLayoutData, data4Layout.config);\n  log2.debug(\"Positioning nodes based on layout results\");\n  layoutResult.nodes.forEach(positionedNode => {\n    const node = nodeDb[positionedNode.id];\n    if (node !== null && node !== void 0 && node.domId) {\n      node.domId.attr(\"transform\", \"translate(\".concat(positionedNode.x, \", \").concat(positionedNode.y, \")\"));\n      node.x = positionedNode.x;\n      node.y = positionedNode.y;\n      log2.debug(\"Positioned node \".concat(node.id, \" at center (\").concat(positionedNode.x, \", \").concat(positionedNode.y, \")\"));\n    }\n  });\n  layoutResult.edges.forEach(positionedEdge => {\n    const edge = data4Layout.edges.find(e => e.id === positionedEdge.id);\n    if (edge) {\n      edge.points = [{\n        x: positionedEdge.startX,\n        y: positionedEdge.startY\n      }, {\n        x: positionedEdge.midX,\n        y: positionedEdge.midY\n      }, {\n        x: positionedEdge.endX,\n        y: positionedEdge.endY\n      }];\n    }\n  });\n  log2.debug(\"Inserting and positioning edges\");\n  await Promise.all(data4Layout.edges.map(async edge => {\n    var _edge$start, _edge$end;\n    const _edgeLabel = await insertEdgeLabel(edgeLabels, edge);\n    const startNode = nodeDb[(_edge$start = edge.start) !== null && _edge$start !== void 0 ? _edge$start : \"\"];\n    const endNode = nodeDb[(_edge$end = edge.end) !== null && _edge$end !== void 0 ? _edge$end : \"\"];\n    if (startNode && endNode) {\n      const positionedEdge = layoutResult.edges.find(e => e.id === edge.id);\n      if (positionedEdge) {\n        log2.debug(\"APA01 positionedEdge\", positionedEdge);\n        const edgeWithPath = _objectSpread({}, edge);\n        const paths = insertEdge(edgePaths, edgeWithPath, clusterDb, data4Layout.type, startNode, endNode, data4Layout.diagramId);\n        positionEdgeLabel(edgeWithPath, paths);\n      } else {\n        const edgeWithPath = _objectSpread(_objectSpread({}, edge), {}, {\n          points: [{\n            x: startNode.x || 0,\n            y: startNode.y || 0\n          }, {\n            x: endNode.x || 0,\n            y: endNode.y || 0\n          }]\n        });\n        const paths = insertEdge(edgePaths, edgeWithPath, clusterDb, data4Layout.type, startNode, endNode, data4Layout.diagramId);\n        positionEdgeLabel(edgeWithPath, paths);\n      }\n    }\n  }));\n  log2.debug(\"Cose-bilkent rendering completed\");\n}, \"render\");\n\n// src/rendering-util/layout-algorithms/cose-bilkent/index.ts\nvar render2 = render;\nexport { render2 as render };","map":{"version":3,"names":["__name","log","cytoscape","coseBilkent","select","use","addNodes","nodes","cy","forEach","node","_node$padding","_node$x","_node$y","nodeData","id","labelText","label","height","width","padding","Object","keys","key","includes","add","group","data","position","x","y","addEdges","edges","edge","edgeData","source","start","target","end","createCytoscapeInstance","Promise","resolve","renderEl","append","attr","container","document","getElementById","style","selector","remove","n","layoutDimensions","w","h","layoutConfig","name","quality","styleEnabled","animate","layout","run","ready","e","info","extractPositionedNodes","map","positionedNode","extractPositionedEdges","rscratch","_private","positionedEdge","startX","startY","midX","midY","endX","endY","executeCoseBilkentLayout","_config","debug","validateLayoutData","positionedNodes","positionedEdges","concat","length","error","Error","config","rootNode","Array","isArray","render","data4Layout","svg","_ref","_ref2","insertCluster","insertEdge","insertEdgeLabel","insertMarkers","insertNode","log2","positionEdgeLabel","algorithm","_algorithm","nodeDb","clusterDb","element","markers","type","diagramId","subGraphsEl","insert","edgePaths","edgeLabels","all","isGroup","clusterNode","_objectSpread","nodeWithPosition","nodeEl","dir","direction","boundingBox","getBBox","domId","updatedLayoutData","nodeWithDimensions","layoutResult","find","points","_edge$start","_edge$end","_edgeLabel","startNode","endNode","edgeWithPath","paths","render2"],"sources":["/home/saiadmin/k3s-cluster/dashboard/frontend/node_modules/mermaid/dist/chunks/mermaid.core/cose-bilkent-S5V4N54A.mjs"],"sourcesContent":["import {\n  __name,\n  log\n} from \"./chunk-AGHRB4JF.mjs\";\n\n// src/rendering-util/layout-algorithms/cose-bilkent/cytoscape-setup.ts\nimport cytoscape from \"cytoscape\";\nimport coseBilkent from \"cytoscape-cose-bilkent\";\nimport { select } from \"d3\";\ncytoscape.use(coseBilkent);\nfunction addNodes(nodes, cy) {\n  nodes.forEach((node) => {\n    const nodeData = {\n      id: node.id,\n      labelText: node.label,\n      height: node.height,\n      width: node.width,\n      padding: node.padding ?? 0\n    };\n    Object.keys(node).forEach((key) => {\n      if (![\"id\", \"label\", \"height\", \"width\", \"padding\", \"x\", \"y\"].includes(key)) {\n        nodeData[key] = node[key];\n      }\n    });\n    cy.add({\n      group: \"nodes\",\n      data: nodeData,\n      position: {\n        x: node.x ?? 0,\n        y: node.y ?? 0\n      }\n    });\n  });\n}\n__name(addNodes, \"addNodes\");\nfunction addEdges(edges, cy) {\n  edges.forEach((edge) => {\n    const edgeData = {\n      id: edge.id,\n      source: edge.start,\n      target: edge.end\n    };\n    Object.keys(edge).forEach((key) => {\n      if (![\"id\", \"start\", \"end\"].includes(key)) {\n        edgeData[key] = edge[key];\n      }\n    });\n    cy.add({\n      group: \"edges\",\n      data: edgeData\n    });\n  });\n}\n__name(addEdges, \"addEdges\");\nfunction createCytoscapeInstance(data) {\n  return new Promise((resolve) => {\n    const renderEl = select(\"body\").append(\"div\").attr(\"id\", \"cy\").attr(\"style\", \"display:none\");\n    const cy = cytoscape({\n      container: document.getElementById(\"cy\"),\n      // container to render in\n      style: [\n        {\n          selector: \"edge\",\n          style: {\n            \"curve-style\": \"bezier\"\n          }\n        }\n      ]\n    });\n    renderEl.remove();\n    addNodes(data.nodes, cy);\n    addEdges(data.edges, cy);\n    cy.nodes().forEach(function(n) {\n      n.layoutDimensions = () => {\n        const nodeData = n.data();\n        return { w: nodeData.width, h: nodeData.height };\n      };\n    });\n    const layoutConfig = {\n      name: \"cose-bilkent\",\n      // @ts-ignore Types for cose-bilkent are not correct?\n      quality: \"proof\",\n      styleEnabled: false,\n      animate: false\n    };\n    cy.layout(layoutConfig).run();\n    cy.ready((e) => {\n      log.info(\"Cytoscape ready\", e);\n      resolve(cy);\n    });\n  });\n}\n__name(createCytoscapeInstance, \"createCytoscapeInstance\");\nfunction extractPositionedNodes(cy) {\n  return cy.nodes().map((node) => {\n    const data = node.data();\n    const position = node.position();\n    const positionedNode = {\n      id: data.id,\n      x: position.x,\n      y: position.y\n    };\n    Object.keys(data).forEach((key) => {\n      if (key !== \"id\") {\n        positionedNode[key] = data[key];\n      }\n    });\n    return positionedNode;\n  });\n}\n__name(extractPositionedNodes, \"extractPositionedNodes\");\nfunction extractPositionedEdges(cy) {\n  return cy.edges().map((edge) => {\n    const data = edge.data();\n    const rscratch = edge._private.rscratch;\n    const positionedEdge = {\n      id: data.id,\n      source: data.source,\n      target: data.target,\n      startX: rscratch.startX,\n      startY: rscratch.startY,\n      midX: rscratch.midX,\n      midY: rscratch.midY,\n      endX: rscratch.endX,\n      endY: rscratch.endY\n    };\n    Object.keys(data).forEach((key) => {\n      if (![\"id\", \"source\", \"target\"].includes(key)) {\n        positionedEdge[key] = data[key];\n      }\n    });\n    return positionedEdge;\n  });\n}\n__name(extractPositionedEdges, \"extractPositionedEdges\");\n\n// src/rendering-util/layout-algorithms/cose-bilkent/layout.ts\nasync function executeCoseBilkentLayout(data, _config) {\n  log.debug(\"Starting cose-bilkent layout algorithm\");\n  try {\n    validateLayoutData(data);\n    const cy = await createCytoscapeInstance(data);\n    const positionedNodes = extractPositionedNodes(cy);\n    const positionedEdges = extractPositionedEdges(cy);\n    log.debug(`Layout completed: ${positionedNodes.length} nodes, ${positionedEdges.length} edges`);\n    return {\n      nodes: positionedNodes,\n      edges: positionedEdges\n    };\n  } catch (error) {\n    log.error(\"Error in cose-bilkent layout algorithm:\", error);\n    throw error;\n  }\n}\n__name(executeCoseBilkentLayout, \"executeCoseBilkentLayout\");\nfunction validateLayoutData(data) {\n  if (!data) {\n    throw new Error(\"Layout data is required\");\n  }\n  if (!data.config) {\n    throw new Error(\"Configuration is required in layout data\");\n  }\n  if (!data.rootNode) {\n    throw new Error(\"Root node is required\");\n  }\n  if (!data.nodes || !Array.isArray(data.nodes)) {\n    throw new Error(\"No nodes found in layout data\");\n  }\n  if (!Array.isArray(data.edges)) {\n    throw new Error(\"Edges array is required in layout data\");\n  }\n  return true;\n}\n__name(validateLayoutData, \"validateLayoutData\");\n\n// src/rendering-util/layout-algorithms/cose-bilkent/render.ts\nvar render = /* @__PURE__ */ __name(async (data4Layout, svg, {\n  insertCluster,\n  insertEdge,\n  insertEdgeLabel,\n  insertMarkers,\n  insertNode,\n  log: log2,\n  positionEdgeLabel\n}, { algorithm: _algorithm }) => {\n  const nodeDb = {};\n  const clusterDb = {};\n  const element = svg.select(\"g\");\n  insertMarkers(element, data4Layout.markers, data4Layout.type, data4Layout.diagramId);\n  const subGraphsEl = element.insert(\"g\").attr(\"class\", \"subgraphs\");\n  const edgePaths = element.insert(\"g\").attr(\"class\", \"edgePaths\");\n  const edgeLabels = element.insert(\"g\").attr(\"class\", \"edgeLabels\");\n  const nodes = element.insert(\"g\").attr(\"class\", \"nodes\");\n  log2.debug(\"Inserting nodes into DOM for dimension calculation\");\n  await Promise.all(\n    data4Layout.nodes.map(async (node) => {\n      if (node.isGroup) {\n        const clusterNode = { ...node };\n        clusterDb[node.id] = clusterNode;\n        nodeDb[node.id] = clusterNode;\n        await insertCluster(subGraphsEl, node);\n      } else {\n        const nodeWithPosition = { ...node };\n        nodeDb[node.id] = nodeWithPosition;\n        const nodeEl = await insertNode(nodes, node, {\n          config: data4Layout.config,\n          dir: data4Layout.direction || \"TB\"\n        });\n        const boundingBox = nodeEl.node().getBBox();\n        nodeWithPosition.width = boundingBox.width;\n        nodeWithPosition.height = boundingBox.height;\n        nodeWithPosition.domId = nodeEl;\n        log2.debug(`Node ${node.id} dimensions: ${boundingBox.width}x${boundingBox.height}`);\n      }\n    })\n  );\n  log2.debug(\"Running cose-bilkent layout algorithm\");\n  const updatedLayoutData = {\n    ...data4Layout,\n    nodes: data4Layout.nodes.map((node) => {\n      const nodeWithDimensions = nodeDb[node.id];\n      return {\n        ...node,\n        width: nodeWithDimensions.width,\n        height: nodeWithDimensions.height\n      };\n    })\n  };\n  const layoutResult = await executeCoseBilkentLayout(updatedLayoutData, data4Layout.config);\n  log2.debug(\"Positioning nodes based on layout results\");\n  layoutResult.nodes.forEach((positionedNode) => {\n    const node = nodeDb[positionedNode.id];\n    if (node?.domId) {\n      node.domId.attr(\n        \"transform\",\n        `translate(${positionedNode.x}, ${positionedNode.y})`\n      );\n      node.x = positionedNode.x;\n      node.y = positionedNode.y;\n      log2.debug(`Positioned node ${node.id} at center (${positionedNode.x}, ${positionedNode.y})`);\n    }\n  });\n  layoutResult.edges.forEach((positionedEdge) => {\n    const edge = data4Layout.edges.find((e) => e.id === positionedEdge.id);\n    if (edge) {\n      edge.points = [\n        { x: positionedEdge.startX, y: positionedEdge.startY },\n        { x: positionedEdge.midX, y: positionedEdge.midY },\n        { x: positionedEdge.endX, y: positionedEdge.endY }\n      ];\n    }\n  });\n  log2.debug(\"Inserting and positioning edges\");\n  await Promise.all(\n    data4Layout.edges.map(async (edge) => {\n      const _edgeLabel = await insertEdgeLabel(edgeLabels, edge);\n      const startNode = nodeDb[edge.start ?? \"\"];\n      const endNode = nodeDb[edge.end ?? \"\"];\n      if (startNode && endNode) {\n        const positionedEdge = layoutResult.edges.find((e) => e.id === edge.id);\n        if (positionedEdge) {\n          log2.debug(\"APA01 positionedEdge\", positionedEdge);\n          const edgeWithPath = { ...edge };\n          const paths = insertEdge(\n            edgePaths,\n            edgeWithPath,\n            clusterDb,\n            data4Layout.type,\n            startNode,\n            endNode,\n            data4Layout.diagramId\n          );\n          positionEdgeLabel(edgeWithPath, paths);\n        } else {\n          const edgeWithPath = {\n            ...edge,\n            points: [\n              { x: startNode.x || 0, y: startNode.y || 0 },\n              { x: endNode.x || 0, y: endNode.y || 0 }\n            ]\n          };\n          const paths = insertEdge(\n            edgePaths,\n            edgeWithPath,\n            clusterDb,\n            data4Layout.type,\n            startNode,\n            endNode,\n            data4Layout.diagramId\n          );\n          positionEdgeLabel(edgeWithPath, paths);\n        }\n      }\n    })\n  );\n  log2.debug(\"Cose-bilkent rendering completed\");\n}, \"render\");\n\n// src/rendering-util/layout-algorithms/cose-bilkent/index.ts\nvar render2 = render;\nexport {\n  render2 as render\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}